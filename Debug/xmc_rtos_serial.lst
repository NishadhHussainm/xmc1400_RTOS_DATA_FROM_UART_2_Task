
xmc_rtos_serial.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005958  10001000  10001000  00001000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .VENEER_Code  00000144  2000000c  10006958  0000800c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 Stack         00000400  20000150  00000000  00000150  2**0
                  ALLOC
  3 .data         000000f4  20000550  10006a9c  00008550  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000001d4  20000644  000004f4  00008644  2**2
                  ALLOC
  5 .no_init      00000004  20003ffc  00003eac  00000150  2**2
                  ALLOC
  6 .debug_aranges 000011a8  00000000  00000000  00008648  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00018cb9  00000000  00000000  000097f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000378e  00000000  00000000  000224a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00009418  00000000  00000000  00025c37  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00003df0  00000000  00000000  0002f050  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000a7a6  00000000  00000000  00032e40  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000638f  00000000  00000000  0003d5e6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000f98  00000000  00000000  00043978  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .build_attributes 000007c8  00000000  00000000  00044910  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

10001000 <__Vectors>:
10001000:	50 05 00 20 1d 10 00 10 00 00 00 00 9d 10 00 10     P.. ............
10001010:	00 18 04 00 00 01 00 00 00 00 00 80                 ............

1000101c <Reset_Handler>:
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
1000101c:	4911      	ldr	r1, [pc, #68]	; (10001064 <__copy_data+0xe>)
	ldr	r2, =VeneerStart
1000101e:	4a12      	ldr	r2, [pc, #72]	; (10001068 <__copy_data+0x12>)
	ldr	r3, =VeneerEnd
10001020:	4b12      	ldr	r3, [pc, #72]	; (1000106c <__copy_data+0x16>)
	bl  __copy_data
10001022:	f000 f818 	bl	10001056 <__copy_data>

    ldr  r0, =SystemInit
10001026:	4812      	ldr	r0, [pc, #72]	; (10001070 <__copy_data+0x1a>)
    blx  r0
10001028:	4780      	blx	r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
1000102a:	4912      	ldr	r1, [pc, #72]	; (10001074 <__copy_data+0x1e>)
	ldr	r2, =__data_start
1000102c:	4a12      	ldr	r2, [pc, #72]	; (10001078 <__copy_data+0x22>)
	ldr	r3, =__data_end
1000102e:	4b13      	ldr	r3, [pc, #76]	; (1000107c <__copy_data+0x26>)
	bl  __copy_data
10001030:	f000 f811 	bl	10001056 <__copy_data>

/* RAM code */
	ldr	r1, =__ram_code_load
10001034:	4912      	ldr	r1, [pc, #72]	; (10001080 <__copy_data+0x2a>)
	ldr	r2, =__ram_code_start
10001036:	4a13      	ldr	r2, [pc, #76]	; (10001084 <__copy_data+0x2e>)
	ldr	r3, =__ram_code_end
10001038:	4b13      	ldr	r3, [pc, #76]	; (10001088 <__copy_data+0x32>)
	bl  __copy_data
1000103a:	f000 f80c 	bl	10001056 <__copy_data>
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
1000103e:	4913      	ldr	r1, [pc, #76]	; (1000108c <__copy_data+0x36>)
	ldr	r2, =__bss_end
10001040:	4a13      	ldr	r2, [pc, #76]	; (10001090 <__copy_data+0x3a>)

	movs	r0, 0
10001042:	2000      	movs	r0, #0

	subs	r2, r1
10001044:	1a52      	subs	r2, r2, r1
	ble	.L_loop3_done
10001046:	dd02      	ble.n	1000104e <Reset_Handler+0x32>

.L_loop3:
	subs	r2, #4
10001048:	3a04      	subs	r2, #4
	str	r0, [r1, r2]
1000104a:	5088      	str	r0, [r1, r2]
	bgt	.L_loop3
1000104c:	dcfc      	bgt.n	10001048 <Reset_Handler+0x2c>
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
1000104e:	4811      	ldr	r0, [pc, #68]	; (10001094 <__copy_data+0x3e>)
    blx  r0
10001050:	4780      	blx	r0
#endif

    ldr  r0, =main
10001052:	4811      	ldr	r0, [pc, #68]	; (10001098 <__copy_data+0x42>)
    blx  r0
10001054:	4780      	blx	r0

10001056 <__copy_data>:
 *    r3: end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 *  Uses r0
 */
	subs	r3, r2
10001056:	1a9b      	subs	r3, r3, r2
	ble	.L_loop_done
10001058:	dd03      	ble.n	10001062 <__copy_data+0xc>

.L_loop:
	subs	r3, #4
1000105a:	3b04      	subs	r3, #4
	ldr	r0, [r1,r3]
1000105c:	58c8      	ldr	r0, [r1, r3]
	str	r0, [r2,r3]
1000105e:	50d0      	str	r0, [r2, r3]
	bgt	.L_loop
10001060:	dcfb      	bgt.n	1000105a <__copy_data+0x4>

.L_loop_done:
	bx  lr
10001062:	4770      	bx	lr
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001064:	10006958 	.word	0x10006958
	ldr	r2, =VeneerStart
10001068:	2000000c 	.word	0x2000000c
	ldr	r3, =VeneerEnd
1000106c:	20000150 	.word	0x20000150
	bl  __copy_data

    ldr  r0, =SystemInit
10001070:	100010a1 	.word	0x100010a1
    blx  r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001074:	10006a9c 	.word	0x10006a9c
	ldr	r2, =__data_start
10001078:	20000550 	.word	0x20000550
	ldr	r3, =__data_end
1000107c:	20000644 	.word	0x20000644
	bl  __copy_data

/* RAM code */
	ldr	r1, =__ram_code_load
10001080:	10006b90 	.word	0x10006b90
	ldr	r2, =__ram_code_start
10001084:	20000644 	.word	0x20000644
	ldr	r3, =__ram_code_end
10001088:	20000644 	.word	0x20000644
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
1000108c:	20000644 	.word	0x20000644
	ldr	r2, =__bss_end
10001090:	20000814 	.word	0x20000814
	bgt	.L_loop3
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
10001094:	100064b5 	.word	0x100064b5
    blx  r0
#endif

    ldr  r0, =main
10001098:	10006449 	.word	0x10006449

1000109c <HardFault_Handler>:
    
    .thumb_func
    .weak Default_handler
    .type Default_handler, %function
Default_Handler:
    b  .
1000109c:	e7fe      	b.n	1000109c <HardFault_Handler>
	...

100010a0 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{
100010a0:	b580      	push	{r7, lr}
100010a2:	af00      	add	r7, sp, #0
  SystemCoreSetup();
100010a4:	f004 fdd4 	bl	10005c50 <SystemCoreSetup>
  SystemCoreClockSetup();
100010a8:	f004 fe20 	bl	10005cec <SystemCoreClockSetup>
}
100010ac:	46bd      	mov	sp, r7
100010ae:	bd80      	pop	{r7, pc}

100010b0 <SystemCoreClockUpdate>:

  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
100010b0:	b580      	push	{r7, lr}
100010b2:	af00      	add	r7, sp, #0
  static uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
100010b4:	4b2a      	ldr	r3, [pc, #168]	; (10001160 <SystemCoreClockUpdate+0xb0>)
100010b6:	681a      	ldr	r2, [r3, #0]
100010b8:	23ff      	movs	r3, #255	; 0xff
100010ba:	021b      	lsls	r3, r3, #8
100010bc:	4013      	ands	r3, r2
100010be:	0a1a      	lsrs	r2, r3, #8
100010c0:	4b28      	ldr	r3, [pc, #160]	; (10001164 <SystemCoreClockUpdate+0xb4>)
100010c2:	601a      	str	r2, [r3, #0]

  if (IDIV != 0)
100010c4:	4b27      	ldr	r3, [pc, #156]	; (10001164 <SystemCoreClockUpdate+0xb4>)
100010c6:	681b      	ldr	r3, [r3, #0]
100010c8:	2b00      	cmp	r3, #0
100010ca:	d037      	beq.n	1000113c <SystemCoreClockUpdate+0x8c>
  {
    FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
100010cc:	4b24      	ldr	r3, [pc, #144]	; (10001160 <SystemCoreClockUpdate+0xb0>)
100010ce:	681b      	ldr	r3, [r3, #0]
100010d0:	22ff      	movs	r2, #255	; 0xff
100010d2:	401a      	ands	r2, r3
100010d4:	4b24      	ldr	r3, [pc, #144]	; (10001168 <SystemCoreClockUpdate+0xb8>)
100010d6:	601a      	str	r2, [r3, #0]
    FDIV |= ((SCU_CLK->CLKCR1) & SCU_CLK_CLKCR1_FDIV_Msk) << 8;
100010d8:	4b21      	ldr	r3, [pc, #132]	; (10001160 <SystemCoreClockUpdate+0xb0>)
100010da:	69db      	ldr	r3, [r3, #28]
100010dc:	2203      	movs	r2, #3
100010de:	4013      	ands	r3, r2
100010e0:	021a      	lsls	r2, r3, #8
100010e2:	4b21      	ldr	r3, [pc, #132]	; (10001168 <SystemCoreClockUpdate+0xb8>)
100010e4:	681b      	ldr	r3, [r3, #0]
100010e6:	431a      	orrs	r2, r3
100010e8:	4b1f      	ldr	r3, [pc, #124]	; (10001168 <SystemCoreClockUpdate+0xb8>)
100010ea:	601a      	str	r2, [r3, #0]
    
    /* Fractional divider is enabled and used */
    if (((SCU_CLK->CLKCR1) & SCU_CLK_CLKCR1_DCLKSEL_Msk) == 0U)
100010ec:	4b1c      	ldr	r3, [pc, #112]	; (10001160 <SystemCoreClockUpdate+0xb0>)
100010ee:	69da      	ldr	r2, [r3, #28]
100010f0:	2380      	movs	r3, #128	; 0x80
100010f2:	009b      	lsls	r3, r3, #2
100010f4:	4013      	ands	r3, r2
100010f6:	d10e      	bne.n	10001116 <SystemCoreClockUpdate+0x66>
    {
       SystemCoreClock = ((uint32_t)((DCO1_FREQUENCY << 6U) / ((IDIV << 10) + FDIV))) << 4U;
100010f8:	4b1a      	ldr	r3, [pc, #104]	; (10001164 <SystemCoreClockUpdate+0xb4>)
100010fa:	681b      	ldr	r3, [r3, #0]
100010fc:	029a      	lsls	r2, r3, #10
100010fe:	4b1a      	ldr	r3, [pc, #104]	; (10001168 <SystemCoreClockUpdate+0xb8>)
10001100:	681b      	ldr	r3, [r3, #0]
10001102:	18d3      	adds	r3, r2, r3
10001104:	4819      	ldr	r0, [pc, #100]	; (1000116c <SystemCoreClockUpdate+0xbc>)
10001106:	1c19      	adds	r1, r3, #0
10001108:	f000 fe52 	bl	10001db0 <__aeabi_uidiv>
1000110c:	1c03      	adds	r3, r0, #0
1000110e:	011a      	lsls	r2, r3, #4
10001110:	4b17      	ldr	r3, [pc, #92]	; (10001170 <SystemCoreClockUpdate+0xc0>)
10001112:	601a      	str	r2, [r3, #0]
10001114:	e021      	b.n	1000115a <SystemCoreClockUpdate+0xaa>
    }
    else
    {
       SystemCoreClock = ((uint32_t)((OSCHP_GetFrequency() << 6U) / ((IDIV << 10) + FDIV))) << 4U;
10001116:	f000 f82f 	bl	10001178 <OSCHP_GetFrequency>
1000111a:	1c03      	adds	r3, r0, #0
1000111c:	0199      	lsls	r1, r3, #6
1000111e:	4b11      	ldr	r3, [pc, #68]	; (10001164 <SystemCoreClockUpdate+0xb4>)
10001120:	681b      	ldr	r3, [r3, #0]
10001122:	029a      	lsls	r2, r3, #10
10001124:	4b10      	ldr	r3, [pc, #64]	; (10001168 <SystemCoreClockUpdate+0xb8>)
10001126:	681b      	ldr	r3, [r3, #0]
10001128:	18d3      	adds	r3, r2, r3
1000112a:	1c08      	adds	r0, r1, #0
1000112c:	1c19      	adds	r1, r3, #0
1000112e:	f000 fe3f 	bl	10001db0 <__aeabi_uidiv>
10001132:	1c03      	adds	r3, r0, #0
10001134:	011a      	lsls	r2, r3, #4
10001136:	4b0e      	ldr	r3, [pc, #56]	; (10001170 <SystemCoreClockUpdate+0xc0>)
10001138:	601a      	str	r2, [r3, #0]
1000113a:	e00e      	b.n	1000115a <SystemCoreClockUpdate+0xaa>
    }
  }
  else
  {
    /* Fractional divider bypassed. */
    if (((SCU_CLK->CLKCR1) & SCU_CLK_CLKCR1_DCLKSEL_Msk) == 0U)
1000113c:	4b08      	ldr	r3, [pc, #32]	; (10001160 <SystemCoreClockUpdate+0xb0>)
1000113e:	69da      	ldr	r2, [r3, #28]
10001140:	2380      	movs	r3, #128	; 0x80
10001142:	009b      	lsls	r3, r3, #2
10001144:	4013      	ands	r3, r2
10001146:	d103      	bne.n	10001150 <SystemCoreClockUpdate+0xa0>
    {
        SystemCoreClock = DCO1_FREQUENCY;
10001148:	4b09      	ldr	r3, [pc, #36]	; (10001170 <SystemCoreClockUpdate+0xc0>)
1000114a:	4a0a      	ldr	r2, [pc, #40]	; (10001174 <SystemCoreClockUpdate+0xc4>)
1000114c:	601a      	str	r2, [r3, #0]
1000114e:	e004      	b.n	1000115a <SystemCoreClockUpdate+0xaa>
    }
    else
    {
        SystemCoreClock = OSCHP_GetFrequency();
10001150:	f000 f812 	bl	10001178 <OSCHP_GetFrequency>
10001154:	1c02      	adds	r2, r0, #0
10001156:	4b06      	ldr	r3, [pc, #24]	; (10001170 <SystemCoreClockUpdate+0xc0>)
10001158:	601a      	str	r2, [r3, #0]
    }
  }
}
1000115a:	46bd      	mov	sp, r7
1000115c:	bd80      	pop	{r7, pc}
1000115e:	46c0      	nop			; (mov r8, r8)
10001160:	40010300 	.word	0x40010300
10001164:	20000644 	.word	0x20000644
10001168:	20000648 	.word	0x20000648
1000116c:	b71b0000 	.word	0xb71b0000
10001170:	20003ffc 	.word	0x20003ffc
10001174:	02dc6c00 	.word	0x02dc6c00

10001178 <OSCHP_GetFrequency>:

__WEAK uint32_t OSCHP_GetFrequency(void)
{
10001178:	b580      	push	{r7, lr}
1000117a:	af00      	add	r7, sp, #0
  return OSCHP_FREQUENCY;
1000117c:	4b01      	ldr	r3, [pc, #4]	; (10001184 <OSCHP_GetFrequency+0xc>)
}
1000117e:	1c18      	adds	r0, r3, #0
10001180:	46bd      	mov	sp, r7
10001182:	bd80      	pop	{r7, pc}
10001184:	01312d00 	.word	0x01312d00

10001188 <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
10001188:	b590      	push	{r4, r7, lr}
1000118a:	b085      	sub	sp, #20
1000118c:	af00      	add	r7, sp, #0
1000118e:	60f8      	str	r0, [r7, #12]
10001190:	607a      	str	r2, [r7, #4]
10001192:	230b      	movs	r3, #11
10001194:	18fb      	adds	r3, r7, r3
10001196:	1c0a      	adds	r2, r1, #0
10001198:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
  XMC_ASSERT("XMC_GPIO_Init: Invalid input hysteresis", XMC_GPIO_CHECK_INPUT_HYSTERESIS(config->input_hysteresis));

  /* Switch to input */
  port->IOCR[pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
1000119a:	230b      	movs	r3, #11
1000119c:	18fb      	adds	r3, r7, r3
1000119e:	781b      	ldrb	r3, [r3, #0]
100011a0:	089b      	lsrs	r3, r3, #2
100011a2:	b2db      	uxtb	r3, r3
100011a4:	1c18      	adds	r0, r3, #0
100011a6:	230b      	movs	r3, #11
100011a8:	18fb      	adds	r3, r7, r3
100011aa:	781b      	ldrb	r3, [r3, #0]
100011ac:	089b      	lsrs	r3, r3, #2
100011ae:	b2db      	uxtb	r3, r3
100011b0:	1c1a      	adds	r2, r3, #0
100011b2:	68fb      	ldr	r3, [r7, #12]
100011b4:	3204      	adds	r2, #4
100011b6:	0092      	lsls	r2, r2, #2
100011b8:	58d3      	ldr	r3, [r2, r3]
100011ba:	220b      	movs	r2, #11
100011bc:	18ba      	adds	r2, r7, r2
100011be:	7812      	ldrb	r2, [r2, #0]
100011c0:	2103      	movs	r1, #3
100011c2:	400a      	ands	r2, r1
100011c4:	00d2      	lsls	r2, r2, #3
100011c6:	1c11      	adds	r1, r2, #0
100011c8:	22fc      	movs	r2, #252	; 0xfc
100011ca:	408a      	lsls	r2, r1
100011cc:	43d2      	mvns	r2, r2
100011ce:	401a      	ands	r2, r3
100011d0:	1c11      	adds	r1, r2, #0
100011d2:	68fb      	ldr	r3, [r7, #12]
100011d4:	1d02      	adds	r2, r0, #4
100011d6:	0092      	lsls	r2, r2, #2
100011d8:	50d1      	str	r1, [r2, r3]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
100011da:	68fb      	ldr	r3, [r7, #12]
100011dc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
100011de:	220b      	movs	r2, #11
100011e0:	18ba      	adds	r2, r7, r2
100011e2:	7812      	ldrb	r2, [r2, #0]
100011e4:	0052      	lsls	r2, r2, #1
100011e6:	1c11      	adds	r1, r2, #0
100011e8:	2203      	movs	r2, #3
100011ea:	408a      	lsls	r2, r1
100011ec:	43d2      	mvns	r2, r2
100011ee:	401a      	ands	r2, r3
100011f0:	68fb      	ldr	r3, [r7, #12]
100011f2:	675a      	str	r2, [r3, #116]	; 0x74

  /* Set input hysteresis */
  port->PHCR[(uint32_t)pin >> 3U] &= ~(uint32_t)((uint32_t)PORT_PHCR_Msk << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U)));
100011f4:	230b      	movs	r3, #11
100011f6:	18fb      	adds	r3, r7, r3
100011f8:	781b      	ldrb	r3, [r3, #0]
100011fa:	08db      	lsrs	r3, r3, #3
100011fc:	b2db      	uxtb	r3, r3
100011fe:	1c18      	adds	r0, r3, #0
10001200:	230b      	movs	r3, #11
10001202:	18fb      	adds	r3, r7, r3
10001204:	781b      	ldrb	r3, [r3, #0]
10001206:	08db      	lsrs	r3, r3, #3
10001208:	b2db      	uxtb	r3, r3
1000120a:	1c1a      	adds	r2, r3, #0
1000120c:	68fb      	ldr	r3, [r7, #12]
1000120e:	3210      	adds	r2, #16
10001210:	0092      	lsls	r2, r2, #2
10001212:	58d3      	ldr	r3, [r2, r3]
10001214:	220b      	movs	r2, #11
10001216:	18ba      	adds	r2, r7, r2
10001218:	7812      	ldrb	r2, [r2, #0]
1000121a:	2107      	movs	r1, #7
1000121c:	400a      	ands	r2, r1
1000121e:	0092      	lsls	r2, r2, #2
10001220:	1c11      	adds	r1, r2, #0
10001222:	2204      	movs	r2, #4
10001224:	408a      	lsls	r2, r1
10001226:	43d2      	mvns	r2, r2
10001228:	401a      	ands	r2, r3
1000122a:	1c11      	adds	r1, r2, #0
1000122c:	68fb      	ldr	r3, [r7, #12]
1000122e:	1c02      	adds	r2, r0, #0
10001230:	3210      	adds	r2, #16
10001232:	0092      	lsls	r2, r2, #2
10001234:	50d1      	str	r1, [r2, r3]
  port->PHCR[(uint32_t)pin >> 3U] |= (uint32_t)config->input_hysteresis << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U));
10001236:	230b      	movs	r3, #11
10001238:	18fb      	adds	r3, r7, r3
1000123a:	781b      	ldrb	r3, [r3, #0]
1000123c:	08db      	lsrs	r3, r3, #3
1000123e:	b2db      	uxtb	r3, r3
10001240:	1c18      	adds	r0, r3, #0
10001242:	230b      	movs	r3, #11
10001244:	18fb      	adds	r3, r7, r3
10001246:	781b      	ldrb	r3, [r3, #0]
10001248:	08db      	lsrs	r3, r3, #3
1000124a:	b2db      	uxtb	r3, r3
1000124c:	1c1a      	adds	r2, r3, #0
1000124e:	68fb      	ldr	r3, [r7, #12]
10001250:	3210      	adds	r2, #16
10001252:	0092      	lsls	r2, r2, #2
10001254:	58d2      	ldr	r2, [r2, r3]
10001256:	687b      	ldr	r3, [r7, #4]
10001258:	785b      	ldrb	r3, [r3, #1]
1000125a:	1c1c      	adds	r4, r3, #0
1000125c:	230b      	movs	r3, #11
1000125e:	18fb      	adds	r3, r7, r3
10001260:	781b      	ldrb	r3, [r3, #0]
10001262:	2107      	movs	r1, #7
10001264:	400b      	ands	r3, r1
10001266:	009b      	lsls	r3, r3, #2
10001268:	409c      	lsls	r4, r3
1000126a:	1c23      	adds	r3, r4, #0
1000126c:	431a      	orrs	r2, r3
1000126e:	1c11      	adds	r1, r2, #0
10001270:	68fb      	ldr	r3, [r7, #12]
10001272:	1c02      	adds	r2, r0, #0
10001274:	3210      	adds	r2, #16
10001276:	0092      	lsls	r2, r2, #2
10001278:	50d1      	str	r1, [r2, r3]

  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
1000127a:	68fb      	ldr	r3, [r7, #12]
1000127c:	4a20      	ldr	r2, [pc, #128]	; (10001300 <XMC_GPIO_Init+0x178>)
1000127e:	4293      	cmp	r3, r2
10001280:	d10b      	bne.n	1000129a <XMC_GPIO_Init+0x112>
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
10001282:	68fb      	ldr	r3, [r7, #12]
10001284:	6e1b      	ldr	r3, [r3, #96]	; 0x60
10001286:	220b      	movs	r2, #11
10001288:	18ba      	adds	r2, r7, r2
1000128a:	7812      	ldrb	r2, [r2, #0]
1000128c:	2101      	movs	r1, #1
1000128e:	4091      	lsls	r1, r2
10001290:	1c0a      	adds	r2, r1, #0
10001292:	43d2      	mvns	r2, r2
10001294:	401a      	ands	r2, r3
10001296:	68fb      	ldr	r3, [r7, #12]
10001298:	661a      	str	r2, [r3, #96]	; 0x60
  }

  if ((config->mode & XMC_GPIO_MODE_OE) != 0)
1000129a:	687b      	ldr	r3, [r7, #4]
1000129c:	781b      	ldrb	r3, [r3, #0]
1000129e:	b2db      	uxtb	r3, r3
100012a0:	b25b      	sxtb	r3, r3
100012a2:	2b00      	cmp	r3, #0
100012a4:	da07      	bge.n	100012b6 <XMC_GPIO_Init+0x12e>
  {
    /* If output is enabled */

    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
100012a6:	687b      	ldr	r3, [r7, #4]
100012a8:	685a      	ldr	r2, [r3, #4]
100012aa:	230b      	movs	r3, #11
100012ac:	18fb      	adds	r3, r7, r3
100012ae:	781b      	ldrb	r3, [r3, #0]
100012b0:	409a      	lsls	r2, r3
100012b2:	68fb      	ldr	r3, [r7, #12]
100012b4:	605a      	str	r2, [r3, #4]
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << (PORT_IOCR_PC_Size * (pin & 0x3U));
100012b6:	230b      	movs	r3, #11
100012b8:	18fb      	adds	r3, r7, r3
100012ba:	781b      	ldrb	r3, [r3, #0]
100012bc:	089b      	lsrs	r3, r3, #2
100012be:	b2db      	uxtb	r3, r3
100012c0:	1c18      	adds	r0, r3, #0
100012c2:	230b      	movs	r3, #11
100012c4:	18fb      	adds	r3, r7, r3
100012c6:	781b      	ldrb	r3, [r3, #0]
100012c8:	089b      	lsrs	r3, r3, #2
100012ca:	b2db      	uxtb	r3, r3
100012cc:	1c1a      	adds	r2, r3, #0
100012ce:	68fb      	ldr	r3, [r7, #12]
100012d0:	3204      	adds	r2, #4
100012d2:	0092      	lsls	r2, r2, #2
100012d4:	58d2      	ldr	r2, [r2, r3]
100012d6:	687b      	ldr	r3, [r7, #4]
100012d8:	781b      	ldrb	r3, [r3, #0]
100012da:	1c1c      	adds	r4, r3, #0
100012dc:	230b      	movs	r3, #11
100012de:	18fb      	adds	r3, r7, r3
100012e0:	781b      	ldrb	r3, [r3, #0]
100012e2:	2103      	movs	r1, #3
100012e4:	400b      	ands	r3, r1
100012e6:	00db      	lsls	r3, r3, #3
100012e8:	409c      	lsls	r4, r3
100012ea:	1c23      	adds	r3, r4, #0
100012ec:	431a      	orrs	r2, r3
100012ee:	1c11      	adds	r1, r2, #0
100012f0:	68fb      	ldr	r3, [r7, #12]
100012f2:	1d02      	adds	r2, r0, #4
100012f4:	0092      	lsls	r2, r2, #2
100012f6:	50d1      	str	r1, [r2, r3]
}
100012f8:	46bd      	mov	sp, r7
100012fa:	b005      	add	sp, #20
100012fc:	bd90      	pop	{r4, r7, pc}
100012fe:	46c0      	nop			; (mov r8, r8)
10001300:	40040200 	.word	0x40040200

10001304 <XMC_SCU_LockProtectedBits>:
#endif
}

/* API to lock protected bitfields from being modified */
void XMC_SCU_LockProtectedBits(void)
{
10001304:	b580      	push	{r7, lr}
10001306:	af00      	add	r7, sp, #0
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_ENABLE;
10001308:	4b02      	ldr	r3, [pc, #8]	; (10001314 <XMC_SCU_LockProtectedBits+0x10>)
1000130a:	22c3      	movs	r2, #195	; 0xc3
1000130c:	625a      	str	r2, [r3, #36]	; 0x24
}
1000130e:	46bd      	mov	sp, r7
10001310:	bd80      	pop	{r7, pc}
10001312:	46c0      	nop			; (mov r8, r8)
10001314:	40010000 	.word	0x40010000

10001318 <XMC_SCU_UnlockProtectedBits>:

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
10001318:	b580      	push	{r7, lr}
1000131a:	af00      	add	r7, sp, #0
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
1000131c:	4b05      	ldr	r3, [pc, #20]	; (10001334 <XMC_SCU_UnlockProtectedBits+0x1c>)
1000131e:	22c0      	movs	r2, #192	; 0xc0
10001320:	625a      	str	r2, [r3, #36]	; 0x24

  while (((SCU_GENERAL->PASSWD) & SCU_GENERAL_PASSWD_PROTS_Msk))
10001322:	46c0      	nop			; (mov r8, r8)
10001324:	4b03      	ldr	r3, [pc, #12]	; (10001334 <XMC_SCU_UnlockProtectedBits+0x1c>)
10001326:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10001328:	2204      	movs	r2, #4
1000132a:	4013      	ands	r3, r2
1000132c:	d1fa      	bne.n	10001324 <XMC_SCU_UnlockProtectedBits+0xc>
  {
    /* Loop until the lock is removed */
  }
}
1000132e:	46bd      	mov	sp, r7
10001330:	bd80      	pop	{r7, pc}
10001332:	46c0      	nop			; (mov r8, r8)
10001334:	40010000 	.word	0x40010000

10001338 <XMC_SCU_CLOCK_Init>:
}


/* API which initializes the clock tree ofthe device */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
10001338:	b580      	push	{r7, lr}
1000133a:	b086      	sub	sp, #24
1000133c:	af00      	add	r7, sp, #0
1000133e:	6078      	str	r0, [r7, #4]
  /* Remove protection */
  XMC_SCU_UnlockProtectedBits();
10001340:	f7ff ffea 	bl	10001318 <XMC_SCU_UnlockProtectedBits>

#if (UC_SERIES == XMC14)
  /* OSCHP source selection - OSC mode */

  if (config->oschp_mode != XMC_SCU_CLOCK_OSCHP_MODE_DISABLED)
10001344:	687b      	ldr	r3, [r7, #4]
10001346:	799b      	ldrb	r3, [r3, #6]
10001348:	2b30      	cmp	r3, #48	; 0x30
1000134a:	d053      	beq.n	100013f4 <XMC_SCU_CLOCK_Init+0xbc>
  {
    if (OSCHP_GetFrequency() > 20000000U)
1000134c:	f7ff ff14 	bl	10001178 <OSCHP_GetFrequency>
10001350:	1e02      	subs	r2, r0, #0
10001352:	4b49      	ldr	r3, [pc, #292]	; (10001478 <XMC_SCU_CLOCK_Init+0x140>)
10001354:	429a      	cmp	r2, r3
10001356:	d909      	bls.n	1000136c <XMC_SCU_CLOCK_Init+0x34>
    {
      SCU_ANALOG->ANAOSCHPCTRL |= (uint16_t)SCU_ANALOG_ANAOSCHPCTRL_HYSCTRL_Msk;
10001358:	4a48      	ldr	r2, [pc, #288]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
1000135a:	4948      	ldr	r1, [pc, #288]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
1000135c:	2390      	movs	r3, #144	; 0x90
1000135e:	5acb      	ldrh	r3, [r1, r3]
10001360:	b29b      	uxth	r3, r3
10001362:	2140      	movs	r1, #64	; 0x40
10001364:	430b      	orrs	r3, r1
10001366:	b299      	uxth	r1, r3
10001368:	2390      	movs	r3, #144	; 0x90
1000136a:	52d1      	strh	r1, [r2, r3]
    }

    SCU_ANALOG->ANAOSCHPCTRL = (uint16_t)(SCU_ANALOG->ANAOSCHPCTRL & ~(SCU_ANALOG_ANAOSCHPCTRL_SHBY_Msk | SCU_ANALOG_ANAOSCHPCTRL_MODE_Msk)) |
1000136c:	4a43      	ldr	r2, [pc, #268]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
1000136e:	4943      	ldr	r1, [pc, #268]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
10001370:	2390      	movs	r3, #144	; 0x90
10001372:	5acb      	ldrh	r3, [r1, r3]
10001374:	b29b      	uxth	r3, r3
10001376:	b29b      	uxth	r3, r3
10001378:	1c19      	adds	r1, r3, #0
1000137a:	2332      	movs	r3, #50	; 0x32
1000137c:	4399      	bics	r1, r3
1000137e:	1c0b      	adds	r3, r1, #0
10001380:	b299      	uxth	r1, r3
                               config->oschp_mode;
10001382:	687b      	ldr	r3, [r7, #4]
10001384:	799b      	ldrb	r3, [r3, #6]
    if (OSCHP_GetFrequency() > 20000000U)
    {
      SCU_ANALOG->ANAOSCHPCTRL |= (uint16_t)SCU_ANALOG_ANAOSCHPCTRL_HYSCTRL_Msk;
    }

    SCU_ANALOG->ANAOSCHPCTRL = (uint16_t)(SCU_ANALOG->ANAOSCHPCTRL & ~(SCU_ANALOG_ANAOSCHPCTRL_SHBY_Msk | SCU_ANALOG_ANAOSCHPCTRL_MODE_Msk)) |
10001386:	b29b      	uxth	r3, r3
10001388:	430b      	orrs	r3, r1
1000138a:	b29b      	uxth	r3, r3
1000138c:	b299      	uxth	r1, r3
1000138e:	2390      	movs	r3, #144	; 0x90
10001390:	52d1      	strh	r1, [r2, r3]
                               config->oschp_mode;

    do
    {
      /* clear the status bit before restarting the detection. */
      SCU_INTERRUPT->SRCLR1 = SCU_INTERRUPT_SRCLR1_LOECI_Msk;
10001392:	4b3b      	ldr	r3, [pc, #236]	; (10001480 <XMC_SCU_CLOCK_Init+0x148>)
10001394:	2202      	movs	r2, #2
10001396:	629a      	str	r2, [r3, #40]	; 0x28

      /* According to errata SCU_CM.023, to reset the XOWD it is needed to disable/enable the watchdog,
         keeping in between at least one DCO2 cycle */

      /* Disable XOWD */
      SCU_CLK->OSCCSR &= ~SCU_CLK_OSCCSR_XOWDEN_Msk;
10001398:	4b3a      	ldr	r3, [pc, #232]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
1000139a:	4a3a      	ldr	r2, [pc, #232]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
1000139c:	6952      	ldr	r2, [r2, #20]
1000139e:	493a      	ldr	r1, [pc, #232]	; (10001488 <XMC_SCU_CLOCK_Init+0x150>)
100013a0:	400a      	ands	r2, r1
100013a2:	615a      	str	r2, [r3, #20]
100013a4:	4b39      	ldr	r3, [pc, #228]	; (1000148c <XMC_SCU_CLOCK_Init+0x154>)
100013a6:	617b      	str	r3, [r7, #20]
100013a8:	e000      	b.n	100013ac <XMC_SCU_CLOCK_Init+0x74>
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
  {
    __NOP();
100013aa:	46c0      	nop			; (mov r8, r8)

#if UC_SERIES == XMC14
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
100013ac:	697b      	ldr	r3, [r7, #20]
100013ae:	3b01      	subs	r3, #1
100013b0:	617b      	str	r3, [r7, #20]
100013b2:	697b      	ldr	r3, [r7, #20]
100013b4:	2b00      	cmp	r3, #0
100013b6:	d1f8      	bne.n	100013aa <XMC_SCU_CLOCK_Init+0x72>
      /* Clock domains synchronization, at least 1 DCO2 cycle */
      /* delay value calculation assuming worst case DCO1=48Mhz and 3cycles per delay iteration */
      delay(538);

      /* Enable XOWD */
      SCU_CLK->OSCCSR |= SCU_CLK_OSCCSR_XOWDEN_Msk | SCU_CLK_OSCCSR_XOWDRES_Msk;
100013b8:	4b32      	ldr	r3, [pc, #200]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
100013ba:	4a32      	ldr	r2, [pc, #200]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
100013bc:	6952      	ldr	r2, [r2, #20]
100013be:	21c0      	movs	r1, #192	; 0xc0
100013c0:	0489      	lsls	r1, r1, #18
100013c2:	430a      	orrs	r2, r1
100013c4:	615a      	str	r2, [r3, #20]

      /* OSCCSR.XOWDRES bit will be automatically reset to 0 after XOWD is reset */
      while (SCU_CLK->OSCCSR & SCU_CLK_OSCCSR_XOWDRES_Msk);
100013c6:	46c0      	nop			; (mov r8, r8)
100013c8:	4b2e      	ldr	r3, [pc, #184]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
100013ca:	695a      	ldr	r2, [r3, #20]
100013cc:	2380      	movs	r3, #128	; 0x80
100013ce:	045b      	lsls	r3, r3, #17
100013d0:	4013      	ands	r3, r2
100013d2:	d1f9      	bne.n	100013c8 <XMC_SCU_CLOCK_Init+0x90>
100013d4:	4b2e      	ldr	r3, [pc, #184]	; (10001490 <XMC_SCU_CLOCK_Init+0x158>)
100013d6:	613b      	str	r3, [r7, #16]
100013d8:	e000      	b.n	100013dc <XMC_SCU_CLOCK_Init+0xa4>
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
  {
    __NOP();
100013da:	46c0      	nop			; (mov r8, r8)

#if UC_SERIES == XMC14
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
100013dc:	693b      	ldr	r3, [r7, #16]
100013de:	3b01      	subs	r3, #1
100013e0:	613b      	str	r3, [r7, #16]
100013e2:	693b      	ldr	r3, [r7, #16]
100013e4:	2b00      	cmp	r3, #0
100013e6:	d1f8      	bne.n	100013da <XMC_SCU_CLOCK_Init+0xa2>
      /* Wait a at least 5 DCO2 cycles for the update of the XTAL OWD result */
      /* delay value calculation assuming worst case DCO1=48Mhz and 3cycles per delay iteration */
      delay(2685);

    }
    while (SCU_INTERRUPT->SRRAW1 & SCU_INTERRUPT_SRRAW1_LOECI_Msk);
100013e8:	4b25      	ldr	r3, [pc, #148]	; (10001480 <XMC_SCU_CLOCK_Init+0x148>)
100013ea:	6a1b      	ldr	r3, [r3, #32]
100013ec:	2202      	movs	r2, #2
100013ee:	4013      	ands	r3, r2
100013f0:	d1cf      	bne.n	10001392 <XMC_SCU_CLOCK_Init+0x5a>
100013f2:	e009      	b.n	10001408 <XMC_SCU_CLOCK_Init+0xd0>
  }
  else /* (config->oschp_mode == XMC_SCU_CLOCK_OSCHP_MODE_DISABLED) */
  {
    SCU_ANALOG->ANAOSCHPCTRL |= SCU_ANALOG_ANAOSCHPCTRL_MODE_Msk;
100013f4:	4a21      	ldr	r2, [pc, #132]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
100013f6:	4921      	ldr	r1, [pc, #132]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
100013f8:	2390      	movs	r3, #144	; 0x90
100013fa:	5acb      	ldrh	r3, [r1, r3]
100013fc:	b29b      	uxth	r3, r3
100013fe:	2130      	movs	r1, #48	; 0x30
10001400:	430b      	orrs	r3, r1
10001402:	b299      	uxth	r1, r3
10001404:	2390      	movs	r3, #144	; 0x90
10001406:	52d1      	strh	r1, [r2, r3]
  }

  SCU_ANALOG->ANAOSCLPCTRL = (uint16_t)config->osclp_mode;
10001408:	4a1c      	ldr	r2, [pc, #112]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
1000140a:	687b      	ldr	r3, [r7, #4]
1000140c:	79db      	ldrb	r3, [r3, #7]
1000140e:	b299      	uxth	r1, r3
10001410:	238c      	movs	r3, #140	; 0x8c
10001412:	52d1      	strh	r1, [r2, r3]
#ifndef DISABLE_WAIT_RTC_XTAL_OSC_STARTUP
  if (config->osclp_mode == XMC_SCU_CLOCK_OSCLP_MODE_OSC)
10001414:	687b      	ldr	r3, [r7, #4]
10001416:	79db      	ldrb	r3, [r3, #7]
10001418:	2b00      	cmp	r3, #0
1000141a:	d109      	bne.n	10001430 <XMC_SCU_CLOCK_Init+0xf8>
1000141c:	4b1d      	ldr	r3, [pc, #116]	; (10001494 <XMC_SCU_CLOCK_Init+0x15c>)
1000141e:	60fb      	str	r3, [r7, #12]
10001420:	e000      	b.n	10001424 <XMC_SCU_CLOCK_Init+0xec>
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
  {
    __NOP();
10001422:	46c0      	nop			; (mov r8, r8)

#if UC_SERIES == XMC14
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
10001424:	68fb      	ldr	r3, [r7, #12]
10001426:	3b01      	subs	r3, #1
10001428:	60fb      	str	r3, [r7, #12]
1000142a:	68fb      	ldr	r3, [r7, #12]
1000142c:	2b00      	cmp	r3, #0
1000142e:	d1f8      	bne.n	10001422 <XMC_SCU_CLOCK_Init+0xea>
    /* Wait oscillator startup time ~5s */
    delay(6500000);
  }
#endif

  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
10001430:	4b14      	ldr	r3, [pc, #80]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
10001432:	4a14      	ldr	r2, [pc, #80]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
10001434:	69d2      	ldr	r2, [r2, #28]
10001436:	4918      	ldr	r1, [pc, #96]	; (10001498 <XMC_SCU_CLOCK_Init+0x160>)
10001438:	400a      	ands	r2, r1
                    config->dclk_src;
1000143a:	6879      	ldr	r1, [r7, #4]
1000143c:	8889      	ldrh	r1, [r1, #4]
    /* Wait oscillator startup time ~5s */
    delay(6500000);
  }
#endif

  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
1000143e:	430a      	orrs	r2, r1
10001440:	61da      	str	r2, [r3, #28]
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
10001442:	4a10      	ldr	r2, [pc, #64]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
10001444:	4b0f      	ldr	r3, [pc, #60]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
10001446:	681b      	ldr	r3, [r3, #0]
10001448:	4914      	ldr	r1, [pc, #80]	; (1000149c <XMC_SCU_CLOCK_Init+0x164>)
1000144a:	4019      	ands	r1, r3
                   config->rtc_src |
1000144c:	687b      	ldr	r3, [r7, #4]
1000144e:	68db      	ldr	r3, [r3, #12]
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
10001450:	4319      	orrs	r1, r3
                   config->rtc_src |
                   config->pclk_src;
10001452:	687b      	ldr	r3, [r7, #4]
10001454:	689b      	ldr	r3, [r3, #8]
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
                   config->rtc_src |
10001456:	430b      	orrs	r3, r1
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
10001458:	6013      	str	r3, [r2, #0]
                   config->rtc_src |
                   config->pclk_src;

  /* Close the lock opened above. */
  XMC_SCU_LockProtectedBits();
1000145a:	f7ff ff53 	bl	10001304 <XMC_SCU_LockProtectedBits>

  /* Update the dividers now */
  XMC_SCU_CLOCK_ScaleMCLKFrequency(config->idiv, config->fdiv);
1000145e:	687b      	ldr	r3, [r7, #4]
10001460:	789b      	ldrb	r3, [r3, #2]
10001462:	1c1a      	adds	r2, r3, #0
10001464:	687b      	ldr	r3, [r7, #4]
10001466:	881b      	ldrh	r3, [r3, #0]
10001468:	1c10      	adds	r0, r2, #0
1000146a:	1c19      	adds	r1, r3, #0
1000146c:	f000 f844 	bl	100014f8 <XMC_SCU_CLOCK_ScaleMCLKFrequency>

}
10001470:	46bd      	mov	sp, r7
10001472:	b006      	add	sp, #24
10001474:	bd80      	pop	{r7, pc}
10001476:	46c0      	nop			; (mov r8, r8)
10001478:	01312d00 	.word	0x01312d00
1000147c:	40011000 	.word	0x40011000
10001480:	40010038 	.word	0x40010038
10001484:	40010300 	.word	0x40010300
10001488:	fdffffff 	.word	0xfdffffff
1000148c:	0000021a 	.word	0x0000021a
10001490:	00000a7d 	.word	0x00000a7d
10001494:	00632ea0 	.word	0x00632ea0
10001498:	fffffdff 	.word	0xfffffdff
1000149c:	fff0ffff 	.word	0xfff0ffff

100014a0 <XMC_SCU_CLOCK_UngatePeripheralClock>:
  XMC_SCU_LockProtectedBits();
}

/* API which ungates a clock note at its source */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
100014a0:	b580      	push	{r7, lr}
100014a2:	b082      	sub	sp, #8
100014a4:	af00      	add	r7, sp, #0
100014a6:	6078      	str	r0, [r7, #4]
  XMC_SCU_UnlockProtectedBits();
100014a8:	f7ff ff36 	bl	10001318 <XMC_SCU_UnlockProtectedBits>
  SCU_CLK->CGATCLR0 |= (uint32_t)peripheral;
100014ac:	4b08      	ldr	r3, [pc, #32]	; (100014d0 <XMC_SCU_CLOCK_UngatePeripheralClock+0x30>)
100014ae:	4a08      	ldr	r2, [pc, #32]	; (100014d0 <XMC_SCU_CLOCK_UngatePeripheralClock+0x30>)
100014b0:	6911      	ldr	r1, [r2, #16]
100014b2:	687a      	ldr	r2, [r7, #4]
100014b4:	430a      	orrs	r2, r1
100014b6:	611a      	str	r2, [r3, #16]
  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
100014b8:	46c0      	nop			; (mov r8, r8)
100014ba:	4b05      	ldr	r3, [pc, #20]	; (100014d0 <XMC_SCU_CLOCK_UngatePeripheralClock+0x30>)
100014bc:	681a      	ldr	r2, [r3, #0]
100014be:	2380      	movs	r3, #128	; 0x80
100014c0:	05db      	lsls	r3, r3, #23
100014c2:	4013      	ands	r3, r2
100014c4:	d1f9      	bne.n	100014ba <XMC_SCU_CLOCK_UngatePeripheralClock+0x1a>
  {
    /* Wait voltage suply stabilization */
  }
  XMC_SCU_LockProtectedBits();
100014c6:	f7ff ff1d 	bl	10001304 <XMC_SCU_LockProtectedBits>
}
100014ca:	46bd      	mov	sp, r7
100014cc:	b002      	add	sp, #8
100014ce:	bd80      	pop	{r7, pc}
100014d0:	40010300 	.word	0x40010300

100014d4 <XMC_SCU_CLOCK_IsPeripheralClockGated>:

/* Checks the status of peripheral clock gating */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
100014d4:	b580      	push	{r7, lr}
100014d6:	b082      	sub	sp, #8
100014d8:	af00      	add	r7, sp, #0
100014da:	6078      	str	r0, [r7, #4]
  return (bool)((SCU_CLK->CGATSTAT0 & peripheral) != 0);
100014dc:	4b05      	ldr	r3, [pc, #20]	; (100014f4 <XMC_SCU_CLOCK_IsPeripheralClockGated+0x20>)
100014de:	689b      	ldr	r3, [r3, #8]
100014e0:	687a      	ldr	r2, [r7, #4]
100014e2:	4013      	ands	r3, r2
100014e4:	1e5a      	subs	r2, r3, #1
100014e6:	4193      	sbcs	r3, r2
100014e8:	b2db      	uxtb	r3, r3
}
100014ea:	1c18      	adds	r0, r3, #0
100014ec:	46bd      	mov	sp, r7
100014ee:	b002      	add	sp, #8
100014f0:	bd80      	pop	{r7, pc}
100014f2:	46c0      	nop			; (mov r8, r8)
100014f4:	40010300 	.word	0x40010300

100014f8 <XMC_SCU_CLOCK_ScaleMCLKFrequency>:
}


/* A utility routine which updates the fractional dividers in steps */
void XMC_SCU_CLOCK_ScaleMCLKFrequency(uint32_t idiv, uint32_t fdiv)
{
100014f8:	b580      	push	{r7, lr}
100014fa:	b084      	sub	sp, #16
100014fc:	af00      	add	r7, sp, #0
100014fe:	6078      	str	r0, [r7, #4]
10001500:	6039      	str	r1, [r7, #0]
  /* Find out current and target value of idiv */
  uint32_t curr_idiv;

  XMC_SCU_UnlockProtectedBits();
10001502:	f7ff ff09 	bl	10001318 <XMC_SCU_UnlockProtectedBits>

  /* Take a snapshot of value already programmed into IDIV */
  curr_idiv = (SCU_CLK->CLKCR & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
10001506:	4b27      	ldr	r3, [pc, #156]	; (100015a4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
10001508:	681a      	ldr	r2, [r3, #0]
1000150a:	23ff      	movs	r3, #255	; 0xff
1000150c:	021b      	lsls	r3, r3, #8
1000150e:	4013      	ands	r3, r2
10001510:	0a1b      	lsrs	r3, r3, #8
10001512:	60fb      	str	r3, [r7, #12]

#if (UC_SERIES == XMC14)
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & (uint32_t)~(SCU_CLK_CLKCR1_FDIV_Msk)) |
10001514:	4b23      	ldr	r3, [pc, #140]	; (100015a4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
10001516:	4a23      	ldr	r2, [pc, #140]	; (100015a4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
10001518:	69d2      	ldr	r2, [r2, #28]
1000151a:	2103      	movs	r1, #3
1000151c:	438a      	bics	r2, r1
1000151e:	1c11      	adds	r1, r2, #0
                    (uint32_t)((fdiv >> 8U) << SCU_CLK_CLKCR1_FDIV_Pos);
10001520:	683a      	ldr	r2, [r7, #0]
10001522:	0a12      	lsrs	r2, r2, #8

  /* Take a snapshot of value already programmed into IDIV */
  curr_idiv = (SCU_CLK->CLKCR & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;

#if (UC_SERIES == XMC14)
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & (uint32_t)~(SCU_CLK_CLKCR1_FDIV_Msk)) |
10001524:	430a      	orrs	r2, r1
10001526:	61da      	str	r2, [r3, #28]
                    (uint32_t)((fdiv >> 8U) << SCU_CLK_CLKCR1_FDIV_Pos);

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001528:	4b1e      	ldr	r3, [pc, #120]	; (100015a4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
1000152a:	4a1e      	ldr	r2, [pc, #120]	; (100015a4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
1000152c:	6812      	ldr	r2, [r2, #0]
1000152e:	491e      	ldr	r1, [pc, #120]	; (100015a8 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xb0>)
10001530:	4011      	ands	r1, r2
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
10001532:	683a      	ldr	r2, [r7, #0]
10001534:	20ff      	movs	r0, #255	; 0xff
10001536:	4002      	ands	r2, r0

#if (UC_SERIES == XMC14)
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & (uint32_t)~(SCU_CLK_CLKCR1_FDIV_Msk)) |
                    (uint32_t)((fdiv >> 8U) << SCU_CLK_CLKCR1_FDIV_Pos);

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001538:	430a      	orrs	r2, r1
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
1000153a:	491c      	ldr	r1, [pc, #112]	; (100015ac <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xb4>)
1000153c:	430a      	orrs	r2, r1

#if (UC_SERIES == XMC14)
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & (uint32_t)~(SCU_CLK_CLKCR1_FDIV_Msk)) |
                    (uint32_t)((fdiv >> 8U) << SCU_CLK_CLKCR1_FDIV_Pos);

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000153e:	601a      	str	r2, [r3, #0]
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#endif

  while ((SCU_CLK->CLKCR)& SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001540:	46c0      	nop			; (mov r8, r8)
10001542:	4b18      	ldr	r3, [pc, #96]	; (100015a4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
10001544:	681a      	ldr	r2, [r3, #0]
10001546:	2380      	movs	r3, #128	; 0x80
10001548:	05db      	lsls	r3, r3, #23
1000154a:	4013      	ands	r3, r2
1000154c:	d1f9      	bne.n	10001542 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x4a>
  {
    /* Spin until the core supply stabilizes */
  }

  if (curr_idiv <= idiv)
1000154e:	68fa      	ldr	r2, [r7, #12]
10001550:	687b      	ldr	r3, [r7, #4]
10001552:	429a      	cmp	r2, r3
10001554:	d806      	bhi.n	10001564 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x6c>
  {
    /* Requested IDIV is greater than currently programmed IDIV. So downscale the frequency */
    XMC_SCU_CLOCK_lFrequencyDownScaling(curr_idiv, idiv);
10001556:	68fa      	ldr	r2, [r7, #12]
10001558:	687b      	ldr	r3, [r7, #4]
1000155a:	1c10      	adds	r0, r2, #0
1000155c:	1c19      	adds	r1, r3, #0
1000155e:	f000 f853 	bl	10001608 <XMC_SCU_CLOCK_lFrequencyDownScaling>
10001562:	e005      	b.n	10001570 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x78>
  }
  else
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
10001564:	68fa      	ldr	r2, [r7, #12]
10001566:	687b      	ldr	r3, [r7, #4]
10001568:	1c10      	adds	r0, r2, #0
1000156a:	1c19      	adds	r1, r3, #0
1000156c:	f000 f822 	bl	100015b4 <XMC_SCU_CLOCK_lFrequencyUpScaling>
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001570:	4b0c      	ldr	r3, [pc, #48]	; (100015a4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
10001572:	4a0c      	ldr	r2, [pc, #48]	; (100015a4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
10001574:	6812      	ldr	r2, [r2, #0]
10001576:	490e      	ldr	r1, [pc, #56]	; (100015b0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xb8>)
10001578:	4011      	ands	r1, r2
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
1000157a:	687a      	ldr	r2, [r7, #4]
1000157c:	0212      	lsls	r2, r2, #8
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000157e:	430a      	orrs	r2, r1
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
10001580:	490a      	ldr	r1, [pc, #40]	; (100015ac <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xb4>)
10001582:	430a      	orrs	r2, r1
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001584:	601a      	str	r2, [r3, #0]
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001586:	46c0      	nop			; (mov r8, r8)
10001588:	4b06      	ldr	r3, [pc, #24]	; (100015a4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
1000158a:	681a      	ldr	r2, [r3, #0]
1000158c:	2380      	movs	r3, #128	; 0x80
1000158e:	05db      	lsls	r3, r3, #23
10001590:	4013      	ands	r3, r2
10001592:	d1f9      	bne.n	10001588 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x90>
  {
    /* Wait voltage suply stabilization */
  }

  XMC_SCU_LockProtectedBits();
10001594:	f7ff feb6 	bl	10001304 <XMC_SCU_LockProtectedBits>

  SystemCoreClockUpdate();
10001598:	f7ff fd8a 	bl	100010b0 <SystemCoreClockUpdate>

}
1000159c:	46bd      	mov	sp, r7
1000159e:	b004      	add	sp, #16
100015a0:	bd80      	pop	{r7, pc}
100015a2:	46c0      	nop			; (mov r8, r8)
100015a4:	40010300 	.word	0x40010300
100015a8:	c00fff00 	.word	0xc00fff00
100015ac:	3ff00000 	.word	0x3ff00000
100015b0:	c00f00ff 	.word	0xc00f00ff

100015b4 <XMC_SCU_CLOCK_lFrequencyUpScaling>:

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
100015b4:	b580      	push	{r7, lr}
100015b6:	b082      	sub	sp, #8
100015b8:	af00      	add	r7, sp, #0
100015ba:	6078      	str	r0, [r7, #4]
100015bc:	6039      	str	r1, [r7, #0]
  while (curr_idiv > (target_idiv * 4UL))
100015be:	e014      	b.n	100015ea <XMC_SCU_CLOCK_lFrequencyUpScaling+0x36>
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */
100015c0:	687b      	ldr	r3, [r7, #4]
100015c2:	089b      	lsrs	r3, r3, #2
100015c4:	607b      	str	r3, [r7, #4]

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100015c6:	4b0d      	ldr	r3, [pc, #52]	; (100015fc <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
100015c8:	4a0c      	ldr	r2, [pc, #48]	; (100015fc <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
100015ca:	6812      	ldr	r2, [r2, #0]
100015cc:	490c      	ldr	r1, [pc, #48]	; (10001600 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x4c>)
100015ce:	4011      	ands	r1, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
100015d0:	687a      	ldr	r2, [r7, #4]
100015d2:	0212      	lsls	r2, r2, #8
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100015d4:	430a      	orrs	r2, r1
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
100015d6:	490b      	ldr	r1, [pc, #44]	; (10001604 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x50>)
100015d8:	430a      	orrs	r2, r1
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100015da:	601a      	str	r2, [r3, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
100015dc:	46c0      	nop			; (mov r8, r8)
100015de:	4b07      	ldr	r3, [pc, #28]	; (100015fc <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
100015e0:	681a      	ldr	r2, [r3, #0]
100015e2:	2380      	movs	r3, #128	; 0x80
100015e4:	05db      	lsls	r3, r3, #23
100015e6:	4013      	ands	r3, r2
100015e8:	d1f9      	bne.n	100015de <XMC_SCU_CLOCK_lFrequencyUpScaling+0x2a>
}

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
  while (curr_idiv > (target_idiv * 4UL))
100015ea:	683b      	ldr	r3, [r7, #0]
100015ec:	009a      	lsls	r2, r3, #2
100015ee:	687b      	ldr	r3, [r7, #4]
100015f0:	429a      	cmp	r2, r3
100015f2:	d3e5      	bcc.n	100015c0 <XMC_SCU_CLOCK_lFrequencyUpScaling+0xc>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
      /* Wait voltage suply stabilization */
    }
  }
}
100015f4:	46bd      	mov	sp, r7
100015f6:	b002      	add	sp, #8
100015f8:	bd80      	pop	{r7, pc}
100015fa:	46c0      	nop			; (mov r8, r8)
100015fc:	40010300 	.word	0x40010300
10001600:	c00f00ff 	.word	0xc00f00ff
10001604:	3ff00000 	.word	0x3ff00000

10001608 <XMC_SCU_CLOCK_lFrequencyDownScaling>:

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
10001608:	b580      	push	{r7, lr}
1000160a:	b082      	sub	sp, #8
1000160c:	af00      	add	r7, sp, #0
1000160e:	6078      	str	r0, [r7, #4]
10001610:	6039      	str	r1, [r7, #0]

  while ((curr_idiv * 4UL) < target_idiv)
10001612:	e019      	b.n	10001648 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x40>
  {
    if (0U == curr_idiv)
10001614:	687b      	ldr	r3, [r7, #4]
10001616:	2b00      	cmp	r3, #0
10001618:	d101      	bne.n	1000161e <XMC_SCU_CLOCK_lFrequencyDownScaling+0x16>
    {
      curr_idiv = 1U;
1000161a:	2301      	movs	r3, #1
1000161c:	607b      	str	r3, [r7, #4]
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
1000161e:	687b      	ldr	r3, [r7, #4]
10001620:	009b      	lsls	r3, r3, #2
10001622:	607b      	str	r3, [r7, #4]
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001624:	4b0c      	ldr	r3, [pc, #48]	; (10001658 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
10001626:	4a0c      	ldr	r2, [pc, #48]	; (10001658 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
10001628:	6812      	ldr	r2, [r2, #0]
1000162a:	490c      	ldr	r1, [pc, #48]	; (1000165c <XMC_SCU_CLOCK_lFrequencyDownScaling+0x54>)
1000162c:	4011      	ands	r1, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
1000162e:	687a      	ldr	r2, [r7, #4]
10001630:	0212      	lsls	r2, r2, #8
    if (0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001632:	430a      	orrs	r2, r1
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
10001634:	490a      	ldr	r1, [pc, #40]	; (10001660 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x58>)
10001636:	430a      	orrs	r2, r1
    if (0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001638:	601a      	str	r2, [r3, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
1000163a:	46c0      	nop			; (mov r8, r8)
1000163c:	4b06      	ldr	r3, [pc, #24]	; (10001658 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
1000163e:	681a      	ldr	r2, [r3, #0]
10001640:	2380      	movs	r3, #128	; 0x80
10001642:	05db      	lsls	r3, r3, #23
10001644:	4013      	ands	r3, r2
10001646:	d1f9      	bne.n	1000163c <XMC_SCU_CLOCK_lFrequencyDownScaling+0x34>

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{

  while ((curr_idiv * 4UL) < target_idiv)
10001648:	687b      	ldr	r3, [r7, #4]
1000164a:	009a      	lsls	r2, r3, #2
1000164c:	683b      	ldr	r3, [r7, #0]
1000164e:	429a      	cmp	r2, r3
10001650:	d3e0      	bcc.n	10001614 <XMC_SCU_CLOCK_lFrequencyDownScaling+0xc>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
      /* Wait voltage suply stabilization */
    }
  }
}
10001652:	46bd      	mov	sp, r7
10001654:	b002      	add	sp, #8
10001656:	bd80      	pop	{r7, pc}
10001658:	40010300 	.word	0x40010300
1000165c:	c00f00ff 	.word	0xc00f00ff
10001660:	3ff00000 	.word	0x3ff00000

10001664 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:

/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
10001664:	b580      	push	{r7, lr}
10001666:	af00      	add	r7, sp, #0
  return (SystemCoreClock);
10001668:	4b02      	ldr	r3, [pc, #8]	; (10001674 <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x10>)
1000166a:	681b      	ldr	r3, [r3, #0]
}
1000166c:	1c18      	adds	r0, r3, #0
1000166e:	46bd      	mov	sp, r7
10001670:	bd80      	pop	{r7, pc}
10001672:	46c0      	nop			; (mov r8, r8)
10001674:	20003ffc 	.word	0x20003ffc

10001678 <XMC_SCU_SetInterruptControl>:
  return (bool)((SCU_ANALOG->ANASYNC2 & SCU_ANALOG_ANASYNC2_SYNC_READY_Msk) != 0U);
}

/* This function selects service request source for a NVIC interrupt node */
void XMC_SCU_SetInterruptControl(uint8_t irq_number, XMC_SCU_IRQCTRL_t source)
{
10001678:	b580      	push	{r7, lr}
1000167a:	b082      	sub	sp, #8
1000167c:	af00      	add	r7, sp, #0
1000167e:	1c02      	adds	r2, r0, #0
10001680:	1dfb      	adds	r3, r7, #7
10001682:	701a      	strb	r2, [r3, #0]
10001684:	1d3b      	adds	r3, r7, #4
10001686:	1c0a      	adds	r2, r1, #0
10001688:	801a      	strh	r2, [r3, #0]
  XMC_ASSERT("XMC_SCU_SetInterruptControl: Invalid irq_number", irq_number < 32);
  XMC_ASSERT("XMC_SCU_SetInterruptControl: Invalid source", (source >> 8) == irq_number);

  source &= 0x3U;
1000168a:	1d3b      	adds	r3, r7, #4
1000168c:	1d3a      	adds	r2, r7, #4
1000168e:	8812      	ldrh	r2, [r2, #0]
10001690:	2103      	movs	r1, #3
10001692:	400a      	ands	r2, r1
10001694:	801a      	strh	r2, [r3, #0]
  if (irq_number < 16U)
10001696:	1dfb      	adds	r3, r7, #7
10001698:	781b      	ldrb	r3, [r3, #0]
1000169a:	2b0f      	cmp	r3, #15
1000169c:	d813      	bhi.n	100016c6 <XMC_SCU_SetInterruptControl+0x4e>
  {
    SCU_GENERAL->INTCR0 = (SCU_GENERAL->INTCR0 & ~(SCU_GENERAL_INTCR_INTSEL_Msk << (irq_number * SCU_GENERAL_INTCR_INTSEL_Size))) |
1000169e:	4b18      	ldr	r3, [pc, #96]	; (10001700 <XMC_SCU_SetInterruptControl+0x88>)
100016a0:	4a17      	ldr	r2, [pc, #92]	; (10001700 <XMC_SCU_SetInterruptControl+0x88>)
100016a2:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
100016a4:	1df9      	adds	r1, r7, #7
100016a6:	7809      	ldrb	r1, [r1, #0]
100016a8:	0049      	lsls	r1, r1, #1
100016aa:	1c08      	adds	r0, r1, #0
100016ac:	2103      	movs	r1, #3
100016ae:	4081      	lsls	r1, r0
100016b0:	43c9      	mvns	r1, r1
100016b2:	400a      	ands	r2, r1
                          (source << (irq_number * SCU_GENERAL_INTCR_INTSEL_Size));
100016b4:	1d39      	adds	r1, r7, #4
100016b6:	8809      	ldrh	r1, [r1, #0]
100016b8:	1df8      	adds	r0, r7, #7
100016ba:	7800      	ldrb	r0, [r0, #0]
100016bc:	0040      	lsls	r0, r0, #1
100016be:	4081      	lsls	r1, r0
  XMC_ASSERT("XMC_SCU_SetInterruptControl: Invalid source", (source >> 8) == irq_number);

  source &= 0x3U;
  if (irq_number < 16U)
  {
    SCU_GENERAL->INTCR0 = (SCU_GENERAL->INTCR0 & ~(SCU_GENERAL_INTCR_INTSEL_Msk << (irq_number * SCU_GENERAL_INTCR_INTSEL_Size))) |
100016c0:	430a      	orrs	r2, r1
100016c2:	66da      	str	r2, [r3, #108]	; 0x6c
100016c4:	e018      	b.n	100016f8 <XMC_SCU_SetInterruptControl+0x80>
                          (source << (irq_number * SCU_GENERAL_INTCR_INTSEL_Size));
  }
  else
  {
    irq_number &= 0x0fU;
100016c6:	1dfb      	adds	r3, r7, #7
100016c8:	1dfa      	adds	r2, r7, #7
100016ca:	7812      	ldrb	r2, [r2, #0]
100016cc:	210f      	movs	r1, #15
100016ce:	400a      	ands	r2, r1
100016d0:	701a      	strb	r2, [r3, #0]
    SCU_GENERAL->INTCR1 = (SCU_GENERAL->INTCR1 & ~(SCU_GENERAL_INTCR_INTSEL_Msk << (irq_number  * SCU_GENERAL_INTCR_INTSEL_Size))) |
100016d2:	4b0b      	ldr	r3, [pc, #44]	; (10001700 <XMC_SCU_SetInterruptControl+0x88>)
100016d4:	4a0a      	ldr	r2, [pc, #40]	; (10001700 <XMC_SCU_SetInterruptControl+0x88>)
100016d6:	6f12      	ldr	r2, [r2, #112]	; 0x70
100016d8:	1df9      	adds	r1, r7, #7
100016da:	7809      	ldrb	r1, [r1, #0]
100016dc:	0049      	lsls	r1, r1, #1
100016de:	1c08      	adds	r0, r1, #0
100016e0:	2103      	movs	r1, #3
100016e2:	4081      	lsls	r1, r0
100016e4:	43c9      	mvns	r1, r1
100016e6:	400a      	ands	r2, r1
                          (source << (irq_number  * SCU_GENERAL_INTCR_INTSEL_Size));
100016e8:	1d39      	adds	r1, r7, #4
100016ea:	8809      	ldrh	r1, [r1, #0]
100016ec:	1df8      	adds	r0, r7, #7
100016ee:	7800      	ldrb	r0, [r0, #0]
100016f0:	0040      	lsls	r0, r0, #1
100016f2:	4081      	lsls	r1, r0
                          (source << (irq_number * SCU_GENERAL_INTCR_INTSEL_Size));
  }
  else
  {
    irq_number &= 0x0fU;
    SCU_GENERAL->INTCR1 = (SCU_GENERAL->INTCR1 & ~(SCU_GENERAL_INTCR_INTSEL_Msk << (irq_number  * SCU_GENERAL_INTCR_INTSEL_Size))) |
100016f4:	430a      	orrs	r2, r1
100016f6:	671a      	str	r2, [r3, #112]	; 0x70
                          (source << (irq_number  * SCU_GENERAL_INTCR_INTSEL_Size));
  }
}
100016f8:	46bd      	mov	sp, r7
100016fa:	b002      	add	sp, #8
100016fc:	bd80      	pop	{r7, pc}
100016fe:	46c0      	nop			; (mov r8, r8)
10001700:	40010000 	.word	0x40010000

10001704 <XMC_CAN_IsPanelControlReady>:
 * \par<b>Related APIs:</b><BR>
 *  XMC_CAN_PanelControl()
 *
 */
__STATIC_INLINE bool XMC_CAN_IsPanelControlReady(XMC_CAN_t *const obj)
{
10001704:	b580      	push	{r7, lr}
10001706:	b082      	sub	sp, #8
10001708:	af00      	add	r7, sp, #0
1000170a:	6078      	str	r0, [r7, #4]
  return (bool)((obj->PANCTR & (CAN_PANCTR_BUSY_Msk | CAN_PANCTR_RBUSY_Msk)) == 0);
1000170c:	687a      	ldr	r2, [r7, #4]
1000170e:	23e2      	movs	r3, #226	; 0xe2
10001710:	005b      	lsls	r3, r3, #1
10001712:	58d2      	ldr	r2, [r2, r3]
10001714:	23c0      	movs	r3, #192	; 0xc0
10001716:	009b      	lsls	r3, r3, #2
10001718:	4013      	ands	r3, r2
1000171a:	425a      	negs	r2, r3
1000171c:	4153      	adcs	r3, r2
1000171e:	b2db      	uxtb	r3, r3
}
10001720:	1c18      	adds	r0, r3, #0
10001722:	46bd      	mov	sp, r7
10001724:	b002      	add	sp, #8
10001726:	bd80      	pop	{r7, pc}

10001728 <XMC_CAN_PanelControl>:

__STATIC_INLINE void XMC_CAN_PanelControl(XMC_CAN_t *const obj,
    const XMC_CAN_PANCMD_t pancmd,
    const uint8_t arg1,
    const uint8_t arg2)
{
10001728:	b590      	push	{r4, r7, lr}
1000172a:	b083      	sub	sp, #12
1000172c:	af00      	add	r7, sp, #0
1000172e:	6078      	str	r0, [r7, #4]
10001730:	1c0c      	adds	r4, r1, #0
10001732:	1c10      	adds	r0, r2, #0
10001734:	1c19      	adds	r1, r3, #0
10001736:	1cfb      	adds	r3, r7, #3
10001738:	1c22      	adds	r2, r4, #0
1000173a:	701a      	strb	r2, [r3, #0]
1000173c:	1cbb      	adds	r3, r7, #2
1000173e:	1c02      	adds	r2, r0, #0
10001740:	701a      	strb	r2, [r3, #0]
10001742:	1c7b      	adds	r3, r7, #1
10001744:	1c0a      	adds	r2, r1, #0
10001746:	701a      	strb	r2, [r3, #0]
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
10001748:	1cfb      	adds	r3, r7, #3
1000174a:	781a      	ldrb	r2, [r3, #0]
                (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
1000174c:	1cbb      	adds	r3, r7, #2
1000174e:	781b      	ldrb	r3, [r3, #0]
10001750:	0419      	lsls	r1, r3, #16
10001752:	23ff      	movs	r3, #255	; 0xff
10001754:	041b      	lsls	r3, r3, #16
10001756:	400b      	ands	r3, r1
__STATIC_INLINE void XMC_CAN_PanelControl(XMC_CAN_t *const obj,
    const XMC_CAN_PANCMD_t pancmd,
    const uint8_t arg1,
    const uint8_t arg2)
{
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
10001758:	431a      	orrs	r2, r3
                (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
                (((uint32_t)arg2 << CAN_PANCTR_PANAR2_Pos) & (uint32_t)CAN_PANCTR_PANAR2_Msk);
1000175a:	1c7b      	adds	r3, r7, #1
1000175c:	781b      	ldrb	r3, [r3, #0]
1000175e:	061b      	lsls	r3, r3, #24
    const XMC_CAN_PANCMD_t pancmd,
    const uint8_t arg1,
    const uint8_t arg2)
{
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
                (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
10001760:	431a      	orrs	r2, r3
10001762:	1c11      	adds	r1, r2, #0
__STATIC_INLINE void XMC_CAN_PanelControl(XMC_CAN_t *const obj,
    const XMC_CAN_PANCMD_t pancmd,
    const uint8_t arg1,
    const uint8_t arg2)
{
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
10001764:	687a      	ldr	r2, [r7, #4]
10001766:	23e2      	movs	r3, #226	; 0xe2
10001768:	005b      	lsls	r3, r3, #1
1000176a:	50d1      	str	r1, [r2, r3]
                (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
                (((uint32_t)arg2 << CAN_PANCTR_PANAR2_Pos) & (uint32_t)CAN_PANCTR_PANAR2_Msk);
}
1000176c:	46bd      	mov	sp, r7
1000176e:	b003      	add	sp, #12
10001770:	bd90      	pop	{r4, r7, pc}
10001772:	46c0      	nop			; (mov r8, r8)

10001774 <XMC_CAN_NODE_EnableConfigurationChange>:
 * XMC_CAN_NODE_DisableConfigurationChange()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_EnableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
10001774:	b580      	push	{r7, lr}
10001776:	b082      	sub	sp, #8
10001778:	af00      	add	r7, sp, #0
1000177a:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_CCE_Msk;
1000177c:	687b      	ldr	r3, [r7, #4]
1000177e:	681b      	ldr	r3, [r3, #0]
10001780:	2240      	movs	r2, #64	; 0x40
10001782:	431a      	orrs	r2, r3
10001784:	687b      	ldr	r3, [r7, #4]
10001786:	601a      	str	r2, [r3, #0]
}
10001788:	46bd      	mov	sp, r7
1000178a:	b002      	add	sp, #8
1000178c:	bd80      	pop	{r7, pc}
1000178e:	46c0      	nop			; (mov r8, r8)

10001790 <XMC_CAN_NODE_DisableConfigurationChange>:
 * XMC_CAN_NODE_EnableConfigurationChange()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_DisableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
10001790:	b580      	push	{r7, lr}
10001792:	b082      	sub	sp, #8
10001794:	af00      	add	r7, sp, #0
10001796:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CCE_Msk;
10001798:	687b      	ldr	r3, [r7, #4]
1000179a:	681b      	ldr	r3, [r3, #0]
1000179c:	2240      	movs	r2, #64	; 0x40
1000179e:	4393      	bics	r3, r2
100017a0:	1c1a      	adds	r2, r3, #0
100017a2:	687b      	ldr	r3, [r7, #4]
100017a4:	601a      	str	r2, [r3, #0]
}
100017a6:	46bd      	mov	sp, r7
100017a8:	b002      	add	sp, #8
100017aa:	bd80      	pop	{r7, pc}

100017ac <max>:

#if defined(CAN)
#include "xmc_scu.h"

__STATIC_INLINE uint32_t max(uint32_t a, uint32_t b)
{
100017ac:	b580      	push	{r7, lr}
100017ae:	b082      	sub	sp, #8
100017b0:	af00      	add	r7, sp, #0
100017b2:	6078      	str	r0, [r7, #4]
100017b4:	6039      	str	r1, [r7, #0]
  return (a > b) ? a : b;
100017b6:	687a      	ldr	r2, [r7, #4]
100017b8:	683b      	ldr	r3, [r7, #0]
100017ba:	4293      	cmp	r3, r2
100017bc:	d200      	bcs.n	100017c0 <max+0x14>
100017be:	1c13      	adds	r3, r2, #0
}
100017c0:	1c18      	adds	r0, r3, #0
100017c2:	46bd      	mov	sp, r7
100017c4:	b002      	add	sp, #8
100017c6:	bd80      	pop	{r7, pc}

100017c8 <min>:

__STATIC_INLINE uint32_t min(uint32_t a, uint32_t b)
{
100017c8:	b580      	push	{r7, lr}
100017ca:	b082      	sub	sp, #8
100017cc:	af00      	add	r7, sp, #0
100017ce:	6078      	str	r0, [r7, #4]
100017d0:	6039      	str	r1, [r7, #0]
  return (a < b) ? a : b;
100017d2:	687a      	ldr	r2, [r7, #4]
100017d4:	683b      	ldr	r3, [r7, #0]
100017d6:	4293      	cmp	r3, r2
100017d8:	d900      	bls.n	100017dc <min+0x14>
100017da:	1c13      	adds	r3, r2, #0
}
100017dc:	1c18      	adds	r0, r3, #0
100017de:	46bd      	mov	sp, r7
100017e0:	b002      	add	sp, #8
100017e2:	bd80      	pop	{r7, pc}

100017e4 <XMC_CAN_NODE_NominalBitTimeConfigureEx>:
#define XMC_CAN_NODE_MAX_TSEG2 7


int32_t XMC_CAN_NODE_NominalBitTimeConfigureEx(XMC_CAN_NODE_t *const can_node,
    const XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t *const bit_time_config)
{
100017e4:	b580      	push	{r7, lr}
100017e6:	b088      	sub	sp, #32
100017e8:	af00      	add	r7, sp, #0
100017ea:	6078      	str	r0, [r7, #4]
100017ec:	6039      	str	r1, [r7, #0]
  /* Check that the CAN frequency is a multiple of the required baudrate */
  if ((bit_time_config->can_frequency % bit_time_config->baudrate) == 0)
100017ee:	683b      	ldr	r3, [r7, #0]
100017f0:	681a      	ldr	r2, [r3, #0]
100017f2:	683b      	ldr	r3, [r7, #0]
100017f4:	685b      	ldr	r3, [r3, #4]
100017f6:	1c10      	adds	r0, r2, #0
100017f8:	1c19      	adds	r1, r3, #0
100017fa:	f000 fb29 	bl	10001e50 <__aeabi_uidivmod>
100017fe:	1e0b      	subs	r3, r1, #0
10001800:	d000      	beq.n	10001804 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x20>
10001802:	e096      	b.n	10001932 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x14e>
  {
    uint32_t prescaler = 0;
10001804:	2300      	movs	r3, #0
10001806:	61fb      	str	r3, [r7, #28]
    uint32_t div8 = 0;
10001808:	2300      	movs	r3, #0
1000180a:	61bb      	str	r3, [r7, #24]

    /* Calculate the factor between can frequency and required baudrate, this is equal to (prescaler x ntq) */
    uint32_t fcan_div = bit_time_config->can_frequency / bit_time_config->baudrate;
1000180c:	683b      	ldr	r3, [r7, #0]
1000180e:	681a      	ldr	r2, [r3, #0]
10001810:	683b      	ldr	r3, [r7, #0]
10001812:	685b      	ldr	r3, [r3, #4]
10001814:	1c10      	adds	r0, r2, #0
10001816:	1c19      	adds	r1, r3, #0
10001818:	f000 faca 	bl	10001db0 <__aeabi_uidiv>
1000181c:	1c03      	adds	r3, r0, #0
1000181e:	60bb      	str	r3, [r7, #8]

    /* start with highest ntq, i.e as much as possible time quanta should be used to construct a bit time */
    uint32_t ntq = XMC_CAN_NODE_MAX_NTQ;
10001820:	2319      	movs	r3, #25
10001822:	617b      	str	r3, [r7, #20]
    uint32_t tseg1 = 0;
10001824:	2300      	movs	r3, #0
10001826:	613b      	str	r3, [r7, #16]
    uint32_t tseg2 = 0;
10001828:	2300      	movs	r3, #0
1000182a:	60fb      	str	r3, [r7, #12]
    while (ntq >= XMC_CAN_NODE_MIN_NTQ)
1000182c:	e049      	b.n	100018c2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xde>
    {
      /* consider this ntq, only if fcan_div is multiple of ntq */
      if ((fcan_div % ntq) == 0)
1000182e:	68bb      	ldr	r3, [r7, #8]
10001830:	1c18      	adds	r0, r3, #0
10001832:	6979      	ldr	r1, [r7, #20]
10001834:	f000 fb0c 	bl	10001e50 <__aeabi_uidivmod>
10001838:	1e0b      	subs	r3, r1, #0
1000183a:	d13f      	bne.n	100018bc <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd8>
      {
        div8 = 0;
1000183c:	2300      	movs	r3, #0
1000183e:	61bb      	str	r3, [r7, #24]
        prescaler = fcan_div / ntq;
10001840:	68b8      	ldr	r0, [r7, #8]
10001842:	6979      	ldr	r1, [r7, #20]
10001844:	f000 fab4 	bl	10001db0 <__aeabi_uidiv>
10001848:	1c03      	adds	r3, r0, #0
1000184a:	61fb      	str	r3, [r7, #28]
        if ((prescaler > 0) && (prescaler <= XMC_CAN_NODE_MAX_PRESCALER))
1000184c:	69fb      	ldr	r3, [r7, #28]
1000184e:	2b00      	cmp	r3, #0
10001850:	d034      	beq.n	100018bc <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd8>
10001852:	69fa      	ldr	r2, [r7, #28]
10001854:	2380      	movs	r3, #128	; 0x80
10001856:	009b      	lsls	r3, r3, #2
10001858:	429a      	cmp	r2, r3
1000185a:	d82f      	bhi.n	100018bc <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd8>
        {
          if (prescaler >= 64)
1000185c:	69fb      	ldr	r3, [r7, #28]
1000185e:	2b3f      	cmp	r3, #63	; 0x3f
10001860:	d909      	bls.n	10001876 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x92>
          {
            /* consider prescaler >=64, if it is integer divisible by 8*/
            if ((prescaler & 0x7U) != 0)
10001862:	69fb      	ldr	r3, [r7, #28]
10001864:	2207      	movs	r2, #7
10001866:	4013      	ands	r3, r2
10001868:	d003      	beq.n	10001872 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x8e>
            {
              --ntq;
1000186a:	697b      	ldr	r3, [r7, #20]
1000186c:	3b01      	subs	r3, #1
1000186e:	617b      	str	r3, [r7, #20]
              continue;
10001870:	e027      	b.n	100018c2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xde>
            }
            else
            {
              div8 = 1;
10001872:	2301      	movs	r3, #1
10001874:	61bb      	str	r3, [r7, #24]
            }
          }

          tseg1 = ((ntq - 1) * bit_time_config->sample_point) / 10000;
10001876:	697b      	ldr	r3, [r7, #20]
10001878:	3b01      	subs	r3, #1
1000187a:	683a      	ldr	r2, [r7, #0]
1000187c:	8912      	ldrh	r2, [r2, #8]
1000187e:	4353      	muls	r3, r2
10001880:	1c18      	adds	r0, r3, #0
10001882:	492e      	ldr	r1, [pc, #184]	; (1000193c <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x158>)
10001884:	f000 fa94 	bl	10001db0 <__aeabi_uidiv>
10001888:	1c03      	adds	r3, r0, #0
1000188a:	613b      	str	r3, [r7, #16]
          tseg2 = ntq - tseg1 - 1;
1000188c:	697a      	ldr	r2, [r7, #20]
1000188e:	693b      	ldr	r3, [r7, #16]
10001890:	1ad3      	subs	r3, r2, r3
10001892:	3b01      	subs	r3, #1
10001894:	60fb      	str	r3, [r7, #12]

          if ((XMC_CAN_NODE_MIN_TSEG1 <= tseg1) && (tseg1 <= XMC_CAN_NODE_MAX_TSEG1) &&
10001896:	693b      	ldr	r3, [r7, #16]
10001898:	2b02      	cmp	r3, #2
1000189a:	d90f      	bls.n	100018bc <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd8>
1000189c:	693b      	ldr	r3, [r7, #16]
1000189e:	2b0f      	cmp	r3, #15
100018a0:	d80c      	bhi.n	100018bc <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd8>
100018a2:	68fb      	ldr	r3, [r7, #12]
100018a4:	2b01      	cmp	r3, #1
100018a6:	d909      	bls.n	100018bc <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd8>
              (XMC_CAN_NODE_MIN_TSEG2 <= tseg2) && (tseg2 < XMC_CAN_NODE_MAX_TSEG2) && (tseg2 >= bit_time_config->sjw))
100018a8:	68fb      	ldr	r3, [r7, #12]
100018aa:	2b06      	cmp	r3, #6
100018ac:	d806      	bhi.n	100018bc <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd8>
100018ae:	683b      	ldr	r3, [r7, #0]
100018b0:	895b      	ldrh	r3, [r3, #10]
100018b2:	1e1a      	subs	r2, r3, #0
100018b4:	68fb      	ldr	r3, [r7, #12]
100018b6:	429a      	cmp	r2, r3
100018b8:	d800      	bhi.n	100018bc <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd8>
          {
            break;
100018ba:	e005      	b.n	100018c8 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xe4>
          }


        }
      }
      --ntq;
100018bc:	697b      	ldr	r3, [r7, #20]
100018be:	3b01      	subs	r3, #1
100018c0:	617b      	str	r3, [r7, #20]

    /* start with highest ntq, i.e as much as possible time quanta should be used to construct a bit time */
    uint32_t ntq = XMC_CAN_NODE_MAX_NTQ;
    uint32_t tseg1 = 0;
    uint32_t tseg2 = 0;
    while (ntq >= XMC_CAN_NODE_MIN_NTQ)
100018c2:	697b      	ldr	r3, [r7, #20]
100018c4:	2b07      	cmp	r3, #7
100018c6:	d8b2      	bhi.n	1000182e <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x4a>
        }
      }
      --ntq;
    }

    if (ntq >= XMC_CAN_NODE_MIN_NTQ)
100018c8:	697b      	ldr	r3, [r7, #20]
100018ca:	2b07      	cmp	r3, #7
100018cc:	d931      	bls.n	10001932 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x14e>

      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: prescaler", (prescaler != 0));
      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: tseg1", (tseg1 != 0));
      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: tseg2", (tseg2 != 0));

      XMC_CAN_NODE_EnableConfigurationChange(can_node);
100018ce:	687b      	ldr	r3, [r7, #4]
100018d0:	1c18      	adds	r0, r3, #0
100018d2:	f7ff ff4f 	bl	10001774 <XMC_CAN_NODE_EnableConfigurationChange>

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
100018d6:	68fb      	ldr	r3, [r7, #12]
100018d8:	3b01      	subs	r3, #1
100018da:	031a      	lsls	r2, r3, #12
100018dc:	23e0      	movs	r3, #224	; 0xe0
100018de:	01db      	lsls	r3, r3, #7
100018e0:	401a      	ands	r2, r3
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
100018e2:	683b      	ldr	r3, [r7, #0]
100018e4:	895b      	ldrh	r3, [r3, #10]
100018e6:	3b01      	subs	r3, #1
100018e8:	019b      	lsls	r3, r3, #6
100018ea:	21ff      	movs	r1, #255	; 0xff
100018ec:	400b      	ands	r3, r1
      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: tseg2", (tseg2 != 0));

      XMC_CAN_NODE_EnableConfigurationChange(can_node);

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
100018ee:	431a      	orrs	r2, r3
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
                       (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
100018f0:	693b      	ldr	r3, [r7, #16]
100018f2:	3b01      	subs	r3, #1
100018f4:	0219      	lsls	r1, r3, #8
100018f6:	23f0      	movs	r3, #240	; 0xf0
100018f8:	011b      	lsls	r3, r3, #4
100018fa:	400b      	ands	r3, r1

      XMC_CAN_NODE_EnableConfigurationChange(can_node);

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
100018fc:	431a      	orrs	r2, r3
100018fe:	1c11      	adds	r1, r2, #0
                       (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
                       ((((prescaler >> (3 * div8)) - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
10001900:	69ba      	ldr	r2, [r7, #24]
10001902:	1c13      	adds	r3, r2, #0
10001904:	005b      	lsls	r3, r3, #1
10001906:	189b      	adds	r3, r3, r2
10001908:	1c1a      	adds	r2, r3, #0
1000190a:	69fb      	ldr	r3, [r7, #28]
1000190c:	40d3      	lsrs	r3, r2
1000190e:	3b01      	subs	r3, #1
10001910:	223f      	movs	r2, #63	; 0x3f
10001912:	4013      	ands	r3, r2
      XMC_CAN_NODE_EnableConfigurationChange(can_node);

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
                       (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
10001914:	1c0a      	adds	r2, r1, #0
10001916:	431a      	orrs	r2, r3
                       ((((prescaler >> (3 * div8)) - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
                       ((div8 << CAN_NODE_NBTR_DIV8_Pos) & (uint32_t)CAN_NODE_NBTR_DIV8_Msk);
10001918:	69bb      	ldr	r3, [r7, #24]
1000191a:	03db      	lsls	r3, r3, #15
1000191c:	041b      	lsls	r3, r3, #16
1000191e:	0c1b      	lsrs	r3, r3, #16

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
                       (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
                       ((((prescaler >> (3 * div8)) - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
10001920:	431a      	orrs	r2, r3
      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: tseg2", (tseg2 != 0));

      XMC_CAN_NODE_EnableConfigurationChange(can_node);

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
10001922:	687b      	ldr	r3, [r7, #4]
10001924:	611a      	str	r2, [r3, #16]
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
                       (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
                       ((((prescaler >> (3 * div8)) - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
                       ((div8 << CAN_NODE_NBTR_DIV8_Pos) & (uint32_t)CAN_NODE_NBTR_DIV8_Msk);

      XMC_CAN_NODE_DisableConfigurationChange(can_node);
10001926:	687b      	ldr	r3, [r7, #4]
10001928:	1c18      	adds	r0, r3, #0
1000192a:	f7ff ff31 	bl	10001790 <XMC_CAN_NODE_DisableConfigurationChange>

      return XMC_CAN_STATUS_SUCCESS;
1000192e:	2300      	movs	r3, #0
10001930:	e000      	b.n	10001934 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x150>
    }
  }

  return XMC_CAN_STATUS_ERROR;
10001932:	2301      	movs	r3, #1
}
10001934:	1c18      	adds	r0, r3, #0
10001936:	46bd      	mov	sp, r7
10001938:	b008      	add	sp, #32
1000193a:	bd80      	pop	{r7, pc}
1000193c:	00002710 	.word	0x00002710

10001940 <XMC_CAN_AllocateMOtoNodeList>:
                   (((uint32_t)0U << CAN_NODE_NBTR_DIV8_Pos) & (uint32_t)CAN_NODE_NBTR_DIV8_Msk);
  XMC_CAN_NODE_DisableConfigurationChange(can_node);
}
/* Function to allocate message object from free list to node list */
void XMC_CAN_AllocateMOtoNodeList(XMC_CAN_t *const obj, const uint8_t node_num, const uint8_t mo_num)
{
10001940:	b590      	push	{r4, r7, lr}
10001942:	b083      	sub	sp, #12
10001944:	af00      	add	r7, sp, #0
10001946:	6078      	str	r0, [r7, #4]
10001948:	1c08      	adds	r0, r1, #0
1000194a:	1c11      	adds	r1, r2, #0
1000194c:	1cfb      	adds	r3, r7, #3
1000194e:	1c02      	adds	r2, r0, #0
10001950:	701a      	strb	r2, [r3, #0]
10001952:	1cbb      	adds	r3, r7, #2
10001954:	1c0a      	adds	r2, r1, #0
10001956:	701a      	strb	r2, [r3, #0]
  /* wait while panel operation is in progress. */
  while (XMC_CAN_IsPanelControlReady(obj) == false)
10001958:	46c0      	nop			; (mov r8, r8)
1000195a:	687b      	ldr	r3, [r7, #4]
1000195c:	1c18      	adds	r0, r3, #0
1000195e:	f7ff fed1 	bl	10001704 <XMC_CAN_IsPanelControlReady>
10001962:	1c03      	adds	r3, r0, #0
10001964:	1c1a      	adds	r2, r3, #0
10001966:	2301      	movs	r3, #1
10001968:	4053      	eors	r3, r2
1000196a:	b2db      	uxtb	r3, r3
1000196c:	2b00      	cmp	r3, #0
1000196e:	d1f4      	bne.n	1000195a <XMC_CAN_AllocateMOtoNodeList+0x1a>
  {
    /*Do nothing*/
  };

  /* Panel Command for  allocation of MO to node list */
  XMC_CAN_PanelControl(obj, XMC_CAN_PANCMD_STATIC_ALLOCATE, mo_num, (node_num + 1U));
10001970:	1cfb      	adds	r3, r7, #3
10001972:	781b      	ldrb	r3, [r3, #0]
10001974:	3301      	adds	r3, #1
10001976:	b2dc      	uxtb	r4, r3
10001978:	687a      	ldr	r2, [r7, #4]
1000197a:	1cbb      	adds	r3, r7, #2
1000197c:	781b      	ldrb	r3, [r3, #0]
1000197e:	1c10      	adds	r0, r2, #0
10001980:	2102      	movs	r1, #2
10001982:	1c1a      	adds	r2, r3, #0
10001984:	1c23      	adds	r3, r4, #0
10001986:	f7ff fecf 	bl	10001728 <XMC_CAN_PanelControl>
}
1000198a:	46bd      	mov	sp, r7
1000198c:	b003      	add	sp, #12
1000198e:	bd90      	pop	{r4, r7, pc}

10001990 <XMC_CAN_Enable>:
#endif
}

/* Enable XMC_CAN Peripheral */
void XMC_CAN_Enable(XMC_CAN_t *const obj)
{
10001990:	b580      	push	{r7, lr}
10001992:	b082      	sub	sp, #8
10001994:	af00      	add	r7, sp, #0
10001996:	6078      	str	r0, [r7, #4]
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_MCAN);
10001998:	2380      	movs	r3, #128	; 0x80
1000199a:	039b      	lsls	r3, r3, #14
1000199c:	1c18      	adds	r0, r3, #0
1000199e:	f7ff fd7f 	bl	100014a0 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_MCAN);
#endif
  /* Enable CAN Module */
  obj->CLC &= ~(uint32_t)CAN_CLC_DISR_Msk;
100019a2:	687b      	ldr	r3, [r7, #4]
100019a4:	681b      	ldr	r3, [r3, #0]
100019a6:	2201      	movs	r2, #1
100019a8:	4393      	bics	r3, r2
100019aa:	1c1a      	adds	r2, r3, #0
100019ac:	687b      	ldr	r3, [r7, #4]
100019ae:	601a      	str	r2, [r3, #0]
  while (obj->CLC & CAN_CLC_DISS_Msk)
100019b0:	46c0      	nop			; (mov r8, r8)
100019b2:	687b      	ldr	r3, [r7, #4]
100019b4:	681b      	ldr	r3, [r3, #0]
100019b6:	2202      	movs	r2, #2
100019b8:	4013      	ands	r3, r2
100019ba:	d1fa      	bne.n	100019b2 <XMC_CAN_Enable+0x22>
  {
    /*Do nothing*/
  };
}
100019bc:	46bd      	mov	sp, r7
100019be:	b002      	add	sp, #8
100019c0:	bd80      	pop	{r7, pc}
100019c2:	46c0      	nop			; (mov r8, r8)

100019c4 <XMC_CAN_SetBaudrateClockSource>:
  obj->FDR |= ((uint32_t)can_divider_mode << CAN_FDR_DM_Pos) | ((uint32_t)step << CAN_FDR_STEP_Pos);
}
#endif

void XMC_CAN_SetBaudrateClockSource(XMC_CAN_t *const obj, const XMC_CAN_CANCLKSRC_t source)
{
100019c4:	b580      	push	{r7, lr}
100019c6:	b082      	sub	sp, #8
100019c8:	af00      	add	r7, sp, #0
100019ca:	6078      	str	r0, [r7, #4]
100019cc:	1c0a      	adds	r2, r1, #0
100019ce:	1cfb      	adds	r3, r7, #3
100019d0:	701a      	strb	r2, [r3, #0]
#if defined(MULTICAN_PLUS)
  obj->MCR = (obj->MCR & ~CAN_MCR_CLKSEL_Msk) | source ;
100019d2:	687a      	ldr	r2, [r7, #4]
100019d4:	23e4      	movs	r3, #228	; 0xe4
100019d6:	005b      	lsls	r3, r3, #1
100019d8:	58d3      	ldr	r3, [r2, r3]
100019da:	220f      	movs	r2, #15
100019dc:	4393      	bics	r3, r2
100019de:	1c1a      	adds	r2, r3, #0
100019e0:	1cfb      	adds	r3, r7, #3
100019e2:	781b      	ldrb	r3, [r3, #0]
100019e4:	431a      	orrs	r2, r3
100019e6:	1c11      	adds	r1, r2, #0
100019e8:	687a      	ldr	r2, [r7, #4]
100019ea:	23e4      	movs	r3, #228	; 0xe4
100019ec:	005b      	lsls	r3, r3, #1
100019ee:	50d1      	str	r1, [r2, r3]
#else
  XMC_UNUSED_ARG(obj);
  XMC_UNUSED_ARG(source);
#endif
}
100019f0:	46bd      	mov	sp, r7
100019f2:	b002      	add	sp, #8
100019f4:	bd80      	pop	{r7, pc}
100019f6:	46c0      	nop			; (mov r8, r8)

100019f8 <XMC_CAN_GetBaudrateClockSource>:

XMC_CAN_CANCLKSRC_t XMC_CAN_GetBaudrateClockSource(XMC_CAN_t *const obj)
{
100019f8:	b580      	push	{r7, lr}
100019fa:	b082      	sub	sp, #8
100019fc:	af00      	add	r7, sp, #0
100019fe:	6078      	str	r0, [r7, #4]
#if defined(MULTICAN_PLUS)
  return ((XMC_CAN_CANCLKSRC_t)((obj->MCR & CAN_MCR_CLKSEL_Msk) >> CAN_MCR_CLKSEL_Pos));
10001a00:	687a      	ldr	r2, [r7, #4]
10001a02:	23e4      	movs	r3, #228	; 0xe4
10001a04:	005b      	lsls	r3, r3, #1
10001a06:	58d3      	ldr	r3, [r2, r3]
10001a08:	b2db      	uxtb	r3, r3
10001a0a:	220f      	movs	r2, #15
10001a0c:	4013      	ands	r3, r2
10001a0e:	b2db      	uxtb	r3, r3
#elif (UC_FAMILY == XMC4)
  XMC_UNUSED_ARG(obj);
  return XMC_CAN_CANCLKSRC_FPERI;
#endif
}
10001a10:	1c18      	adds	r0, r3, #0
10001a12:	46bd      	mov	sp, r7
10001a14:	b002      	add	sp, #8
10001a16:	bd80      	pop	{r7, pc}

10001a18 <XMC_CAN_GetBaudrateClockFrequency>:

uint32_t XMC_CAN_GetBaudrateClockFrequency(XMC_CAN_t *const obj)
{
10001a18:	b580      	push	{r7, lr}
10001a1a:	b084      	sub	sp, #16
10001a1c:	af00      	add	r7, sp, #0
10001a1e:	6078      	str	r0, [r7, #4]
  uint32_t frequency = 0;
10001a20:	2300      	movs	r3, #0
10001a22:	60fb      	str	r3, [r7, #12]

#if defined(MULTICAN_PLUS)
  switch (XMC_CAN_GetBaudrateClockSource(obj))
10001a24:	687b      	ldr	r3, [r7, #4]
10001a26:	1c18      	adds	r0, r3, #0
10001a28:	f7ff ffe6 	bl	100019f8 <XMC_CAN_GetBaudrateClockSource>
10001a2c:	1e03      	subs	r3, r0, #0
10001a2e:	2b01      	cmp	r3, #1
10001a30:	d002      	beq.n	10001a38 <XMC_CAN_GetBaudrateClockFrequency+0x20>
10001a32:	2b02      	cmp	r3, #2
10001a34:	d005      	beq.n	10001a42 <XMC_CAN_GetBaudrateClockFrequency+0x2a>
10001a36:	e009      	b.n	10001a4c <XMC_CAN_GetBaudrateClockFrequency+0x34>
    case XMC_CAN_CANCLKSRC_FPERI:
      frequency = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
      break;
#else
    case XMC_CAN_CANCLKSRC_MCLK:
      frequency = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
10001a38:	f7ff fe14 	bl	10001664 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
10001a3c:	1c03      	adds	r3, r0, #0
10001a3e:	60fb      	str	r3, [r7, #12]
      break;
10001a40:	e004      	b.n	10001a4c <XMC_CAN_GetBaudrateClockFrequency+0x34>
#endif
    case XMC_CAN_CANCLKSRC_FOHP:
      frequency = OSCHP_GetFrequency();
10001a42:	f7ff fb99 	bl	10001178 <OSCHP_GetFrequency>
10001a46:	1c03      	adds	r3, r0, #0
10001a48:	60fb      	str	r3, [r7, #12]
      break;
10001a4a:	46c0      	nop			; (mov r8, r8)
#else
  XMC_UNUSED_ARG(obj);
  frequency = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
#endif

  return frequency;
10001a4c:	68fb      	ldr	r3, [r7, #12]
}
10001a4e:	1c18      	adds	r0, r3, #0
10001a50:	46bd      	mov	sp, r7
10001a52:	b004      	add	sp, #16
10001a54:	bd80      	pop	{r7, pc}
10001a56:	46c0      	nop			; (mov r8, r8)

10001a58 <XMC_CAN_InitEx>:

uint32_t XMC_CAN_InitEx(XMC_CAN_t *const obj, XMC_CAN_CANCLKSRC_t clksrc, uint32_t can_frequency)
{
10001a58:	b580      	push	{r7, lr}
10001a5a:	b088      	sub	sp, #32
10001a5c:	af00      	add	r7, sp, #0
10001a5e:	60f8      	str	r0, [r7, #12]
10001a60:	607a      	str	r2, [r7, #4]
10001a62:	230b      	movs	r3, #11
10001a64:	18fb      	adds	r3, r7, r3
10001a66:	1c0a      	adds	r2, r1, #0
10001a68:	701a      	strb	r2, [r3, #0]
  uint32_t step_n;
  uint32_t freq_n;
  uint32_t peripheral_frequency;

  /*Enabling the module*/
  XMC_CAN_Enable(obj);
10001a6a:	68fb      	ldr	r3, [r7, #12]
10001a6c:	1c18      	adds	r0, r3, #0
10001a6e:	f7ff ff8f 	bl	10001990 <XMC_CAN_Enable>

  XMC_CAN_SetBaudrateClockSource(obj, clksrc);
10001a72:	68fa      	ldr	r2, [r7, #12]
10001a74:	230b      	movs	r3, #11
10001a76:	18fb      	adds	r3, r7, r3
10001a78:	781b      	ldrb	r3, [r3, #0]
10001a7a:	1c10      	adds	r0, r2, #0
10001a7c:	1c19      	adds	r1, r3, #0
10001a7e:	f7ff ffa1 	bl	100019c4 <XMC_CAN_SetBaudrateClockSource>
  peripheral_frequency = XMC_CAN_GetBaudrateClockFrequency(obj);
10001a82:	68fb      	ldr	r3, [r7, #12]
10001a84:	1c18      	adds	r0, r3, #0
10001a86:	f7ff ffc7 	bl	10001a18 <XMC_CAN_GetBaudrateClockFrequency>
10001a8a:	1c03      	adds	r3, r0, #0
10001a8c:	61fb      	str	r3, [r7, #28]
  XMC_ASSERT("XMC_CAN_Init: frequency not supported", can_frequency <= peripheral_frequency);

  /* Normal divider mode */
  step_n = (uint32_t)min(max(0U, (1024U - (peripheral_frequency / can_frequency))), 1023U);
10001a8e:	69f8      	ldr	r0, [r7, #28]
10001a90:	6879      	ldr	r1, [r7, #4]
10001a92:	f000 f98d 	bl	10001db0 <__aeabi_uidiv>
10001a96:	1c03      	adds	r3, r0, #0
10001a98:	1c1a      	adds	r2, r3, #0
10001a9a:	2380      	movs	r3, #128	; 0x80
10001a9c:	00db      	lsls	r3, r3, #3
10001a9e:	1a9b      	subs	r3, r3, r2
10001aa0:	2000      	movs	r0, #0
10001aa2:	1c19      	adds	r1, r3, #0
10001aa4:	f7ff fe82 	bl	100017ac <max>
10001aa8:	1c02      	adds	r2, r0, #0
10001aaa:	4b12      	ldr	r3, [pc, #72]	; (10001af4 <XMC_CAN_InitEx+0x9c>)
10001aac:	1c10      	adds	r0, r2, #0
10001aae:	1c19      	adds	r1, r3, #0
10001ab0:	f7ff fe8a 	bl	100017c8 <min>
10001ab4:	1c03      	adds	r3, r0, #0
10001ab6:	61bb      	str	r3, [r7, #24]
  freq_n = (uint32_t)(peripheral_frequency / (1024U - step_n));
10001ab8:	69bb      	ldr	r3, [r7, #24]
10001aba:	2280      	movs	r2, #128	; 0x80
10001abc:	00d2      	lsls	r2, r2, #3
10001abe:	1ad3      	subs	r3, r2, r3
10001ac0:	69f8      	ldr	r0, [r7, #28]
10001ac2:	1c19      	adds	r1, r3, #0
10001ac4:	f000 f974 	bl	10001db0 <__aeabi_uidiv>
10001ac8:	1c03      	adds	r3, r0, #0
10001aca:	617b      	str	r3, [r7, #20]

  obj->FDR &= (uint32_t) ~(CAN_FDR_DM_Msk | CAN_FDR_STEP_Msk);
10001acc:	68fb      	ldr	r3, [r7, #12]
10001ace:	68db      	ldr	r3, [r3, #12]
10001ad0:	4a09      	ldr	r2, [pc, #36]	; (10001af8 <XMC_CAN_InitEx+0xa0>)
10001ad2:	401a      	ands	r2, r3
10001ad4:	68fb      	ldr	r3, [r7, #12]
10001ad6:	60da      	str	r2, [r3, #12]
  obj->FDR |= ((uint32_t)XMC_CAN_DM_NORMAL << CAN_FDR_DM_Pos) | ((uint32_t)step_n << CAN_FDR_STEP_Pos);
10001ad8:	68fb      	ldr	r3, [r7, #12]
10001ada:	68da      	ldr	r2, [r3, #12]
10001adc:	69bb      	ldr	r3, [r7, #24]
10001ade:	4313      	orrs	r3, r2
10001ae0:	2280      	movs	r2, #128	; 0x80
10001ae2:	01d2      	lsls	r2, r2, #7
10001ae4:	431a      	orrs	r2, r3
10001ae6:	68fb      	ldr	r3, [r7, #12]
10001ae8:	60da      	str	r2, [r3, #12]

  return freq_n;
10001aea:	697b      	ldr	r3, [r7, #20]
}
10001aec:	1c18      	adds	r0, r3, #0
10001aee:	46bd      	mov	sp, r7
10001af0:	b008      	add	sp, #32
10001af2:	bd80      	pop	{r7, pc}
10001af4:	000003ff 	.word	0x000003ff
10001af8:	ffff3c00 	.word	0xffff3c00

10001afc <XMC_CAN_MO_Config>:
  can_mo->can_id_mask = can_id_mask;
}

/* Initialization of XMC_CAN MO Object */
void XMC_CAN_MO_Config(const XMC_CAN_MO_t *const can_mo)
{
10001afc:	b580      	push	{r7, lr}
10001afe:	b086      	sub	sp, #24
10001b00:	af00      	add	r7, sp, #0
10001b02:	6078      	str	r0, [r7, #4]
  uint32_t reg;

  /* Configure MPN */
  uint32_t num = ((uint32_t)(can_mo->can_mo_ptr) - CAN_BASE - 0x1000U) / 0x0020U;
10001b04:	687b      	ldr	r3, [r7, #4]
10001b06:	681b      	ldr	r3, [r3, #0]
10001b08:	4a48      	ldr	r2, [pc, #288]	; (10001c2c <XMC_CAN_MO_Config+0x130>)
10001b0a:	4694      	mov	ip, r2
10001b0c:	4463      	add	r3, ip
10001b0e:	095b      	lsrs	r3, r3, #5
10001b10:	617b      	str	r3, [r7, #20]
  uint32_t set = (((uint32_t)(num / 32) << (CAN_MO_MOIPR_MPN_Pos + 5U)) | ((uint32_t)(num % 32) << CAN_MO_MOIPR_MPN_Pos));
10001b12:	697b      	ldr	r3, [r7, #20]
10001b14:	095b      	lsrs	r3, r3, #5
10001b16:	035a      	lsls	r2, r3, #13
10001b18:	697b      	ldr	r3, [r7, #20]
10001b1a:	211f      	movs	r1, #31
10001b1c:	400b      	ands	r3, r1
10001b1e:	021b      	lsls	r3, r3, #8
10001b20:	4313      	orrs	r3, r2
10001b22:	613b      	str	r3, [r7, #16]
  can_mo->can_mo_ptr->MOIPR &= ~(CAN_MO_MOIPR_MPN_Msk);
10001b24:	687b      	ldr	r3, [r7, #4]
10001b26:	681b      	ldr	r3, [r3, #0]
10001b28:	687a      	ldr	r2, [r7, #4]
10001b2a:	6812      	ldr	r2, [r2, #0]
10001b2c:	6892      	ldr	r2, [r2, #8]
10001b2e:	4940      	ldr	r1, [pc, #256]	; (10001c30 <XMC_CAN_MO_Config+0x134>)
10001b30:	400a      	ands	r2, r1
10001b32:	609a      	str	r2, [r3, #8]
  can_mo->can_mo_ptr->MOIPR |= set;
10001b34:	687b      	ldr	r3, [r7, #4]
10001b36:	681b      	ldr	r3, [r3, #0]
10001b38:	687a      	ldr	r2, [r7, #4]
10001b3a:	6812      	ldr	r2, [r2, #0]
10001b3c:	6891      	ldr	r1, [r2, #8]
10001b3e:	693a      	ldr	r2, [r7, #16]
10001b40:	430a      	orrs	r2, r1
10001b42:	609a      	str	r2, [r3, #8]

  if (((can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_STANDARD_11BITS) &&
10001b44:	687b      	ldr	r3, [r7, #4]
10001b46:	79db      	ldrb	r3, [r3, #7]
10001b48:	2220      	movs	r2, #32
10001b4a:	4013      	ands	r3, r2
10001b4c:	b2db      	uxtb	r3, r3
10001b4e:	2b00      	cmp	r3, #0
10001b50:	d007      	beq.n	10001b62 <XMC_CAN_MO_Config+0x66>
       (can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_EXTENDED_29BITS)) ||
10001b52:	687b      	ldr	r3, [r7, #4]
10001b54:	79db      	ldrb	r3, [r3, #7]
10001b56:	2220      	movs	r2, #32
10001b58:	4013      	ands	r3, r2
10001b5a:	b2db      	uxtb	r3, r3
  uint32_t num = ((uint32_t)(can_mo->can_mo_ptr) - CAN_BASE - 0x1000U) / 0x0020U;
  uint32_t set = (((uint32_t)(num / 32) << (CAN_MO_MOIPR_MPN_Pos + 5U)) | ((uint32_t)(num % 32) << CAN_MO_MOIPR_MPN_Pos));
  can_mo->can_mo_ptr->MOIPR &= ~(CAN_MO_MOIPR_MPN_Msk);
  can_mo->can_mo_ptr->MOIPR |= set;

  if (((can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_STANDARD_11BITS) &&
10001b5c:	2b00      	cmp	r3, #0
10001b5e:	d100      	bne.n	10001b62 <XMC_CAN_MO_Config+0x66>
10001b60:	e061      	b.n	10001c26 <XMC_CAN_MO_Config+0x12a>
       (can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_EXTENDED_29BITS)) ||
      ((can_mo->can_mo_type != XMC_CAN_MO_TYPE_RECMSGOBJ) &&
10001b62:	687b      	ldr	r3, [r7, #4]
10001b64:	7e1b      	ldrb	r3, [r3, #24]
  uint32_t set = (((uint32_t)(num / 32) << (CAN_MO_MOIPR_MPN_Pos + 5U)) | ((uint32_t)(num % 32) << CAN_MO_MOIPR_MPN_Pos));
  can_mo->can_mo_ptr->MOIPR &= ~(CAN_MO_MOIPR_MPN_Msk);
  can_mo->can_mo_ptr->MOIPR |= set;

  if (((can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_STANDARD_11BITS) &&
       (can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_EXTENDED_29BITS)) ||
10001b66:	2b00      	cmp	r3, #0
10001b68:	d004      	beq.n	10001b74 <XMC_CAN_MO_Config+0x78>
      ((can_mo->can_mo_type != XMC_CAN_MO_TYPE_RECMSGOBJ) &&
       (can_mo->can_mo_type != XMC_CAN_MO_TYPE_TRANSMSGOBJ)))
10001b6a:	687b      	ldr	r3, [r7, #4]
10001b6c:	7e1b      	ldrb	r3, [r3, #24]
  can_mo->can_mo_ptr->MOIPR &= ~(CAN_MO_MOIPR_MPN_Msk);
  can_mo->can_mo_ptr->MOIPR |= set;

  if (((can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_STANDARD_11BITS) &&
       (can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_EXTENDED_29BITS)) ||
      ((can_mo->can_mo_type != XMC_CAN_MO_TYPE_RECMSGOBJ) &&
10001b6e:	2b01      	cmp	r3, #1
10001b70:	d000      	beq.n	10001b74 <XMC_CAN_MO_Config+0x78>
10001b72:	e058      	b.n	10001c26 <XMC_CAN_MO_Config+0x12a>
  }
  else
  {

    /* Disable Message object */
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
10001b74:	687b      	ldr	r3, [r7, #4]
10001b76:	681b      	ldr	r3, [r3, #0]
10001b78:	2220      	movs	r2, #32
10001b7a:	61da      	str	r2, [r3, #28]
    if (can_mo->can_id_mode == (uint32_t)XMC_CAN_FRAME_TYPE_STANDARD_11BITS)
10001b7c:	687b      	ldr	r3, [r7, #4]
10001b7e:	79db      	ldrb	r3, [r3, #7]
10001b80:	2220      	movs	r2, #32
10001b82:	4013      	ands	r3, r2
10001b84:	b2db      	uxtb	r3, r3
10001b86:	2b00      	cmp	r3, #0
10001b88:	d128      	bne.n	10001bdc <XMC_CAN_MO_Config+0xe0>
    {
      reg = can_mo->mo_ar;
10001b8a:	687b      	ldr	r3, [r7, #4]
10001b8c:	685b      	ldr	r3, [r3, #4]
10001b8e:	60fb      	str	r3, [r7, #12]
      reg &= (uint32_t) ~(CAN_MO_MOAR_ID_Msk);
10001b90:	68fb      	ldr	r3, [r7, #12]
10001b92:	0f5b      	lsrs	r3, r3, #29
10001b94:	075b      	lsls	r3, r3, #29
10001b96:	60fb      	str	r3, [r7, #12]
      reg |= (can_mo->can_identifier << XMC_CAN_MO_MOAR_STDID_Pos);
10001b98:	687b      	ldr	r3, [r7, #4]
10001b9a:	685b      	ldr	r3, [r3, #4]
10001b9c:	00db      	lsls	r3, r3, #3
10001b9e:	08db      	lsrs	r3, r3, #3
10001ba0:	049b      	lsls	r3, r3, #18
10001ba2:	1c1a      	adds	r2, r3, #0
10001ba4:	68fb      	ldr	r3, [r7, #12]
10001ba6:	4313      	orrs	r3, r2
10001ba8:	60fb      	str	r3, [r7, #12]
      can_mo->can_mo_ptr->MOAR = reg;
10001baa:	687b      	ldr	r3, [r7, #4]
10001bac:	681b      	ldr	r3, [r3, #0]
10001bae:	68fa      	ldr	r2, [r7, #12]
10001bb0:	619a      	str	r2, [r3, #24]

      reg = can_mo->mo_amr;
10001bb2:	687b      	ldr	r3, [r7, #4]
10001bb4:	689b      	ldr	r3, [r3, #8]
10001bb6:	60fb      	str	r3, [r7, #12]
      reg &= (uint32_t) ~(CAN_MO_MOAMR_AM_Msk);
10001bb8:	68fb      	ldr	r3, [r7, #12]
10001bba:	0f5b      	lsrs	r3, r3, #29
10001bbc:	075b      	lsls	r3, r3, #29
10001bbe:	60fb      	str	r3, [r7, #12]
      reg |= (can_mo->can_id_mask << XMC_CAN_MO_MOAR_STDID_Pos);
10001bc0:	687b      	ldr	r3, [r7, #4]
10001bc2:	689b      	ldr	r3, [r3, #8]
10001bc4:	00db      	lsls	r3, r3, #3
10001bc6:	08db      	lsrs	r3, r3, #3
10001bc8:	049b      	lsls	r3, r3, #18
10001bca:	1c1a      	adds	r2, r3, #0
10001bcc:	68fb      	ldr	r3, [r7, #12]
10001bce:	4313      	orrs	r3, r2
10001bd0:	60fb      	str	r3, [r7, #12]
      can_mo->can_mo_ptr->MOAMR = reg;
10001bd2:	687b      	ldr	r3, [r7, #4]
10001bd4:	681b      	ldr	r3, [r3, #0]
10001bd6:	68fa      	ldr	r2, [r7, #12]
10001bd8:	60da      	str	r2, [r3, #12]
10001bda:	e009      	b.n	10001bf0 <XMC_CAN_MO_Config+0xf4>
    }
    else
    {
      can_mo->can_mo_ptr->MOAR = can_mo->mo_ar;
10001bdc:	687b      	ldr	r3, [r7, #4]
10001bde:	681b      	ldr	r3, [r3, #0]
10001be0:	687a      	ldr	r2, [r7, #4]
10001be2:	6852      	ldr	r2, [r2, #4]
10001be4:	619a      	str	r2, [r3, #24]
      can_mo->can_mo_ptr->MOAMR = can_mo->mo_amr;
10001be6:	687b      	ldr	r3, [r7, #4]
10001be8:	681b      	ldr	r3, [r3, #0]
10001bea:	687a      	ldr	r2, [r7, #4]
10001bec:	6892      	ldr	r2, [r2, #8]
10001bee:	60da      	str	r2, [r3, #12]
    }
    /* Check whether message object is transmit message object */
    if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
10001bf0:	687b      	ldr	r3, [r7, #4]
10001bf2:	7e1b      	ldrb	r3, [r3, #24]
10001bf4:	2b01      	cmp	r3, #1
10001bf6:	d10d      	bne.n	10001c14 <XMC_CAN_MO_Config+0x118>
    {
      /* Set MO as Transmit message object  */
      XMC_CAN_MO_UpdateData(can_mo);
10001bf8:	687b      	ldr	r3, [r7, #4]
10001bfa:	1c18      	adds	r0, r3, #0
10001bfc:	f000 f81e 	bl	10001c3c <XMC_CAN_MO_UpdateData>
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_SETDIR_Msk;
10001c00:	687b      	ldr	r3, [r7, #4]
10001c02:	681b      	ldr	r3, [r3, #0]
10001c04:	2280      	movs	r2, #128	; 0x80
10001c06:	0512      	lsls	r2, r2, #20
10001c08:	61da      	str	r2, [r3, #28]

      /* Reset RTSEL and Set MSGVAL, TXEN0 and TXEN1 bits */
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_SETTXEN0_Msk | CAN_MO_MOCTR_SETTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
10001c0a:	687b      	ldr	r3, [r7, #4]
10001c0c:	681b      	ldr	r3, [r3, #0]
10001c0e:	4a09      	ldr	r2, [pc, #36]	; (10001c34 <XMC_CAN_MO_Config+0x138>)
10001c10:	61da      	str	r2, [r3, #28]
10001c12:	e008      	b.n	10001c26 <XMC_CAN_MO_Config+0x12a>
                                   CAN_MO_MOCTR_RESRXEN_Msk  | CAN_MO_MOCTR_RESRTSEL_Msk);
    }
    else
    {
      /* Set MO as Receive message object and set RXEN bit */
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESDIR_Msk;
10001c14:	687b      	ldr	r3, [r7, #4]
10001c16:	681b      	ldr	r3, [r3, #0]
10001c18:	2280      	movs	r2, #128	; 0x80
10001c1a:	0112      	lsls	r2, r2, #4
10001c1c:	61da      	str	r2, [r3, #28]

      /* Reset RTSEL, TXEN1 and TXEN2 and Set MSGVAL and RXEN bits */
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_RESTXEN0_Msk | CAN_MO_MOCTR_RESTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
10001c1e:	687b      	ldr	r3, [r7, #4]
10001c20:	681b      	ldr	r3, [r3, #0]
10001c22:	4a05      	ldr	r2, [pc, #20]	; (10001c38 <XMC_CAN_MO_Config+0x13c>)
10001c24:	61da      	str	r2, [r3, #28]
                                   CAN_MO_MOCTR_SETRXEN_Msk | CAN_MO_MOCTR_RESRTSEL_Msk);
    }

  }
}
10001c26:	46bd      	mov	sp, r7
10001c28:	b006      	add	sp, #24
10001c2a:	bd80      	pop	{r7, pc}
10001c2c:	affbf000 	.word	0xaffbf000
10001c30:	ffff00ff 	.word	0xffff00ff
10001c34:	062000c0 	.word	0x062000c0
10001c38:	00a00640 	.word	0x00a00640

10001c3c <XMC_CAN_MO_UpdateData>:

/* Update of XMC_CAN Object */
XMC_CAN_STATUS_t XMC_CAN_MO_UpdateData(const XMC_CAN_MO_t *const can_mo)
{
10001c3c:	b580      	push	{r7, lr}
10001c3e:	b084      	sub	sp, #16
10001c40:	af00      	add	r7, sp, #0
10001c42:	6078      	str	r0, [r7, #4]
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
10001c44:	230f      	movs	r3, #15
10001c46:	18fb      	adds	r3, r7, r3
10001c48:	2203      	movs	r2, #3
10001c4a:	701a      	strb	r2, [r3, #0]
  /* Check whether message object is transmit message object */
  if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
10001c4c:	687b      	ldr	r3, [r7, #4]
10001c4e:	7e1b      	ldrb	r3, [r3, #24]
10001c50:	2b01      	cmp	r3, #1
10001c52:	d125      	bne.n	10001ca0 <XMC_CAN_MO_UpdateData+0x64>
  {
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
10001c54:	687b      	ldr	r3, [r7, #4]
10001c56:	681b      	ldr	r3, [r3, #0]
10001c58:	2220      	movs	r2, #32
10001c5a:	61da      	str	r2, [r3, #28]
    /* Configure data length */
    can_mo->can_mo_ptr->MOFCR = ((can_mo->can_mo_ptr->MOFCR) & ~(uint32_t)(CAN_MO_MOFCR_DLC_Msk)) |
10001c5c:	687b      	ldr	r3, [r7, #4]
10001c5e:	681b      	ldr	r3, [r3, #0]
10001c60:	687a      	ldr	r2, [r7, #4]
10001c62:	6812      	ldr	r2, [r2, #0]
10001c64:	6812      	ldr	r2, [r2, #0]
10001c66:	4914      	ldr	r1, [pc, #80]	; (10001cb8 <XMC_CAN_MO_UpdateData+0x7c>)
10001c68:	4011      	ands	r1, r2
                                (((uint32_t) can_mo->can_data_length << CAN_MO_MOFCR_DLC_Pos) & (uint32_t)CAN_MO_MOFCR_DLC_Msk);
10001c6a:	687a      	ldr	r2, [r7, #4]
10001c6c:	7b12      	ldrb	r2, [r2, #12]
10001c6e:	0610      	lsls	r0, r2, #24
10001c70:	22f0      	movs	r2, #240	; 0xf0
10001c72:	0512      	lsls	r2, r2, #20
10001c74:	4002      	ands	r2, r0
  /* Check whether message object is transmit message object */
  if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
  {
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
    /* Configure data length */
    can_mo->can_mo_ptr->MOFCR = ((can_mo->can_mo_ptr->MOFCR) & ~(uint32_t)(CAN_MO_MOFCR_DLC_Msk)) |
10001c76:	430a      	orrs	r2, r1
10001c78:	601a      	str	r2, [r3, #0]
                                (((uint32_t) can_mo->can_data_length << CAN_MO_MOFCR_DLC_Pos) & (uint32_t)CAN_MO_MOFCR_DLC_Msk);
    /* Configure Data registers*/
    can_mo->can_mo_ptr->MODATAL = can_mo->can_data[0];
10001c7a:	687b      	ldr	r3, [r7, #4]
10001c7c:	681b      	ldr	r3, [r3, #0]
10001c7e:	687a      	ldr	r2, [r7, #4]
10001c80:	6912      	ldr	r2, [r2, #16]
10001c82:	611a      	str	r2, [r3, #16]
    can_mo->can_mo_ptr->MODATAH = can_mo->can_data[1];
10001c84:	687b      	ldr	r3, [r7, #4]
10001c86:	681b      	ldr	r3, [r3, #0]
10001c88:	687a      	ldr	r2, [r7, #4]
10001c8a:	6952      	ldr	r2, [r2, #20]
10001c8c:	615a      	str	r2, [r3, #20]
    /* Reset RTSEL and Set MSGVAL ,TXEN0 and TXEN1 bits */
    can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_SETNEWDAT_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk | CAN_MO_MOCTR_RESRTSEL_Msk);
10001c8e:	687b      	ldr	r3, [r7, #4]
10001c90:	681b      	ldr	r3, [r3, #0]
10001c92:	4a0a      	ldr	r2, [pc, #40]	; (10001cbc <XMC_CAN_MO_UpdateData+0x80>)
10001c94:	61da      	str	r2, [r3, #28]
    error = XMC_CAN_STATUS_SUCCESS;
10001c96:	230f      	movs	r3, #15
10001c98:	18fb      	adds	r3, r7, r3
10001c9a:	2200      	movs	r2, #0
10001c9c:	701a      	strb	r2, [r3, #0]
10001c9e:	e003      	b.n	10001ca8 <XMC_CAN_MO_UpdateData+0x6c>
  }
  else
  {
    error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
10001ca0:	230f      	movs	r3, #15
10001ca2:	18fb      	adds	r3, r7, r3
10001ca4:	2203      	movs	r2, #3
10001ca6:	701a      	strb	r2, [r3, #0]
  }
  return error;
10001ca8:	230f      	movs	r3, #15
10001caa:	18fb      	adds	r3, r7, r3
10001cac:	781b      	ldrb	r3, [r3, #0]
}
10001cae:	1c18      	adds	r0, r3, #0
10001cb0:	46bd      	mov	sp, r7
10001cb2:	b004      	add	sp, #16
10001cb4:	bd80      	pop	{r7, pc}
10001cb6:	46c0      	nop			; (mov r8, r8)
10001cb8:	f0ffffff 	.word	0xf0ffffff
10001cbc:	00280040 	.word	0x00280040

10001cc0 <XMC_CAN_MO_Transmit>:

/* This function is will put a transmit request to transmit message object */
XMC_CAN_STATUS_t XMC_CAN_MO_Transmit(const XMC_CAN_MO_t *const can_mo)
{
10001cc0:	b580      	push	{r7, lr}
10001cc2:	b086      	sub	sp, #24
10001cc4:	af00      	add	r7, sp, #0
10001cc6:	6078      	str	r0, [r7, #4]
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_ERROR;
10001cc8:	2317      	movs	r3, #23
10001cca:	18fb      	adds	r3, r7, r3
10001ccc:	2201      	movs	r2, #1
10001cce:	701a      	strb	r2, [r3, #0]
  uint32_t mo_type = (uint32_t)(((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_MSGVAL_Msk) >> CAN_MO_MOSTAT_MSGVAL_Pos);
10001cd0:	687b      	ldr	r3, [r7, #4]
10001cd2:	681b      	ldr	r3, [r3, #0]
10001cd4:	69db      	ldr	r3, [r3, #28]
10001cd6:	2220      	movs	r2, #32
10001cd8:	4013      	ands	r3, r2
10001cda:	095b      	lsrs	r3, r3, #5
10001cdc:	613b      	str	r3, [r7, #16]
  uint32_t mo_transmission_ongoing = (uint32_t) ((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_TXRQ_Msk) >> CAN_MO_MOSTAT_TXRQ_Pos;
10001cde:	687b      	ldr	r3, [r7, #4]
10001ce0:	681b      	ldr	r3, [r3, #0]
10001ce2:	69da      	ldr	r2, [r3, #28]
10001ce4:	2380      	movs	r3, #128	; 0x80
10001ce6:	005b      	lsls	r3, r3, #1
10001ce8:	4013      	ands	r3, r2
10001cea:	0a1b      	lsrs	r3, r3, #8
10001cec:	60fb      	str	r3, [r7, #12]
  /* check if message is disabled */
  if (mo_type == 0U)
10001cee:	693b      	ldr	r3, [r7, #16]
10001cf0:	2b00      	cmp	r3, #0
10001cf2:	d104      	bne.n	10001cfe <XMC_CAN_MO_Transmit+0x3e>
  {
    error = XMC_CAN_STATUS_MO_DISABLED;
10001cf4:	2317      	movs	r3, #23
10001cf6:	18fb      	adds	r3, r7, r3
10001cf8:	2204      	movs	r2, #4
10001cfa:	701a      	strb	r2, [r3, #0]
10001cfc:	e010      	b.n	10001d20 <XMC_CAN_MO_Transmit+0x60>
  }
  /* check if transmission is ongoing on message object */
  else if (mo_transmission_ongoing == 1U)
10001cfe:	68fb      	ldr	r3, [r7, #12]
10001d00:	2b01      	cmp	r3, #1
10001d02:	d104      	bne.n	10001d0e <XMC_CAN_MO_Transmit+0x4e>
  {
    error = XMC_CAN_STATUS_BUSY;
10001d04:	2317      	movs	r3, #23
10001d06:	18fb      	adds	r3, r7, r3
10001d08:	2202      	movs	r2, #2
10001d0a:	701a      	strb	r2, [r3, #0]
10001d0c:	e008      	b.n	10001d20 <XMC_CAN_MO_Transmit+0x60>
  }
  else
  {
    /* set TXRQ bit */
    can_mo->can_mo_ptr-> MOCTR = CAN_MO_MOCTR_SETTXRQ_Msk | CAN_MO_MOCTR_SETTXEN0_Msk | CAN_MO_MOCTR_SETTXEN1_Msk;
10001d0e:	687b      	ldr	r3, [r7, #4]
10001d10:	681b      	ldr	r3, [r3, #0]
10001d12:	22e0      	movs	r2, #224	; 0xe0
10001d14:	04d2      	lsls	r2, r2, #19
10001d16:	61da      	str	r2, [r3, #28]
    error = XMC_CAN_STATUS_SUCCESS;
10001d18:	2317      	movs	r3, #23
10001d1a:	18fb      	adds	r3, r7, r3
10001d1c:	2200      	movs	r2, #0
10001d1e:	701a      	strb	r2, [r3, #0]
  }
  return error;
10001d20:	2317      	movs	r3, #23
10001d22:	18fb      	adds	r3, r7, r3
10001d24:	781b      	ldrb	r3, [r3, #0]
}
10001d26:	1c18      	adds	r0, r3, #0
10001d28:	46bd      	mov	sp, r7
10001d2a:	b006      	add	sp, #24
10001d2c:	bd80      	pop	{r7, pc}
10001d2e:	46c0      	nop			; (mov r8, r8)

10001d30 <XMC_CAN_NODE_EnableEvent>:
  return error;
}

/* Function to enable node event */
void XMC_CAN_NODE_EnableEvent(XMC_CAN_NODE_t *const can_node, const XMC_CAN_NODE_EVENT_t event)
{
10001d30:	b580      	push	{r7, lr}
10001d32:	b082      	sub	sp, #8
10001d34:	af00      	add	r7, sp, #0
10001d36:	6078      	str	r0, [r7, #4]
10001d38:	6039      	str	r1, [r7, #0]
  if (event != XMC_CAN_NODE_EVENT_CFCIE)
10001d3a:	683a      	ldr	r2, [r7, #0]
10001d3c:	2380      	movs	r3, #128	; 0x80
10001d3e:	03db      	lsls	r3, r3, #15
10001d40:	429a      	cmp	r2, r3
10001d42:	d006      	beq.n	10001d52 <XMC_CAN_NODE_EnableEvent+0x22>
  {
    can_node->NCR |= (uint32_t)event;
10001d44:	687b      	ldr	r3, [r7, #4]
10001d46:	681a      	ldr	r2, [r3, #0]
10001d48:	683b      	ldr	r3, [r7, #0]
10001d4a:	431a      	orrs	r2, r3
10001d4c:	687b      	ldr	r3, [r7, #4]
10001d4e:	601a      	str	r2, [r3, #0]
10001d50:	e005      	b.n	10001d5e <XMC_CAN_NODE_EnableEvent+0x2e>
  }
  else
  {
    can_node->NFCR |= (uint32_t)event;
10001d52:	687b      	ldr	r3, [r7, #4]
10001d54:	699a      	ldr	r2, [r3, #24]
10001d56:	683b      	ldr	r3, [r7, #0]
10001d58:	431a      	orrs	r2, r3
10001d5a:	687b      	ldr	r3, [r7, #4]
10001d5c:	619a      	str	r2, [r3, #24]
  }
}
10001d5e:	46bd      	mov	sp, r7
10001d60:	b002      	add	sp, #8
10001d62:	bd80      	pop	{r7, pc}

10001d64 <XMC_GPIO_SetHardwareControl>:
  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
}

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
10001d64:	b580      	push	{r7, lr}
10001d66:	b082      	sub	sp, #8
10001d68:	af00      	add	r7, sp, #0
10001d6a:	6078      	str	r0, [r7, #4]
10001d6c:	1c08      	adds	r0, r1, #0
10001d6e:	1c11      	adds	r1, r2, #0
10001d70:	1cfb      	adds	r3, r7, #3
10001d72:	1c02      	adds	r2, r0, #0
10001d74:	701a      	strb	r2, [r3, #0]
10001d76:	1cbb      	adds	r3, r7, #2
10001d78:	1c0a      	adds	r2, r1, #0
10001d7a:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
10001d7c:	687b      	ldr	r3, [r7, #4]
10001d7e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
10001d80:	1cfa      	adds	r2, r7, #3
10001d82:	7812      	ldrb	r2, [r2, #0]
10001d84:	0052      	lsls	r2, r2, #1
10001d86:	1c11      	adds	r1, r2, #0
10001d88:	2203      	movs	r2, #3
10001d8a:	408a      	lsls	r2, r1
10001d8c:	43d2      	mvns	r2, r2
10001d8e:	401a      	ands	r2, r3
10001d90:	687b      	ldr	r3, [r7, #4]
10001d92:	675a      	str	r2, [r3, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
10001d94:	687b      	ldr	r3, [r7, #4]
10001d96:	6f5a      	ldr	r2, [r3, #116]	; 0x74
10001d98:	1cbb      	adds	r3, r7, #2
10001d9a:	781b      	ldrb	r3, [r3, #0]
10001d9c:	1cf9      	adds	r1, r7, #3
10001d9e:	7809      	ldrb	r1, [r1, #0]
10001da0:	0049      	lsls	r1, r1, #1
10001da2:	408b      	lsls	r3, r1
10001da4:	431a      	orrs	r2, r3
10001da6:	687b      	ldr	r3, [r7, #4]
10001da8:	675a      	str	r2, [r3, #116]	; 0x74
}
10001daa:	46bd      	mov	sp, r7
10001dac:	b002      	add	sp, #8
10001dae:	bd80      	pop	{r7, pc}

10001db0 <__aeabi_uidiv>:
/***********************************************************************************************************************
 * API IMPLEMENTATION - aeabi routines
 **********************************************************************************************************************/
/* This function performs unsigned integer division */
uint32_t __aeabi_uidiv(uint32_t dividend, uint32_t divisor)
{
10001db0:	b580      	push	{r7, lr}
10001db2:	b088      	sub	sp, #32
10001db4:	af00      	add	r7, sp, #0
10001db6:	6078      	str	r0, [r7, #4]
10001db8:	6039      	str	r1, [r7, #0]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10001dba:	f3ef 8310 	mrs	r3, PRIMASK
10001dbe:	617b      	str	r3, [r7, #20]
  return(result);
10001dc0:	697b      	ldr	r3, [r7, #20]
 * API IMPLEMENTATION - Utility functions
 ********************************************************************************************************************/
__attribute__((always_inline)) __STATIC_INLINE uint32_t critical_section_enter(void)
{
  uint32_t status;
  status = __get_PRIMASK();
10001dc2:	613b      	str	r3, [r7, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001dc4:	b672      	cpsid	i
  __disable_irq ();
  return status;
10001dc6:	693b      	ldr	r3, [r7, #16]
/* This function performs unsigned integer division */
uint32_t __aeabi_uidiv(uint32_t dividend, uint32_t divisor)
{
  uint32_t result;
  uint32_t ics;
  ics = critical_section_enter();
10001dc8:	61fb      	str	r3, [r7, #28]

  MATH->DIVCON  = XMC_MATH_UNSIGNED_DIVISION;
10001dca:	4b0c      	ldr	r3, [pc, #48]	; (10001dfc <__aeabi_uidiv+0x4c>)
10001dcc:	2204      	movs	r2, #4
10001dce:	635a      	str	r2, [r3, #52]	; 0x34
  MATH->DVD     = dividend;
10001dd0:	4b0a      	ldr	r3, [pc, #40]	; (10001dfc <__aeabi_uidiv+0x4c>)
10001dd2:	687a      	ldr	r2, [r7, #4]
10001dd4:	621a      	str	r2, [r3, #32]
  MATH->DVS     = divisor;
10001dd6:	4b09      	ldr	r3, [pc, #36]	; (10001dfc <__aeabi_uidiv+0x4c>)
10001dd8:	683a      	ldr	r2, [r7, #0]
10001dda:	625a      	str	r2, [r3, #36]	; 0x24

  result = MATH->QUOT;
10001ddc:	4b07      	ldr	r3, [pc, #28]	; (10001dfc <__aeabi_uidiv+0x4c>)
10001dde:	6a9b      	ldr	r3, [r3, #40]	; 0x28
10001de0:	61bb      	str	r3, [r7, #24]
10001de2:	69fb      	ldr	r3, [r7, #28]
10001de4:	60fb      	str	r3, [r7, #12]
10001de6:	68fb      	ldr	r3, [r7, #12]
10001de8:	60bb      	str	r3, [r7, #8]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10001dea:	68bb      	ldr	r3, [r7, #8]
10001dec:	f383 8810 	msr	PRIMASK, r3

  critical_section_exit(ics);

  return result;
10001df0:	69bb      	ldr	r3, [r7, #24]
}
10001df2:	1c18      	adds	r0, r3, #0
10001df4:	46bd      	mov	sp, r7
10001df6:	b008      	add	sp, #32
10001df8:	bd80      	pop	{r7, pc}
10001dfa:	46c0      	nop			; (mov r8, r8)
10001dfc:	40030000 	.word	0x40030000

10001e00 <__aeabi_idiv>:

/* This function performs signed integer division */
int32_t __aeabi_idiv(int32_t dividend, int32_t divisor)
{
10001e00:	b580      	push	{r7, lr}
10001e02:	b088      	sub	sp, #32
10001e04:	af00      	add	r7, sp, #0
10001e06:	6078      	str	r0, [r7, #4]
10001e08:	6039      	str	r1, [r7, #0]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10001e0a:	f3ef 8310 	mrs	r3, PRIMASK
10001e0e:	617b      	str	r3, [r7, #20]
  return(result);
10001e10:	697b      	ldr	r3, [r7, #20]
 * API IMPLEMENTATION - Utility functions
 ********************************************************************************************************************/
__attribute__((always_inline)) __STATIC_INLINE uint32_t critical_section_enter(void)
{
  uint32_t status;
  status = __get_PRIMASK();
10001e12:	613b      	str	r3, [r7, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001e14:	b672      	cpsid	i
  __disable_irq ();
  return status;
10001e16:	693b      	ldr	r3, [r7, #16]
/* This function performs signed integer division */
int32_t __aeabi_idiv(int32_t dividend, int32_t divisor)
{
  uint32_t result;
  uint32_t ics;
  ics = critical_section_enter();
10001e18:	61fb      	str	r3, [r7, #28]

  MATH->DIVCON  = XMC_MATH_SIGNED_DIVISION;
10001e1a:	4b0c      	ldr	r3, [pc, #48]	; (10001e4c <__aeabi_idiv+0x4c>)
10001e1c:	2200      	movs	r2, #0
10001e1e:	635a      	str	r2, [r3, #52]	; 0x34
  MATH->DVD     = dividend;
10001e20:	4b0a      	ldr	r3, [pc, #40]	; (10001e4c <__aeabi_idiv+0x4c>)
10001e22:	687a      	ldr	r2, [r7, #4]
10001e24:	621a      	str	r2, [r3, #32]
  MATH->DVS     = divisor;
10001e26:	4b09      	ldr	r3, [pc, #36]	; (10001e4c <__aeabi_idiv+0x4c>)
10001e28:	683a      	ldr	r2, [r7, #0]
10001e2a:	625a      	str	r2, [r3, #36]	; 0x24

  result = MATH->QUOT;
10001e2c:	4b07      	ldr	r3, [pc, #28]	; (10001e4c <__aeabi_idiv+0x4c>)
10001e2e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
10001e30:	61bb      	str	r3, [r7, #24]
10001e32:	69fb      	ldr	r3, [r7, #28]
10001e34:	60fb      	str	r3, [r7, #12]
10001e36:	68fb      	ldr	r3, [r7, #12]
10001e38:	60bb      	str	r3, [r7, #8]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10001e3a:	68bb      	ldr	r3, [r7, #8]
10001e3c:	f383 8810 	msr	PRIMASK, r3

  critical_section_exit(ics);

  return result;
10001e40:	69bb      	ldr	r3, [r7, #24]
}
10001e42:	1c18      	adds	r0, r3, #0
10001e44:	46bd      	mov	sp, r7
10001e46:	b008      	add	sp, #32
10001e48:	bd80      	pop	{r7, pc}
10001e4a:	46c0      	nop			; (mov r8, r8)
10001e4c:	40030000 	.word	0x40030000

10001e50 <__aeabi_uidivmod>:

/* This function performs unsigned integer division modulo */
uint64_t __aeabi_uidivmod(uint32_t dividend, uint32_t divisor)
{
10001e50:	b5f0      	push	{r4, r5, r6, r7, lr}
10001e52:	b08d      	sub	sp, #52	; 0x34
10001e54:	af00      	add	r7, sp, #0
10001e56:	6078      	str	r0, [r7, #4]
10001e58:	6039      	str	r1, [r7, #0]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10001e5a:	f3ef 8210 	mrs	r2, PRIMASK
10001e5e:	617a      	str	r2, [r7, #20]
  return(result);
10001e60:	697a      	ldr	r2, [r7, #20]
 * API IMPLEMENTATION - Utility functions
 ********************************************************************************************************************/
__attribute__((always_inline)) __STATIC_INLINE uint32_t critical_section_enter(void)
{
  uint32_t status;
  status = __get_PRIMASK();
10001e62:	613a      	str	r2, [r7, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001e64:	b672      	cpsid	i
  __disable_irq ();
  return status;
10001e66:	693a      	ldr	r2, [r7, #16]
uint64_t __aeabi_uidivmod(uint32_t dividend, uint32_t divisor)
{
  uint64_t remainder;
  uint64_t quot;
  uint32_t ics;
  ics = critical_section_enter();
10001e68:	62fa      	str	r2, [r7, #44]	; 0x2c

  MATH->DIVCON  = XMC_MATH_UNSIGNED_DIVISION;
10001e6a:	4a15      	ldr	r2, [pc, #84]	; (10001ec0 <__aeabi_uidivmod+0x70>)
10001e6c:	2104      	movs	r1, #4
10001e6e:	6351      	str	r1, [r2, #52]	; 0x34
  MATH->DVD     = dividend;
10001e70:	4a13      	ldr	r2, [pc, #76]	; (10001ec0 <__aeabi_uidivmod+0x70>)
10001e72:	6879      	ldr	r1, [r7, #4]
10001e74:	6211      	str	r1, [r2, #32]
  MATH->DVS     = divisor;
10001e76:	4a12      	ldr	r2, [pc, #72]	; (10001ec0 <__aeabi_uidivmod+0x70>)
10001e78:	6839      	ldr	r1, [r7, #0]
10001e7a:	6251      	str	r1, [r2, #36]	; 0x24

  remainder = (uint64_t)MATH->RMD;
10001e7c:	4a10      	ldr	r2, [pc, #64]	; (10001ec0 <__aeabi_uidivmod+0x70>)
10001e7e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
10001e80:	623a      	str	r2, [r7, #32]
10001e82:	2200      	movs	r2, #0
10001e84:	627a      	str	r2, [r7, #36]	; 0x24
  quot = (uint64_t)MATH->QUOT;
10001e86:	4a0e      	ldr	r2, [pc, #56]	; (10001ec0 <__aeabi_uidivmod+0x70>)
10001e88:	6a92      	ldr	r2, [r2, #40]	; 0x28
10001e8a:	61ba      	str	r2, [r7, #24]
10001e8c:	2200      	movs	r2, #0
10001e8e:	61fa      	str	r2, [r7, #28]
10001e90:	6afa      	ldr	r2, [r7, #44]	; 0x2c
10001e92:	60fa      	str	r2, [r7, #12]
10001e94:	68fa      	ldr	r2, [r7, #12]
10001e96:	60ba      	str	r2, [r7, #8]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10001e98:	68ba      	ldr	r2, [r7, #8]
10001e9a:	f382 8810 	msr	PRIMASK, r2

  critical_section_exit(ics);

  return ((remainder << 32) | quot);
10001e9e:	6a3a      	ldr	r2, [r7, #32]
10001ea0:	0014      	movs	r4, r2
10001ea2:	2200      	movs	r2, #0
10001ea4:	1c13      	adds	r3, r2, #0
10001ea6:	69ba      	ldr	r2, [r7, #24]
10001ea8:	431a      	orrs	r2, r3
10001eaa:	1c15      	adds	r5, r2, #0
10001eac:	69fa      	ldr	r2, [r7, #28]
10001eae:	4322      	orrs	r2, r4
10001eb0:	1c16      	adds	r6, r2, #0
10001eb2:	1c2b      	adds	r3, r5, #0
10001eb4:	1c34      	adds	r4, r6, #0
}
10001eb6:	1c18      	adds	r0, r3, #0
10001eb8:	1c21      	adds	r1, r4, #0
10001eba:	46bd      	mov	sp, r7
10001ebc:	b00d      	add	sp, #52	; 0x34
10001ebe:	bdf0      	pop	{r4, r5, r6, r7, pc}
10001ec0:	40030000 	.word	0x40030000

10001ec4 <XMC_SPI_CH_InitEx>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* Initializes the selected SPI channel with the config structure. */
void XMC_SPI_CH_InitEx(XMC_USIC_CH_t *const channel, const XMC_SPI_CH_CONFIG_t *const config, bool init_brg)
{
10001ec4:	b580      	push	{r7, lr}
10001ec6:	b084      	sub	sp, #16
10001ec8:	af00      	add	r7, sp, #0
10001eca:	60f8      	str	r0, [r7, #12]
10001ecc:	60b9      	str	r1, [r7, #8]
10001ece:	1dfb      	adds	r3, r7, #7
10001ed0:	701a      	strb	r2, [r3, #0]
  XMC_USIC_CH_Enable(channel);
10001ed2:	68fb      	ldr	r3, [r7, #12]
10001ed4:	1c18      	adds	r0, r3, #0
10001ed6:	f000 f967 	bl	100021a8 <XMC_USIC_CH_Enable>

  if ((config->bus_mode == XMC_SPI_CH_BUS_MODE_MASTER) && init_brg)
10001eda:	68bb      	ldr	r3, [r7, #8]
10001edc:	795b      	ldrb	r3, [r3, #5]
10001ede:	2b00      	cmp	r3, #0
10001ee0:	d119      	bne.n	10001f16 <XMC_SPI_CH_InitEx+0x52>
10001ee2:	1dfb      	adds	r3, r7, #7
10001ee4:	781b      	ldrb	r3, [r3, #0]
10001ee6:	2b00      	cmp	r3, #0
10001ee8:	d015      	beq.n	10001f16 <XMC_SPI_CH_InitEx+0x52>
  {
    /* Configure baud rate */
    if (config->normal_divider_mode)
10001eea:	68bb      	ldr	r3, [r7, #8]
10001eec:	791b      	ldrb	r3, [r3, #4]
10001eee:	2b00      	cmp	r3, #0
10001ef0:	d009      	beq.n	10001f06 <XMC_SPI_CH_InitEx+0x42>
    {
      /* Normal divider mode */
      (void)XMC_USIC_CH_SetBaudrateEx(channel, config->baudrate, XMC_SPI_CH_OVERSAMPLING);
10001ef2:	68bb      	ldr	r3, [r7, #8]
10001ef4:	681b      	ldr	r3, [r3, #0]
10001ef6:	1c1a      	adds	r2, r3, #0
10001ef8:	68fb      	ldr	r3, [r7, #12]
10001efa:	1c18      	adds	r0, r3, #0
10001efc:	1c11      	adds	r1, r2, #0
10001efe:	2202      	movs	r2, #2
10001f00:	f000 fa08 	bl	10002314 <XMC_USIC_CH_SetBaudrateEx>
10001f04:	e007      	b.n	10001f16 <XMC_SPI_CH_InitEx+0x52>
    }
    else
    {
      /* Fractional divider mode */
      (void)XMC_USIC_CH_SetBaudrate(channel, config->baudrate, XMC_SPI_CH_OVERSAMPLING);
10001f06:	68bb      	ldr	r3, [r7, #8]
10001f08:	681b      	ldr	r3, [r3, #0]
10001f0a:	68fa      	ldr	r2, [r7, #12]
10001f0c:	1c10      	adds	r0, r2, #0
10001f0e:	1c19      	adds	r1, r3, #0
10001f10:	2202      	movs	r2, #2
10001f12:	f000 f985 	bl	10002220 <XMC_USIC_CH_SetBaudrate>
  }

  /* Configuration of USIC Shift Control */
  /* Transmission Mode (TRM) = 1  */
  /* Passive Data Level (PDL) = 1 */
  channel->SCTR = USIC_CH_SCTR_PDL_Msk |
10001f16:	68fb      	ldr	r3, [r7, #12]
10001f18:	4a0e      	ldr	r2, [pc, #56]	; (10001f54 <XMC_SPI_CH_InitEx+0x90>)
10001f1a:	635a      	str	r2, [r3, #52]	; 0x34
                  (0x7UL << USIC_CH_SCTR_WLE_Pos);

  /* Configuration of USIC Transmit Control/Status Register */
  /* TBUF Data Enable (TDEN) = 1 */
  /* TBUF Data Single Shot Mode (TDSSM) = 1 */
  channel->TCSR = (uint32_t)(USIC_CH_TCSR_HPCMD_Msk |
10001f1c:	68fb      	ldr	r3, [r7, #12]
10001f1e:	22a2      	movs	r2, #162	; 0xa2
10001f20:	00d2      	lsls	r2, r2, #3
10001f22:	639a      	str	r2, [r3, #56]	; 0x38
                             (0x01UL  << USIC_CH_TCSR_TDEN_Pos) |
                             USIC_CH_TCSR_TDSSM_Msk);

  if (config->bus_mode == XMC_SPI_CH_BUS_MODE_MASTER)
10001f24:	68bb      	ldr	r3, [r7, #8]
10001f26:	795b      	ldrb	r3, [r3, #5]
10001f28:	2b00      	cmp	r3, #0
10001f2a:	d107      	bne.n	10001f3c <XMC_SPI_CH_InitEx+0x78>
  {
    /* Configuration of Protocol Control Register */
    channel->PCR_SSCMode = (uint32_t)(USIC_CH_PCR_SSCMode_MSLSEN_Msk |
                                      USIC_CH_PCR_SSCMode_SELCTR_Msk |
                                      (uint32_t)config->selo_inversion |
10001f2c:	68bb      	ldr	r3, [r7, #8]
10001f2e:	799b      	ldrb	r3, [r3, #6]
                             USIC_CH_TCSR_TDSSM_Msk);

  if (config->bus_mode == XMC_SPI_CH_BUS_MODE_MASTER)
  {
    /* Configuration of Protocol Control Register */
    channel->PCR_SSCMode = (uint32_t)(USIC_CH_PCR_SSCMode_MSLSEN_Msk |
10001f30:	220b      	movs	r2, #11
10001f32:	4313      	orrs	r3, r2
10001f34:	b2db      	uxtb	r3, r3
10001f36:	1c1a      	adds	r2, r3, #0
10001f38:	68fb      	ldr	r3, [r7, #12]
10001f3a:	63da      	str	r2, [r3, #60]	; 0x3c
                                      (uint32_t)config->selo_inversion |
                                      USIC_CH_PCR_SSCMode_FEM_Msk);
  }

  /* Clear protocol status */
  channel->PSCR = 0xFFFFFFFFUL;
10001f3c:	68fb      	ldr	r3, [r7, #12]
10001f3e:	2201      	movs	r2, #1
10001f40:	4252      	negs	r2, r2
10001f42:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Set parity settings */
  channel->CCR = (uint32_t)config->parity_mode;
10001f44:	68bb      	ldr	r3, [r7, #8]
10001f46:	891b      	ldrh	r3, [r3, #8]
10001f48:	1c1a      	adds	r2, r3, #0
10001f4a:	68fb      	ldr	r3, [r7, #12]
10001f4c:	641a      	str	r2, [r3, #64]	; 0x40
}
10001f4e:	46bd      	mov	sp, r7
10001f50:	b004      	add	sp, #16
10001f52:	bd80      	pop	{r7, pc}
10001f54:	073f0102 	.word	0x073f0102

10001f58 <XMC_SPI_CH_EnableSlaveSelect>:
  return (XMC_SPI_CH_STATUS_t)status;
}

/* Enable the selected slave signal by setting (SELO) bits in PCR register. */
void XMC_SPI_CH_EnableSlaveSelect(XMC_USIC_CH_t *const channel, const XMC_SPI_CH_SLAVE_SELECT_t slave)
{
10001f58:	b580      	push	{r7, lr}
10001f5a:	b082      	sub	sp, #8
10001f5c:	af00      	add	r7, sp, #0
10001f5e:	6078      	str	r0, [r7, #4]
10001f60:	6039      	str	r1, [r7, #0]
  /* Configuration of Protocol Control Register */
  channel->PCR_SSCMode &= (uint32_t)~USIC_CH_PCR_SSCMode_SELO_Msk;
10001f62:	687b      	ldr	r3, [r7, #4]
10001f64:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001f66:	4a06      	ldr	r2, [pc, #24]	; (10001f80 <XMC_SPI_CH_EnableSlaveSelect+0x28>)
10001f68:	401a      	ands	r2, r3
10001f6a:	687b      	ldr	r3, [r7, #4]
10001f6c:	63da      	str	r2, [r3, #60]	; 0x3c
  channel->PCR_SSCMode |= (uint32_t)slave;
10001f6e:	687b      	ldr	r3, [r7, #4]
10001f70:	6bda      	ldr	r2, [r3, #60]	; 0x3c
10001f72:	683b      	ldr	r3, [r7, #0]
10001f74:	431a      	orrs	r2, r3
10001f76:	687b      	ldr	r3, [r7, #4]
10001f78:	63da      	str	r2, [r3, #60]	; 0x3c
}
10001f7a:	46bd      	mov	sp, r7
10001f7c:	b002      	add	sp, #8
10001f7e:	bd80      	pop	{r7, pc}
10001f80:	ff00ffff 	.word	0xff00ffff

10001f84 <XMC_SPI_CH_GetReceivedData>:
  }
}

/* Reads the data from the buffers based on the FIFO mode selection. */
uint16_t XMC_SPI_CH_GetReceivedData(XMC_USIC_CH_t *const channel)
{
10001f84:	b580      	push	{r7, lr}
10001f86:	b084      	sub	sp, #16
10001f88:	af00      	add	r7, sp, #0
10001f8a:	6078      	str	r0, [r7, #4]
  uint16_t retval;

  /* Check FIFO size */
  if ((channel->RBCTR & USIC_CH_RBCTR_SIZE_Msk) == 0U)
10001f8c:	687a      	ldr	r2, [r7, #4]
10001f8e:	2386      	movs	r3, #134	; 0x86
10001f90:	005b      	lsls	r3, r3, #1
10001f92:	58d2      	ldr	r2, [r2, r3]
10001f94:	23e0      	movs	r3, #224	; 0xe0
10001f96:	04db      	lsls	r3, r3, #19
10001f98:	4013      	ands	r3, r2
10001f9a:	d105      	bne.n	10001fa8 <XMC_SPI_CH_GetReceivedData+0x24>
  {
    retval = (uint16_t)channel->RBUF;
10001f9c:	687b      	ldr	r3, [r7, #4]
10001f9e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
10001fa0:	230e      	movs	r3, #14
10001fa2:	18fb      	adds	r3, r7, r3
10001fa4:	801a      	strh	r2, [r3, #0]
10001fa6:	e006      	b.n	10001fb6 <XMC_SPI_CH_GetReceivedData+0x32>
  }
  else
  {
    retval = (uint16_t)channel->OUTR;
10001fa8:	687a      	ldr	r2, [r7, #4]
10001faa:	238e      	movs	r3, #142	; 0x8e
10001fac:	005b      	lsls	r3, r3, #1
10001fae:	58d2      	ldr	r2, [r2, r3]
10001fb0:	230e      	movs	r3, #14
10001fb2:	18fb      	adds	r3, r7, r3
10001fb4:	801a      	strh	r2, [r3, #0]
  }

  return retval;
10001fb6:	230e      	movs	r3, #14
10001fb8:	18fb      	adds	r3, r7, r3
10001fba:	881b      	ldrh	r3, [r3, #0]
}
10001fbc:	1c18      	adds	r0, r3, #0
10001fbe:	46bd      	mov	sp, r7
10001fc0:	b004      	add	sp, #16
10001fc2:	bd80      	pop	{r7, pc}

10001fc4 <XMC_SPI_CH_DisableEvent>:
  channel->CCR |= (event & 0x1fc00U);
  channel->PCR_SSCMode |= ((event << 13U) & 0xe000U);
}

void XMC_SPI_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001fc4:	b580      	push	{r7, lr}
10001fc6:	b082      	sub	sp, #8
10001fc8:	af00      	add	r7, sp, #0
10001fca:	6078      	str	r0, [r7, #4]
10001fcc:	6039      	str	r1, [r7, #0]
  channel->CCR &= (uint32_t)~(event & 0x1fc00U);
10001fce:	687b      	ldr	r3, [r7, #4]
10001fd0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10001fd2:	6839      	ldr	r1, [r7, #0]
10001fd4:	22fe      	movs	r2, #254	; 0xfe
10001fd6:	0252      	lsls	r2, r2, #9
10001fd8:	400a      	ands	r2, r1
10001fda:	43d2      	mvns	r2, r2
10001fdc:	401a      	ands	r2, r3
10001fde:	687b      	ldr	r3, [r7, #4]
10001fe0:	641a      	str	r2, [r3, #64]	; 0x40
  channel->PCR_SSCMode &= (uint32_t)~((event << 13U) & 0xe000U);
10001fe2:	687b      	ldr	r3, [r7, #4]
10001fe4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001fe6:	683a      	ldr	r2, [r7, #0]
10001fe8:	0352      	lsls	r2, r2, #13
10001fea:	0412      	lsls	r2, r2, #16
10001fec:	0c12      	lsrs	r2, r2, #16
10001fee:	43d2      	mvns	r2, r2
10001ff0:	401a      	ands	r2, r3
10001ff2:	687b      	ldr	r3, [r7, #4]
10001ff4:	63da      	str	r2, [r3, #60]	; 0x3c
}
10001ff6:	46bd      	mov	sp, r7
10001ff8:	b002      	add	sp, #8
10001ffa:	bd80      	pop	{r7, pc}

10001ffc <XMC_USIC_CH_GetTransmitBufferStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
10001ffc:	b580      	push	{r7, lr}
10001ffe:	b082      	sub	sp, #8
10002000:	af00      	add	r7, sp, #0
10002002:	6078      	str	r0, [r7, #4]
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
10002004:	687b      	ldr	r3, [r7, #4]
10002006:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10002008:	b2db      	uxtb	r3, r3
1000200a:	227f      	movs	r2, #127	; 0x7f
1000200c:	4393      	bics	r3, r2
1000200e:	b2db      	uxtb	r3, r3
}
10002010:	1c18      	adds	r0, r3, #0
10002012:	46bd      	mov	sp, r7
10002014:	b002      	add	sp, #8
10002016:	bd80      	pop	{r7, pc}

10002018 <XMC_UART_CH_ClearStatusFlag>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_DisableEvent(),  XMC_UART_CH_GetStatusFlag()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, const uint32_t flag)
{
10002018:	b580      	push	{r7, lr}
1000201a:	b082      	sub	sp, #8
1000201c:	af00      	add	r7, sp, #0
1000201e:	6078      	str	r0, [r7, #4]
10002020:	6039      	str	r1, [r7, #0]
  channel->PSCR = flag;
10002022:	687b      	ldr	r3, [r7, #4]
10002024:	683a      	ldr	r2, [r7, #0]
10002026:	64da      	str	r2, [r3, #76]	; 0x4c
}
10002028:	46bd      	mov	sp, r7
1000202a:	b002      	add	sp, #8
1000202c:	bd80      	pop	{r7, pc}
1000202e:	46c0      	nop			; (mov r8, r8)

10002030 <XMC_UART_CH_InitEx>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 *********************************************************************************************************************/

void XMC_UART_CH_InitEx(XMC_USIC_CH_t *channel, const XMC_UART_CH_CONFIG_t *const config, bool init_brg)
{
10002030:	b580      	push	{r7, lr}
10002032:	b086      	sub	sp, #24
10002034:	af00      	add	r7, sp, #0
10002036:	60f8      	str	r0, [r7, #12]
10002038:	60b9      	str	r1, [r7, #8]
1000203a:	1dfb      	adds	r3, r7, #7
1000203c:	701a      	strb	r2, [r3, #0]
  uint32_t oversampling = XMC_UART_CH_OVERSAMPLING;
1000203e:	2310      	movs	r3, #16
10002040:	617b      	str	r3, [r7, #20]

  /* USIC channel switched on*/
  XMC_USIC_CH_Enable(channel);
10002042:	68fb      	ldr	r3, [r7, #12]
10002044:	1c18      	adds	r0, r3, #0
10002046:	f000 f8af 	bl	100021a8 <XMC_USIC_CH_Enable>

  if (config->oversampling != 0U)
1000204a:	68bb      	ldr	r3, [r7, #8]
1000204c:	7a1b      	ldrb	r3, [r3, #8]
1000204e:	2b00      	cmp	r3, #0
10002050:	d002      	beq.n	10002058 <XMC_UART_CH_InitEx+0x28>
  {
    oversampling = (uint32_t)config->oversampling;
10002052:	68bb      	ldr	r3, [r7, #8]
10002054:	7a1b      	ldrb	r3, [r3, #8]
10002056:	617b      	str	r3, [r7, #20]
  }

  if (init_brg)
10002058:	1dfb      	adds	r3, r7, #7
1000205a:	781b      	ldrb	r3, [r3, #0]
1000205c:	2b00      	cmp	r3, #0
1000205e:	d016      	beq.n	1000208e <XMC_UART_CH_InitEx+0x5e>
  {
    /* Configure baud rate */
    if (config->normal_divider_mode)
10002060:	68bb      	ldr	r3, [r7, #8]
10002062:	791b      	ldrb	r3, [r3, #4]
10002064:	2b00      	cmp	r3, #0
10002066:	d009      	beq.n	1000207c <XMC_UART_CH_InitEx+0x4c>
    {
      /* Normal divider mode */
      (void)XMC_USIC_CH_SetBaudrateEx(channel, config->baudrate, oversampling);
10002068:	68bb      	ldr	r3, [r7, #8]
1000206a:	681b      	ldr	r3, [r3, #0]
1000206c:	1c19      	adds	r1, r3, #0
1000206e:	697b      	ldr	r3, [r7, #20]
10002070:	68fa      	ldr	r2, [r7, #12]
10002072:	1c10      	adds	r0, r2, #0
10002074:	1c1a      	adds	r2, r3, #0
10002076:	f000 f94d 	bl	10002314 <XMC_USIC_CH_SetBaudrateEx>
1000207a:	e008      	b.n	1000208e <XMC_UART_CH_InitEx+0x5e>
    }
    else
    {
      /* Fractional divider mode */
      (void)XMC_USIC_CH_SetBaudrate(channel, config->baudrate, oversampling);
1000207c:	68bb      	ldr	r3, [r7, #8]
1000207e:	681a      	ldr	r2, [r3, #0]
10002080:	68f9      	ldr	r1, [r7, #12]
10002082:	697b      	ldr	r3, [r7, #20]
10002084:	1c08      	adds	r0, r1, #0
10002086:	1c11      	adds	r1, r2, #0
10002088:	1c1a      	adds	r2, r3, #0
1000208a:	f000 f8c9 	bl	10002220 <XMC_USIC_CH_SetBaudrate>
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
1000208e:	68bb      	ldr	r3, [r7, #8]
10002090:	79db      	ldrb	r3, [r3, #7]
10002092:	3b01      	subs	r3, #1
10002094:	005a      	lsls	r2, r3, #1
                                    (((oversampling >> 1UL) + 1UL) << USIC_CH_PCR_ASCMode_SP_Pos) |
10002096:	697b      	ldr	r3, [r7, #20]
10002098:	085b      	lsrs	r3, r3, #1
1000209a:	3301      	adds	r3, #1
1000209c:	021b      	lsls	r3, r3, #8
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
1000209e:	4313      	orrs	r3, r2
100020a0:	4a19      	ldr	r2, [pc, #100]	; (10002108 <XMC_UART_CH_InitEx+0xd8>)
100020a2:	431a      	orrs	r2, r3
100020a4:	68fb      	ldr	r3, [r7, #12]
100020a6:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Set passive data level, high
     Set word length. Data bits - 1
     If frame length is > 0, frame_lemgth-1; else, FLE = WLE (Data bits - 1)
     Transmission Mode: The shift control signal is considered active if it
     is at 1-level. This is the setting to be programmed to allow data transfers */
  channel->SCTR = (uint32_t)((((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_WLE_Pos) |
100020a8:	68bb      	ldr	r3, [r7, #8]
100020aa:	795b      	ldrb	r3, [r3, #5]
100020ac:	3b01      	subs	r3, #1
100020ae:	061b      	lsls	r3, r3, #24
100020b0:	2281      	movs	r2, #129	; 0x81
100020b2:	0052      	lsls	r2, r2, #1
100020b4:	431a      	orrs	r2, r3
100020b6:	68fb      	ldr	r3, [r7, #12]
100020b8:	635a      	str	r2, [r3, #52]	; 0x34
                             ((0x1UL << USIC_CH_SCTR_TRM_Pos) | USIC_CH_SCTR_PDL_Msk));

  if (config->frame_length != 0U)
100020ba:	68bb      	ldr	r3, [r7, #8]
100020bc:	799b      	ldrb	r3, [r3, #6]
100020be:	2b00      	cmp	r3, #0
100020c0:	d009      	beq.n	100020d6 <XMC_UART_CH_InitEx+0xa6>
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->frame_length - 1UL) << USIC_CH_SCTR_FLE_Pos);
100020c2:	68fb      	ldr	r3, [r7, #12]
100020c4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
100020c6:	68bb      	ldr	r3, [r7, #8]
100020c8:	799b      	ldrb	r3, [r3, #6]
100020ca:	3b01      	subs	r3, #1
100020cc:	041b      	lsls	r3, r3, #16
100020ce:	431a      	orrs	r2, r3
100020d0:	68fb      	ldr	r3, [r7, #12]
100020d2:	635a      	str	r2, [r3, #52]	; 0x34
100020d4:	e008      	b.n	100020e8 <XMC_UART_CH_InitEx+0xb8>
  }
  else
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_FLE_Pos);
100020d6:	68fb      	ldr	r3, [r7, #12]
100020d8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
100020da:	68bb      	ldr	r3, [r7, #8]
100020dc:	795b      	ldrb	r3, [r3, #5]
100020de:	3b01      	subs	r3, #1
100020e0:	041b      	lsls	r3, r3, #16
100020e2:	431a      	orrs	r2, r3
100020e4:	68fb      	ldr	r3, [r7, #12]
100020e6:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Enable transfer buffer */
  channel->TCSR = (0x1UL << USIC_CH_TCSR_TDEN_Pos) |
100020e8:	68fb      	ldr	r3, [r7, #12]
100020ea:	22a0      	movs	r2, #160	; 0xa0
100020ec:	00d2      	lsls	r2, r2, #3
100020ee:	639a      	str	r2, [r3, #56]	; 0x38
                  USIC_CH_TCSR_TDSSM_Msk;

  /* Clear protocol status */
  channel->PSCR = 0xFFFFFFFFUL;
100020f0:	68fb      	ldr	r3, [r7, #12]
100020f2:	2201      	movs	r2, #1
100020f4:	4252      	negs	r2, r2
100020f6:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Set parity settings */
  channel->CCR = (uint32_t)config->parity_mode;
100020f8:	68bb      	ldr	r3, [r7, #8]
100020fa:	895b      	ldrh	r3, [r3, #10]
100020fc:	1c1a      	adds	r2, r3, #0
100020fe:	68fb      	ldr	r3, [r7, #12]
10002100:	641a      	str	r2, [r3, #64]	; 0x40
}
10002102:	46bd      	mov	sp, r7
10002104:	b006      	add	sp, #24
10002106:	bd80      	pop	{r7, pc}
10002108:	00030001 	.word	0x00030001

1000210c <XMC_UART_CH_Transmit>:

  return (XMC_UART_CH_STATUS_t)status;
}

void XMC_UART_CH_Transmit(XMC_USIC_CH_t *const channel, const uint16_t data)
{
1000210c:	b580      	push	{r7, lr}
1000210e:	b082      	sub	sp, #8
10002110:	af00      	add	r7, sp, #0
10002112:	6078      	str	r0, [r7, #4]
10002114:	1c0a      	adds	r2, r1, #0
10002116:	1cbb      	adds	r3, r7, #2
10002118:	801a      	strh	r2, [r3, #0]
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0UL)
1000211a:	687a      	ldr	r2, [r7, #4]
1000211c:	2384      	movs	r3, #132	; 0x84
1000211e:	005b      	lsls	r3, r3, #1
10002120:	58d2      	ldr	r2, [r2, r3]
10002122:	23e0      	movs	r3, #224	; 0xe0
10002124:	04db      	lsls	r3, r3, #19
10002126:	4013      	ands	r3, r2
10002128:	d114      	bne.n	10002154 <XMC_UART_CH_Transmit+0x48>
  {
    /* Wait till the Transmit Buffer is free for transmission */
    while (XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
1000212a:	46c0      	nop			; (mov r8, r8)
1000212c:	687b      	ldr	r3, [r7, #4]
1000212e:	1c18      	adds	r0, r3, #0
10002130:	f7ff ff64 	bl	10001ffc <XMC_USIC_CH_GetTransmitBufferStatus>
10002134:	1e03      	subs	r3, r0, #0
10002136:	2b80      	cmp	r3, #128	; 0x80
10002138:	d0f8      	beq.n	1000212c <XMC_UART_CH_Transmit+0x20>
    {
    }

    /* Clear the Transmit Buffer indication flag */
    XMC_UART_CH_ClearStatusFlag(channel, (uint32_t)XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);
1000213a:	687a      	ldr	r2, [r7, #4]
1000213c:	2380      	movs	r3, #128	; 0x80
1000213e:	019b      	lsls	r3, r3, #6
10002140:	1c10      	adds	r0, r2, #0
10002142:	1c19      	adds	r1, r3, #0
10002144:	f7ff ff68 	bl	10002018 <XMC_UART_CH_ClearStatusFlag>

    /*Transmit data */
    channel->TBUF[0U] = data;
10002148:	1cbb      	adds	r3, r7, #2
1000214a:	881a      	ldrh	r2, [r3, #0]
1000214c:	687b      	ldr	r3, [r7, #4]
1000214e:	2180      	movs	r1, #128	; 0x80
10002150:	505a      	str	r2, [r3, r1]
10002152:	e005      	b.n	10002160 <XMC_UART_CH_Transmit+0x54>
  }
  else
  {
    channel->IN[0U] = data;
10002154:	1cbb      	adds	r3, r7, #2
10002156:	8819      	ldrh	r1, [r3, #0]
10002158:	687a      	ldr	r2, [r7, #4]
1000215a:	23c0      	movs	r3, #192	; 0xc0
1000215c:	005b      	lsls	r3, r3, #1
1000215e:	50d1      	str	r1, [r2, r3]
  }
}
10002160:	46bd      	mov	sp, r7
10002162:	b002      	add	sp, #8
10002164:	bd80      	pop	{r7, pc}
10002166:	46c0      	nop			; (mov r8, r8)

10002168 <XMC_UART_CH_GetReceivedData>:

uint16_t XMC_UART_CH_GetReceivedData(XMC_USIC_CH_t *const channel)
{
10002168:	b580      	push	{r7, lr}
1000216a:	b084      	sub	sp, #16
1000216c:	af00      	add	r7, sp, #0
1000216e:	6078      	str	r0, [r7, #4]
  uint16_t retval;

  /* Check FIFO size */
  if ((channel->RBCTR & USIC_CH_RBCTR_SIZE_Msk) == 0U)
10002170:	687a      	ldr	r2, [r7, #4]
10002172:	2386      	movs	r3, #134	; 0x86
10002174:	005b      	lsls	r3, r3, #1
10002176:	58d2      	ldr	r2, [r2, r3]
10002178:	23e0      	movs	r3, #224	; 0xe0
1000217a:	04db      	lsls	r3, r3, #19
1000217c:	4013      	ands	r3, r2
1000217e:	d105      	bne.n	1000218c <XMC_UART_CH_GetReceivedData+0x24>
  {
    retval = (uint16_t)channel->RBUF;
10002180:	687b      	ldr	r3, [r7, #4]
10002182:	6d5a      	ldr	r2, [r3, #84]	; 0x54
10002184:	230e      	movs	r3, #14
10002186:	18fb      	adds	r3, r7, r3
10002188:	801a      	strh	r2, [r3, #0]
1000218a:	e006      	b.n	1000219a <XMC_UART_CH_GetReceivedData+0x32>
  }
  else
  {
    retval = (uint16_t)channel->OUTR;
1000218c:	687a      	ldr	r2, [r7, #4]
1000218e:	238e      	movs	r3, #142	; 0x8e
10002190:	005b      	lsls	r3, r3, #1
10002192:	58d2      	ldr	r2, [r2, r3]
10002194:	230e      	movs	r3, #14
10002196:	18fb      	adds	r3, r7, r3
10002198:	801a      	strh	r2, [r3, #0]
  }

  return retval;
1000219a:	230e      	movs	r3, #14
1000219c:	18fb      	adds	r3, r7, r3
1000219e:	881b      	ldrh	r3, [r3, #0]
}
100021a0:	1c18      	adds	r0, r3, #0
100021a2:	46bd      	mov	sp, r7
100021a4:	b004      	add	sp, #16
100021a6:	bd80      	pop	{r7, pc}

100021a8 <XMC_USIC_CH_Enable>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel)
{
100021a8:	b580      	push	{r7, lr}
100021aa:	b082      	sub	sp, #8
100021ac:	af00      	add	r7, sp, #0
100021ae:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_USIC_CH_Enable: channel not valid", XMC_USIC_IsChannelValid(channel));

  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
100021b0:	687a      	ldr	r2, [r7, #4]
100021b2:	2390      	movs	r3, #144	; 0x90
100021b4:	05db      	lsls	r3, r3, #23
100021b6:	429a      	cmp	r2, r3
100021b8:	d003      	beq.n	100021c2 <XMC_USIC_CH_Enable+0x1a>
100021ba:	687b      	ldr	r3, [r7, #4]
100021bc:	4a13      	ldr	r2, [pc, #76]	; (1000220c <XMC_USIC_CH_Enable+0x64>)
100021be:	4293      	cmp	r3, r2
100021c0:	d104      	bne.n	100021cc <XMC_USIC_CH_Enable+0x24>
  {
    XMC_USIC_Enable(XMC_USIC0);
100021c2:	4b13      	ldr	r3, [pc, #76]	; (10002210 <XMC_USIC_CH_Enable+0x68>)
100021c4:	1c18      	adds	r0, r3, #0
100021c6:	f000 fa0f 	bl	100025e8 <XMC_USIC_Enable>
100021ca:	e00b      	b.n	100021e4 <XMC_USIC_CH_Enable+0x3c>
  }
#if defined(USIC1)
  else if ((channel == XMC_USIC1_CH0) || (channel == XMC_USIC1_CH1))
100021cc:	687b      	ldr	r3, [r7, #4]
100021ce:	4a11      	ldr	r2, [pc, #68]	; (10002214 <XMC_USIC_CH_Enable+0x6c>)
100021d0:	4293      	cmp	r3, r2
100021d2:	d003      	beq.n	100021dc <XMC_USIC_CH_Enable+0x34>
100021d4:	687b      	ldr	r3, [r7, #4]
100021d6:	4a10      	ldr	r2, [pc, #64]	; (10002218 <XMC_USIC_CH_Enable+0x70>)
100021d8:	4293      	cmp	r3, r2
100021da:	d103      	bne.n	100021e4 <XMC_USIC_CH_Enable+0x3c>
  {
    XMC_USIC_Enable(XMC_USIC1);
100021dc:	4b0f      	ldr	r3, [pc, #60]	; (1000221c <XMC_USIC_CH_Enable+0x74>)
100021de:	1c18      	adds	r0, r3, #0
100021e0:	f000 fa02 	bl	100025e8 <XMC_USIC_Enable>
  {
    XMC_ASSERT("USIC module not available", 0U/*Always*/);
  }

  /* USIC channel switched on*/
  channel->KSCFG = (USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk);
100021e4:	687b      	ldr	r3, [r7, #4]
100021e6:	2203      	movs	r2, #3
100021e8:	60da      	str	r2, [r3, #12]
  while ((channel->KSCFG & USIC_CH_KSCFG_MODEN_Msk) == 0U)
100021ea:	46c0      	nop			; (mov r8, r8)
100021ec:	687b      	ldr	r3, [r7, #4]
100021ee:	68db      	ldr	r3, [r3, #12]
100021f0:	2201      	movs	r2, #1
100021f2:	4013      	ands	r3, r2
100021f4:	d0fa      	beq.n	100021ec <XMC_USIC_CH_Enable+0x44>
  {
    /* Wait till the channel is enabled */
  }

  /* Set USIC channel in IDLE mode */
  channel->CCR &= (uint32_t)~USIC_CH_CCR_MODE_Msk;
100021f6:	687b      	ldr	r3, [r7, #4]
100021f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100021fa:	220f      	movs	r2, #15
100021fc:	4393      	bics	r3, r2
100021fe:	1c1a      	adds	r2, r3, #0
10002200:	687b      	ldr	r3, [r7, #4]
10002202:	641a      	str	r2, [r3, #64]	; 0x40
}
10002204:	46bd      	mov	sp, r7
10002206:	b002      	add	sp, #8
10002208:	bd80      	pop	{r7, pc}
1000220a:	46c0      	nop			; (mov r8, r8)
1000220c:	48000200 	.word	0x48000200
10002210:	48000008 	.word	0x48000008
10002214:	48004000 	.word	0x48004000
10002218:	48004200 	.word	0x48004200
1000221c:	48004008 	.word	0x48004008

10002220 <XMC_USIC_CH_SetBaudrate>:
{
  channel->KSCFG = (uint32_t)((channel->KSCFG & (~USIC_CH_KSCFG_MODEN_Msk)) | USIC_CH_KSCFG_BPMODEN_Msk);
}

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t oversampling)
{
10002220:	b580      	push	{r7, lr}
10002222:	b08e      	sub	sp, #56	; 0x38
10002224:	af00      	add	r7, sp, #0
10002226:	60f8      	str	r0, [r7, #12]
10002228:	60b9      	str	r1, [r7, #8]
1000222a:	607a      	str	r2, [r7, #4]

  uint32_t pdiv_frac;
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
1000222c:	68bb      	ldr	r3, [r7, #8]
1000222e:	2b63      	cmp	r3, #99	; 0x63
10002230:	d960      	bls.n	100022f4 <XMC_USIC_CH_SetBaudrate+0xd4>
10002232:	687b      	ldr	r3, [r7, #4]
10002234:	2b00      	cmp	r3, #0
10002236:	d05d      	beq.n	100022f4 <XMC_USIC_CH_SetBaudrate+0xd4>
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
10002238:	f7ff fa14 	bl	10001664 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
1000223c:	1c03      	adds	r3, r0, #0
1000223e:	1c18      	adds	r0, r3, #0
10002240:	2164      	movs	r1, #100	; 0x64
10002242:	f7ff fdb5 	bl	10001db0 <__aeabi_uidiv>
10002246:	1c03      	adds	r3, r0, #0
10002248:	623b      	str	r3, [r7, #32]
    rate = rate / 100U;
1000224a:	68bb      	ldr	r3, [r7, #8]
1000224c:	1c18      	adds	r0, r3, #0
1000224e:	2164      	movs	r1, #100	; 0x64
10002250:	f7ff fdae 	bl	10001db0 <__aeabi_uidiv>
10002254:	1c03      	adds	r3, r0, #0
10002256:	60bb      	str	r3, [r7, #8]

    clock_divider_min = 1024U;
10002258:	2380      	movs	r3, #128	; 0x80
1000225a:	00db      	lsls	r3, r3, #3
1000225c:	62fb      	str	r3, [r7, #44]	; 0x2c
    pdiv_int_min = 1U;
1000225e:	2301      	movs	r3, #1
10002260:	62bb      	str	r3, [r7, #40]	; 0x28
    pdiv_frac_min = 0x3ffU;
10002262:	4b2a      	ldr	r3, [pc, #168]	; (1000230c <XMC_USIC_CH_SetBaudrate+0xec>)
10002264:	627b      	str	r3, [r7, #36]	; 0x24

    for (clock_divider = 1024U; clock_divider > 0U; --clock_divider)
10002266:	2380      	movs	r3, #128	; 0x80
10002268:	00db      	lsls	r3, r3, #3
1000226a:	633b      	str	r3, [r7, #48]	; 0x30
1000226c:	e025      	b.n	100022ba <XMC_USIC_CH_SetBaudrate+0x9a>
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
1000226e:	6a3b      	ldr	r3, [r7, #32]
10002270:	6b3a      	ldr	r2, [r7, #48]	; 0x30
10002272:	435a      	muls	r2, r3
10002274:	1c11      	adds	r1, r2, #0
10002276:	68bb      	ldr	r3, [r7, #8]
10002278:	687a      	ldr	r2, [r7, #4]
1000227a:	4353      	muls	r3, r2
1000227c:	1c08      	adds	r0, r1, #0
1000227e:	1c19      	adds	r1, r3, #0
10002280:	f7ff fd96 	bl	10001db0 <__aeabi_uidiv>
10002284:	1c03      	adds	r3, r0, #0
10002286:	61fb      	str	r3, [r7, #28]
      pdiv_int = pdiv >> 10U;
10002288:	69fb      	ldr	r3, [r7, #28]
1000228a:	0a9b      	lsrs	r3, r3, #10
1000228c:	61bb      	str	r3, [r7, #24]
      pdiv_frac = pdiv & 0x3ffU;
1000228e:	69fb      	ldr	r3, [r7, #28]
10002290:	059b      	lsls	r3, r3, #22
10002292:	0d9b      	lsrs	r3, r3, #22
10002294:	617b      	str	r3, [r7, #20]

      if ((pdiv_int <= 1024U) && (pdiv_frac < pdiv_frac_min))
10002296:	69ba      	ldr	r2, [r7, #24]
10002298:	2380      	movs	r3, #128	; 0x80
1000229a:	00db      	lsls	r3, r3, #3
1000229c:	429a      	cmp	r2, r3
1000229e:	d809      	bhi.n	100022b4 <XMC_USIC_CH_SetBaudrate+0x94>
100022a0:	697a      	ldr	r2, [r7, #20]
100022a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
100022a4:	429a      	cmp	r2, r3
100022a6:	d205      	bcs.n	100022b4 <XMC_USIC_CH_SetBaudrate+0x94>
      {
        pdiv_frac_min = pdiv_frac;
100022a8:	697b      	ldr	r3, [r7, #20]
100022aa:	627b      	str	r3, [r7, #36]	; 0x24
        pdiv_int_min = pdiv_int;
100022ac:	69bb      	ldr	r3, [r7, #24]
100022ae:	62bb      	str	r3, [r7, #40]	; 0x28
        clock_divider_min = clock_divider;
100022b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
100022b2:	62fb      	str	r3, [r7, #44]	; 0x2c

    clock_divider_min = 1024U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for (clock_divider = 1024U; clock_divider > 0U; --clock_divider)
100022b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
100022b6:	3b01      	subs	r3, #1
100022b8:	633b      	str	r3, [r7, #48]	; 0x30
100022ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
100022bc:	2b00      	cmp	r3, #0
100022be:	d1d6      	bne.n	1000226e <XMC_USIC_CH_SetBaudrate+0x4e>
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);
100022c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
100022c2:	3b01      	subs	r3, #1
        pdiv_int_min = pdiv_int;
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
100022c4:	2280      	movs	r2, #128	; 0x80
100022c6:	0212      	lsls	r2, r2, #8
100022c8:	431a      	orrs	r2, r3
100022ca:	68fb      	ldr	r3, [r7, #12]
100022cc:	611a      	str	r2, [r3, #16]
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
100022ce:	68fb      	ldr	r3, [r7, #12]
100022d0:	695b      	ldr	r3, [r3, #20]
100022d2:	4a0f      	ldr	r2, [pc, #60]	; (10002310 <XMC_USIC_CH_SetBaudrate+0xf0>)
100022d4:	401a      	ands	r2, r3
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
100022d6:	687b      	ldr	r3, [r7, #4]
100022d8:	3b01      	subs	r3, #1
100022da:	029b      	lsls	r3, r3, #10
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
100022dc:	431a      	orrs	r2, r3
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
100022de:	6abb      	ldr	r3, [r7, #40]	; 0x28
100022e0:	3b01      	subs	r3, #1
100022e2:	041b      	lsls	r3, r3, #16

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
100022e4:	431a      	orrs	r2, r3
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
100022e6:	68fb      	ldr	r3, [r7, #12]
100022e8:	615a      	str	r2, [r3, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);

    status = XMC_USIC_CH_STATUS_OK;
100022ea:	2337      	movs	r3, #55	; 0x37
100022ec:	18fb      	adds	r3, r7, r3
100022ee:	2200      	movs	r2, #0
100022f0:	701a      	strb	r2, [r3, #0]
100022f2:	e003      	b.n	100022fc <XMC_USIC_CH_SetBaudrate+0xdc>
  }
  else
  {
    status = XMC_USIC_CH_STATUS_ERROR;
100022f4:	2337      	movs	r3, #55	; 0x37
100022f6:	18fb      	adds	r3, r7, r3
100022f8:	2201      	movs	r2, #1
100022fa:	701a      	strb	r2, [r3, #0]
  }

  return status;
100022fc:	2337      	movs	r3, #55	; 0x37
100022fe:	18fb      	adds	r3, r7, r3
10002300:	781b      	ldrb	r3, [r3, #0]
}
10002302:	1c18      	adds	r0, r3, #0
10002304:	46bd      	mov	sp, r7
10002306:	b00e      	add	sp, #56	; 0x38
10002308:	bd80      	pop	{r7, pc}
1000230a:	46c0      	nop			; (mov r8, r8)
1000230c:	000003ff 	.word	0x000003ff
10002310:	fc0080ef 	.word	0xfc0080ef

10002314 <XMC_USIC_CH_SetBaudrateEx>:

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrateEx(XMC_USIC_CH_t *const channel, int32_t rate, int32_t oversampling)
{
10002314:	b580      	push	{r7, lr}
10002316:	b08c      	sub	sp, #48	; 0x30
10002318:	af00      	add	r7, sp, #0
1000231a:	60f8      	str	r0, [r7, #12]
1000231c:	60b9      	str	r1, [r7, #8]
1000231e:	607a      	str	r2, [r7, #4]
  int32_t peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
10002320:	f7ff f9a0 	bl	10001664 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
10002324:	1c03      	adds	r3, r0, #0
10002326:	623b      	str	r3, [r7, #32]
  int32_t brg_clock = rate * oversampling;
10002328:	68bb      	ldr	r3, [r7, #8]
1000232a:	687a      	ldr	r2, [r7, #4]
1000232c:	4353      	muls	r3, r2
1000232e:	61fb      	str	r3, [r7, #28]
  int32_t actual_rate_upper;
  int32_t actual_rate_lower;
  uint32_t pdiv = 1;
10002330:	2301      	movs	r3, #1
10002332:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t divider_step;
  XMC_USIC_CH_STATUS_t status;

  if (peripheral_clock > brg_clock)
10002334:	6a3a      	ldr	r2, [r7, #32]
10002336:	69fb      	ldr	r3, [r7, #28]
10002338:	429a      	cmp	r2, r3
1000233a:	dd62      	ble.n	10002402 <XMC_USIC_CH_SetBaudrateEx+0xee>
  {
    divider_step = peripheral_clock / brg_clock; // integer division gets truncated
1000233c:	6a38      	ldr	r0, [r7, #32]
1000233e:	69f9      	ldr	r1, [r7, #28]
10002340:	f7ff fd5e 	bl	10001e00 <__aeabi_idiv>
10002344:	1c03      	adds	r3, r0, #0
10002346:	62bb      	str	r3, [r7, #40]	; 0x28
    while (divider_step >= 1023)
10002348:	e00f      	b.n	1000236a <XMC_USIC_CH_SetBaudrateEx+0x56>
    {
      pdiv++;
1000234a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
1000234c:	3301      	adds	r3, #1
1000234e:	62fb      	str	r3, [r7, #44]	; 0x2c
      brg_clock = rate * oversampling * pdiv;
10002350:	68bb      	ldr	r3, [r7, #8]
10002352:	687a      	ldr	r2, [r7, #4]
10002354:	4353      	muls	r3, r2
10002356:	1c1a      	adds	r2, r3, #0
10002358:	6afb      	ldr	r3, [r7, #44]	; 0x2c
1000235a:	4353      	muls	r3, r2
1000235c:	61fb      	str	r3, [r7, #28]
      divider_step = peripheral_clock / brg_clock; // integer division gets truncated
1000235e:	6a38      	ldr	r0, [r7, #32]
10002360:	69f9      	ldr	r1, [r7, #28]
10002362:	f7ff fd4d 	bl	10001e00 <__aeabi_idiv>
10002366:	1c03      	adds	r3, r0, #0
10002368:	62bb      	str	r3, [r7, #40]	; 0x28
  XMC_USIC_CH_STATUS_t status;

  if (peripheral_clock > brg_clock)
  {
    divider_step = peripheral_clock / brg_clock; // integer division gets truncated
    while (divider_step >= 1023)
1000236a:	6abb      	ldr	r3, [r7, #40]	; 0x28
1000236c:	4a2a      	ldr	r2, [pc, #168]	; (10002418 <XMC_USIC_CH_SetBaudrateEx+0x104>)
1000236e:	4293      	cmp	r3, r2
10002370:	d8eb      	bhi.n	1000234a <XMC_USIC_CH_SetBaudrateEx+0x36>
    {
      pdiv++;
      brg_clock = rate * oversampling * pdiv;
      divider_step = peripheral_clock / brg_clock; // integer division gets truncated
    }
    actual_rate_upper = peripheral_clock / (divider_step * oversampling * pdiv);
10002372:	6a39      	ldr	r1, [r7, #32]
10002374:	687b      	ldr	r3, [r7, #4]
10002376:	6aba      	ldr	r2, [r7, #40]	; 0x28
10002378:	4353      	muls	r3, r2
1000237a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
1000237c:	4353      	muls	r3, r2
1000237e:	1c08      	adds	r0, r1, #0
10002380:	1c19      	adds	r1, r3, #0
10002382:	f7ff fd15 	bl	10001db0 <__aeabi_uidiv>
10002386:	1c03      	adds	r3, r0, #0
10002388:	61bb      	str	r3, [r7, #24]
    actual_rate_lower = peripheral_clock / ((divider_step + 1) * oversampling * pdiv);
1000238a:	6a39      	ldr	r1, [r7, #32]
1000238c:	6abb      	ldr	r3, [r7, #40]	; 0x28
1000238e:	3301      	adds	r3, #1
10002390:	687a      	ldr	r2, [r7, #4]
10002392:	4353      	muls	r3, r2
10002394:	6afa      	ldr	r2, [r7, #44]	; 0x2c
10002396:	4353      	muls	r3, r2
10002398:	1c08      	adds	r0, r1, #0
1000239a:	1c19      	adds	r1, r3, #0
1000239c:	f7ff fd08 	bl	10001db0 <__aeabi_uidiv>
100023a0:	1c03      	adds	r3, r0, #0
100023a2:	617b      	str	r3, [r7, #20]

    // choose better approximation if the peripheral frequency is not a multiple of the baudrate
    if (abs(rate - actual_rate_lower) < abs(rate - actual_rate_upper))
100023a4:	68ba      	ldr	r2, [r7, #8]
100023a6:	697b      	ldr	r3, [r7, #20]
100023a8:	1ad3      	subs	r3, r2, r3
100023aa:	17d9      	asrs	r1, r3, #31
100023ac:	185a      	adds	r2, r3, r1
100023ae:	404a      	eors	r2, r1
100023b0:	68b9      	ldr	r1, [r7, #8]
100023b2:	69bb      	ldr	r3, [r7, #24]
100023b4:	1acb      	subs	r3, r1, r3
100023b6:	17d9      	asrs	r1, r3, #31
100023b8:	185b      	adds	r3, r3, r1
100023ba:	404b      	eors	r3, r1
100023bc:	429a      	cmp	r2, r3
100023be:	da02      	bge.n	100023c6 <XMC_USIC_CH_SetBaudrateEx+0xb2>
    {
      divider_step += 1;
100023c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
100023c2:	3301      	adds	r3, #1
100023c4:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    divider_step = 1024 - divider_step;
100023c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
100023c8:	2280      	movs	r2, #128	; 0x80
100023ca:	00d2      	lsls	r2, r2, #3
100023cc:	1ad3      	subs	r3, r2, r3
100023ce:	62bb      	str	r3, [r7, #40]	; 0x28


    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_NORMAL |
100023d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
100023d2:	2280      	movs	r2, #128	; 0x80
100023d4:	01d2      	lsls	r2, r2, #7
100023d6:	431a      	orrs	r2, r3
100023d8:	68fb      	ldr	r3, [r7, #12]
100023da:	611a      	str	r2, [r3, #16]
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
100023dc:	68fb      	ldr	r3, [r7, #12]
100023de:	695b      	ldr	r3, [r3, #20]
100023e0:	4a0e      	ldr	r2, [pc, #56]	; (1000241c <XMC_USIC_CH_SetBaudrateEx+0x108>)
100023e2:	401a      	ands	r2, r3
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
100023e4:	687b      	ldr	r3, [r7, #4]
100023e6:	3b01      	subs	r3, #1
100023e8:	029b      	lsls	r3, r3, #10
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
100023ea:	431a      	orrs	r2, r3
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv - 1) << USIC_CH_BRG_PDIV_Pos);
100023ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
100023ee:	3b01      	subs	r3, #1
100023f0:	041b      	lsls	r3, r3, #16

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
100023f2:	431a      	orrs	r2, r3


    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_NORMAL |
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
100023f4:	68fb      	ldr	r3, [r7, #12]
100023f6:	615a      	str	r2, [r3, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv - 1) << USIC_CH_BRG_PDIV_Pos);

    status = XMC_USIC_CH_STATUS_OK;
100023f8:	2327      	movs	r3, #39	; 0x27
100023fa:	18fb      	adds	r3, r7, r3
100023fc:	2200      	movs	r2, #0
100023fe:	701a      	strb	r2, [r3, #0]
10002400:	e003      	b.n	1000240a <XMC_USIC_CH_SetBaudrateEx+0xf6>
  }
  else
  {
    status = XMC_USIC_CH_STATUS_ERROR;
10002402:	2327      	movs	r3, #39	; 0x27
10002404:	18fb      	adds	r3, r7, r3
10002406:	2201      	movs	r2, #1
10002408:	701a      	strb	r2, [r3, #0]
  }

  return status;
1000240a:	2327      	movs	r3, #39	; 0x27
1000240c:	18fb      	adds	r3, r7, r3
1000240e:	781b      	ldrb	r3, [r3, #0]
}
10002410:	1c18      	adds	r0, r3, #0
10002412:	46bd      	mov	sp, r7
10002414:	b00c      	add	sp, #48	; 0x30
10002416:	bd80      	pop	{r7, pc}
10002418:	000003fe 	.word	0x000003fe
1000241c:	fc0080ef 	.word	0xfc0080ef

10002420 <XMC_USIC_CH_TXFIFO_Configure>:

void XMC_USIC_CH_TXFIFO_Configure(XMC_USIC_CH_t *const channel,
                                  const uint32_t data_pointer,
                                  const XMC_USIC_CH_FIFO_SIZE_t size,
                                  const uint32_t limit)
{
10002420:	b580      	push	{r7, lr}
10002422:	b084      	sub	sp, #16
10002424:	af00      	add	r7, sp, #0
10002426:	60f8      	str	r0, [r7, #12]
10002428:	60b9      	str	r1, [r7, #8]
1000242a:	603b      	str	r3, [r7, #0]
1000242c:	1dfb      	adds	r3, r7, #7
1000242e:	701a      	strb	r2, [r3, #0]
  /* Disable FIFO */
  channel->TBCTR &= (uint32_t)~USIC_CH_TBCTR_SIZE_Msk;
10002430:	68fa      	ldr	r2, [r7, #12]
10002432:	2384      	movs	r3, #132	; 0x84
10002434:	005b      	lsls	r3, r3, #1
10002436:	58d3      	ldr	r3, [r2, r3]
10002438:	4a0e      	ldr	r2, [pc, #56]	; (10002474 <XMC_USIC_CH_TXFIFO_Configure+0x54>)
1000243a:	4013      	ands	r3, r2
1000243c:	1c19      	adds	r1, r3, #0
1000243e:	68fa      	ldr	r2, [r7, #12]
10002440:	2384      	movs	r3, #132	; 0x84
10002442:	005b      	lsls	r3, r3, #1
10002444:	50d1      	str	r1, [r2, r3]
  /* LOF = 0, A standard transmit buffer event occurs when the filling level equals the limit value and gets
   * lower due to transmission of a data word
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
10002446:	68fa      	ldr	r2, [r7, #12]
10002448:	2384      	movs	r3, #132	; 0x84
1000244a:	005b      	lsls	r3, r3, #1
1000244c:	58d3      	ldr	r3, [r2, r3]
1000244e:	4a0a      	ldr	r2, [pc, #40]	; (10002478 <XMC_USIC_CH_TXFIFO_Configure+0x58>)
10002450:	401a      	ands	r2, r3
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
10002452:	683b      	ldr	r3, [r7, #0]
10002454:	0219      	lsls	r1, r3, #8
10002456:	68bb      	ldr	r3, [r7, #8]
10002458:	4319      	orrs	r1, r3
                              (data_pointer << USIC_CH_TBCTR_DPTR_Pos) |
                              ((uint32_t)size << USIC_CH_TBCTR_SIZE_Pos));
1000245a:	1dfb      	adds	r3, r7, #7
1000245c:	781b      	ldrb	r3, [r3, #0]
1000245e:	061b      	lsls	r3, r3, #24
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
10002460:	430b      	orrs	r3, r1
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
10002462:	431a      	orrs	r2, r3
10002464:	1c11      	adds	r1, r2, #0
  /* LOF = 0, A standard transmit buffer event occurs when the filling level equals the limit value and gets
   * lower due to transmission of a data word
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
10002466:	68fa      	ldr	r2, [r7, #12]
10002468:	2384      	movs	r3, #132	; 0x84
1000246a:	005b      	lsls	r3, r3, #1
1000246c:	50d1      	str	r1, [r2, r3]
                              USIC_CH_TBCTR_DPTR_Msk |
                              USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
                              (data_pointer << USIC_CH_TBCTR_DPTR_Pos) |
                              ((uint32_t)size << USIC_CH_TBCTR_SIZE_Pos));
}
1000246e:	46bd      	mov	sp, r7
10002470:	b004      	add	sp, #16
10002472:	bd80      	pop	{r7, pc}
10002474:	f8ffffff 	.word	0xf8ffffff
10002478:	f8ffc0c0 	.word	0xf8ffc0c0

1000247c <XMC_USIC_CH_RXFIFO_Configure>:

void XMC_USIC_CH_RXFIFO_Configure(XMC_USIC_CH_t *const channel,
                                  const uint32_t data_pointer,
                                  const XMC_USIC_CH_FIFO_SIZE_t size,
                                  const uint32_t limit)
{
1000247c:	b580      	push	{r7, lr}
1000247e:	b084      	sub	sp, #16
10002480:	af00      	add	r7, sp, #0
10002482:	60f8      	str	r0, [r7, #12]
10002484:	60b9      	str	r1, [r7, #8]
10002486:	603b      	str	r3, [r7, #0]
10002488:	1dfb      	adds	r3, r7, #7
1000248a:	701a      	strb	r2, [r3, #0]
  /* Disable FIFO */
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;
1000248c:	68fa      	ldr	r2, [r7, #12]
1000248e:	2386      	movs	r3, #134	; 0x86
10002490:	005b      	lsls	r3, r3, #1
10002492:	58d3      	ldr	r3, [r2, r3]
10002494:	4a10      	ldr	r2, [pc, #64]	; (100024d8 <XMC_USIC_CH_RXFIFO_Configure+0x5c>)
10002496:	4013      	ands	r3, r2
10002498:	1c19      	adds	r1, r3, #0
1000249a:	68fa      	ldr	r2, [r7, #12]
1000249c:	2386      	movs	r3, #134	; 0x86
1000249e:	005b      	lsls	r3, r3, #1
100024a0:	50d1      	str	r1, [r2, r3]

  /* LOF = 1, A standard receive buffer event occurs when the filling level equals the limit value and gets bigger
   *  due to the reception of a new data word
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
100024a2:	68fa      	ldr	r2, [r7, #12]
100024a4:	2386      	movs	r3, #134	; 0x86
100024a6:	005b      	lsls	r3, r3, #1
100024a8:	58d3      	ldr	r3, [r2, r3]
100024aa:	4a0c      	ldr	r2, [pc, #48]	; (100024dc <XMC_USIC_CH_RXFIFO_Configure+0x60>)
100024ac:	401a      	ands	r2, r3
                               USIC_CH_RBCTR_DPTR_Msk |
                               USIC_CH_RBCTR_LOF_Msk)) |
                              ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
100024ae:	683b      	ldr	r3, [r7, #0]
100024b0:	0219      	lsls	r1, r3, #8
100024b2:	68bb      	ldr	r3, [r7, #8]
100024b4:	4319      	orrs	r1, r3
                               (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
                               ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos) |
100024b6:	1dfb      	adds	r3, r7, #7
100024b8:	781b      	ldrb	r3, [r3, #0]
100024ba:	061b      	lsls	r3, r3, #24
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
                               USIC_CH_RBCTR_DPTR_Msk |
                               USIC_CH_RBCTR_LOF_Msk)) |
                              ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
                               (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
100024bc:	430b      	orrs	r3, r1
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;

  /* LOF = 1, A standard receive buffer event occurs when the filling level equals the limit value and gets bigger
   *  due to the reception of a new data word
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
100024be:	4313      	orrs	r3, r2
100024c0:	2280      	movs	r2, #128	; 0x80
100024c2:	0552      	lsls	r2, r2, #21
100024c4:	431a      	orrs	r2, r3
100024c6:	1c11      	adds	r1, r2, #0
100024c8:	68fa      	ldr	r2, [r7, #12]
100024ca:	2386      	movs	r3, #134	; 0x86
100024cc:	005b      	lsls	r3, r3, #1
100024ce:	50d1      	str	r1, [r2, r3]
                               USIC_CH_RBCTR_LOF_Msk)) |
                              ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
                               (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
                               ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos) |
                               (uint32_t)USIC_CH_RBCTR_LOF_Msk));
}
100024d0:	46bd      	mov	sp, r7
100024d2:	b004      	add	sp, #16
100024d4:	bd80      	pop	{r7, pc}
100024d6:	46c0      	nop			; (mov r8, r8)
100024d8:	f8ffffff 	.word	0xf8ffffff
100024dc:	efffc0c0 	.word	0xefffc0c0

100024e0 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit>:
}

void XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_FIFO_SIZE_t size,
    const uint32_t limit)
{
100024e0:	b580      	push	{r7, lr}
100024e2:	b084      	sub	sp, #16
100024e4:	af00      	add	r7, sp, #0
100024e6:	60f8      	str	r0, [r7, #12]
100024e8:	607a      	str	r2, [r7, #4]
100024ea:	230b      	movs	r3, #11
100024ec:	18fb      	adds	r3, r7, r3
100024ee:	1c0a      	adds	r2, r1, #0
100024f0:	701a      	strb	r2, [r3, #0]
  XMC_UNUSED_ARG(size);

  channel->RBCTR = (uint32_t)((uint32_t)(channel->RBCTR & (uint32_t)~USIC_CH_RBCTR_LIMIT_Msk) |
100024f2:	68fa      	ldr	r2, [r7, #12]
100024f4:	2386      	movs	r3, #134	; 0x86
100024f6:	005b      	lsls	r3, r3, #1
100024f8:	58d3      	ldr	r3, [r2, r3]
100024fa:	4a06      	ldr	r2, [pc, #24]	; (10002514 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit+0x34>)
100024fc:	401a      	ands	r2, r3
                              (limit << USIC_CH_RBCTR_LIMIT_Pos));
100024fe:	687b      	ldr	r3, [r7, #4]
10002500:	021b      	lsls	r3, r3, #8
    const XMC_USIC_CH_FIFO_SIZE_t size,
    const uint32_t limit)
{
  XMC_UNUSED_ARG(size);

  channel->RBCTR = (uint32_t)((uint32_t)(channel->RBCTR & (uint32_t)~USIC_CH_RBCTR_LIMIT_Msk) |
10002502:	431a      	orrs	r2, r3
10002504:	1c11      	adds	r1, r2, #0
10002506:	68fa      	ldr	r2, [r7, #12]
10002508:	2386      	movs	r3, #134	; 0x86
1000250a:	005b      	lsls	r3, r3, #1
1000250c:	50d1      	str	r1, [r2, r3]
                              (limit << USIC_CH_RBCTR_LIMIT_Pos));
}
1000250e:	46bd      	mov	sp, r7
10002510:	b004      	add	sp, #16
10002512:	bd80      	pop	{r7, pc}
10002514:	ffffc0ff 	.word	0xffffc0ff

10002518 <XMC_USIC_CH_SetInterruptNodePointer>:

void XMC_USIC_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
10002518:	b580      	push	{r7, lr}
1000251a:	b084      	sub	sp, #16
1000251c:	af00      	add	r7, sp, #0
1000251e:	60f8      	str	r0, [r7, #12]
10002520:	607a      	str	r2, [r7, #4]
10002522:	230b      	movs	r3, #11
10002524:	18fb      	adds	r3, r7, r3
10002526:	1c0a      	adds	r2, r1, #0
10002528:	701a      	strb	r2, [r3, #0]
  channel->INPR = (uint32_t)((channel->INPR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
1000252a:	68fb      	ldr	r3, [r7, #12]
1000252c:	699b      	ldr	r3, [r3, #24]
1000252e:	220b      	movs	r2, #11
10002530:	18ba      	adds	r2, r7, r2
10002532:	7812      	ldrb	r2, [r2, #0]
10002534:	2107      	movs	r1, #7
10002536:	4091      	lsls	r1, r2
10002538:	1c0a      	adds	r2, r1, #0
1000253a:	43d2      	mvns	r2, r2
1000253c:	401a      	ands	r2, r3
                             (service_request << (uint32_t)interrupt_node));
1000253e:	230b      	movs	r3, #11
10002540:	18fb      	adds	r3, r7, r3
10002542:	781b      	ldrb	r3, [r3, #0]
10002544:	6879      	ldr	r1, [r7, #4]
10002546:	4099      	lsls	r1, r3
10002548:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
  channel->INPR = (uint32_t)((channel->INPR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
1000254a:	431a      	orrs	r2, r3
1000254c:	68fb      	ldr	r3, [r7, #12]
1000254e:	619a      	str	r2, [r3, #24]
                             (service_request << (uint32_t)interrupt_node));
}
10002550:	46bd      	mov	sp, r7
10002552:	b004      	add	sp, #16
10002554:	bd80      	pop	{r7, pc}
10002556:	46c0      	nop			; (mov r8, r8)

10002558 <XMC_USIC_CH_TXFIFO_SetInterruptNodePointer>:

void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
10002558:	b580      	push	{r7, lr}
1000255a:	b084      	sub	sp, #16
1000255c:	af00      	add	r7, sp, #0
1000255e:	60f8      	str	r0, [r7, #12]
10002560:	607a      	str	r2, [r7, #4]
10002562:	230b      	movs	r3, #11
10002564:	18fb      	adds	r3, r7, r3
10002566:	1c0a      	adds	r2, r1, #0
10002568:	701a      	strb	r2, [r3, #0]
  channel->TBCTR = (uint32_t)((channel->TBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
1000256a:	68fa      	ldr	r2, [r7, #12]
1000256c:	2384      	movs	r3, #132	; 0x84
1000256e:	005b      	lsls	r3, r3, #1
10002570:	58d3      	ldr	r3, [r2, r3]
10002572:	220b      	movs	r2, #11
10002574:	18ba      	adds	r2, r7, r2
10002576:	7812      	ldrb	r2, [r2, #0]
10002578:	2107      	movs	r1, #7
1000257a:	4091      	lsls	r1, r2
1000257c:	1c0a      	adds	r2, r1, #0
1000257e:	43d2      	mvns	r2, r2
10002580:	401a      	ands	r2, r3
                              (service_request << (uint32_t)interrupt_node));
10002582:	230b      	movs	r3, #11
10002584:	18fb      	adds	r3, r7, r3
10002586:	781b      	ldrb	r3, [r3, #0]
10002588:	6879      	ldr	r1, [r7, #4]
1000258a:	4099      	lsls	r1, r3
1000258c:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
  channel->TBCTR = (uint32_t)((channel->TBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
1000258e:	431a      	orrs	r2, r3
10002590:	1c11      	adds	r1, r2, #0
10002592:	68fa      	ldr	r2, [r7, #12]
10002594:	2384      	movs	r3, #132	; 0x84
10002596:	005b      	lsls	r3, r3, #1
10002598:	50d1      	str	r1, [r2, r3]
                              (service_request << (uint32_t)interrupt_node));
}
1000259a:	46bd      	mov	sp, r7
1000259c:	b004      	add	sp, #16
1000259e:	bd80      	pop	{r7, pc}

100025a0 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>:

void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
100025a0:	b580      	push	{r7, lr}
100025a2:	b084      	sub	sp, #16
100025a4:	af00      	add	r7, sp, #0
100025a6:	60f8      	str	r0, [r7, #12]
100025a8:	607a      	str	r2, [r7, #4]
100025aa:	230b      	movs	r3, #11
100025ac:	18fb      	adds	r3, r7, r3
100025ae:	1c0a      	adds	r2, r1, #0
100025b0:	701a      	strb	r2, [r3, #0]
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
100025b2:	68fa      	ldr	r2, [r7, #12]
100025b4:	2386      	movs	r3, #134	; 0x86
100025b6:	005b      	lsls	r3, r3, #1
100025b8:	58d3      	ldr	r3, [r2, r3]
100025ba:	220b      	movs	r2, #11
100025bc:	18ba      	adds	r2, r7, r2
100025be:	7812      	ldrb	r2, [r2, #0]
100025c0:	2107      	movs	r1, #7
100025c2:	4091      	lsls	r1, r2
100025c4:	1c0a      	adds	r2, r1, #0
100025c6:	43d2      	mvns	r2, r2
100025c8:	401a      	ands	r2, r3
                              (service_request << (uint32_t)interrupt_node));
100025ca:	230b      	movs	r3, #11
100025cc:	18fb      	adds	r3, r7, r3
100025ce:	781b      	ldrb	r3, [r3, #0]
100025d0:	6879      	ldr	r1, [r7, #4]
100025d2:	4099      	lsls	r1, r3
100025d4:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
100025d6:	431a      	orrs	r2, r3
100025d8:	1c11      	adds	r1, r2, #0
100025da:	68fa      	ldr	r2, [r7, #12]
100025dc:	2386      	movs	r3, #134	; 0x86
100025de:	005b      	lsls	r3, r3, #1
100025e0:	50d1      	str	r1, [r2, r3]
                              (service_request << (uint32_t)interrupt_node));
}
100025e2:	46bd      	mov	sp, r7
100025e4:	b004      	add	sp, #16
100025e6:	bd80      	pop	{r7, pc}

100025e8 <XMC_USIC_Enable>:

void XMC_USIC_Enable(XMC_USIC_t *const usic)
{
100025e8:	b580      	push	{r7, lr}
100025ea:	b082      	sub	sp, #8
100025ec:	af00      	add	r7, sp, #0
100025ee:	6078      	str	r0, [r7, #4]
  if (usic == USIC0)
100025f0:	687b      	ldr	r3, [r7, #4]
100025f2:	4a10      	ldr	r2, [pc, #64]	; (10002634 <XMC_USIC_Enable+0x4c>)
100025f4:	4293      	cmp	r3, r2
100025f6:	d109      	bne.n	1000260c <XMC_USIC_Enable+0x24>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC0);
100025f8:	2008      	movs	r0, #8
100025fa:	f7fe ff51 	bl	100014a0 <XMC_SCU_CLOCK_UngatePeripheralClock>
    while (XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_USIC0));
100025fe:	46c0      	nop			; (mov r8, r8)
10002600:	2008      	movs	r0, #8
10002602:	f7fe ff67 	bl	100014d4 <XMC_SCU_CLOCK_IsPeripheralClockGated>
10002606:	1e03      	subs	r3, r0, #0
10002608:	d1fa      	bne.n	10002600 <XMC_USIC_Enable+0x18>
1000260a:	e010      	b.n	1000262e <XMC_USIC_Enable+0x46>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC0);
    while (XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_USIC0));
#endif
  }
#if defined(USIC1)
  else if (usic == USIC1)
1000260c:	687b      	ldr	r3, [r7, #4]
1000260e:	4a0a      	ldr	r2, [pc, #40]	; (10002638 <XMC_USIC_Enable+0x50>)
10002610:	4293      	cmp	r3, r2
10002612:	d10c      	bne.n	1000262e <XMC_USIC_Enable+0x46>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC1);
10002614:	2380      	movs	r3, #128	; 0x80
10002616:	02db      	lsls	r3, r3, #11
10002618:	1c18      	adds	r0, r3, #0
1000261a:	f7fe ff41 	bl	100014a0 <XMC_SCU_CLOCK_UngatePeripheralClock>
    while (XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_USIC1));
1000261e:	46c0      	nop			; (mov r8, r8)
10002620:	2380      	movs	r3, #128	; 0x80
10002622:	02db      	lsls	r3, r3, #11
10002624:	1c18      	adds	r0, r3, #0
10002626:	f7fe ff55 	bl	100014d4 <XMC_SCU_CLOCK_IsPeripheralClockGated>
1000262a:	1e03      	subs	r3, r0, #0
1000262c:	d1f8      	bne.n	10002620 <XMC_USIC_Enable+0x38>
#endif
  else
  {
    XMC_ASSERT("USIC module not available", 0/*Always*/);
  }
}
1000262e:	46bd      	mov	sp, r7
10002630:	b002      	add	sp, #8
10002632:	bd80      	pop	{r7, pc}
10002634:	48000008 	.word	0x48000008
10002638:	48004008 	.word	0x48004008

1000263c <_sbrk>:

// defined in linker script
extern caddr_t Heap_Bank1_Start;
extern caddr_t Heap_Bank1_End;
caddr_t _sbrk(int nbytes)
{
1000263c:	b580      	push	{r7, lr}
1000263e:	b084      	sub	sp, #16
10002640:	af00      	add	r7, sp, #0
10002642:	6078      	str	r0, [r7, #4]
  static caddr_t heap_ptr = NULL;
  caddr_t base;

  if (heap_ptr == NULL) {
10002644:	4b14      	ldr	r3, [pc, #80]	; (10002698 <_sbrk+0x5c>)
10002646:	681b      	ldr	r3, [r3, #0]
10002648:	2b00      	cmp	r3, #0
1000264a:	d102      	bne.n	10002652 <_sbrk+0x16>
    heap_ptr = (caddr_t)&Heap_Bank1_Start;
1000264c:	4b12      	ldr	r3, [pc, #72]	; (10002698 <_sbrk+0x5c>)
1000264e:	4a13      	ldr	r2, [pc, #76]	; (1000269c <_sbrk+0x60>)
10002650:	601a      	str	r2, [r3, #0]
  }

  base = heap_ptr;
10002652:	4b11      	ldr	r3, [pc, #68]	; (10002698 <_sbrk+0x5c>)
10002654:	681b      	ldr	r3, [r3, #0]
10002656:	60fb      	str	r3, [r7, #12]

  /* heap word alignment */
  nbytes = (nbytes + 3) & ~0x3U;
10002658:	687b      	ldr	r3, [r7, #4]
1000265a:	3303      	adds	r3, #3
1000265c:	2203      	movs	r2, #3
1000265e:	4393      	bics	r3, r2
10002660:	607b      	str	r3, [r7, #4]
  if ((caddr_t)&Heap_Bank1_End > (heap_ptr + nbytes))
10002662:	4b0d      	ldr	r3, [pc, #52]	; (10002698 <_sbrk+0x5c>)
10002664:	681a      	ldr	r2, [r3, #0]
10002666:	687b      	ldr	r3, [r7, #4]
10002668:	18d2      	adds	r2, r2, r3
1000266a:	4b0d      	ldr	r3, [pc, #52]	; (100026a0 <_sbrk+0x64>)
1000266c:	429a      	cmp	r2, r3
1000266e:	d207      	bcs.n	10002680 <_sbrk+0x44>
  {
    heap_ptr += nbytes;
10002670:	4b09      	ldr	r3, [pc, #36]	; (10002698 <_sbrk+0x5c>)
10002672:	681a      	ldr	r2, [r3, #0]
10002674:	687b      	ldr	r3, [r7, #4]
10002676:	18d2      	adds	r2, r2, r3
10002678:	4b07      	ldr	r3, [pc, #28]	; (10002698 <_sbrk+0x5c>)
1000267a:	601a      	str	r2, [r3, #0]
    return (base);
1000267c:	68fb      	ldr	r3, [r7, #12]
1000267e:	e006      	b.n	1000268e <_sbrk+0x52>
  }
  else
  {
    /* Heap overflow */
    errno = ENOMEM;
10002680:	f003 ff12 	bl	100064a8 <__errno>
10002684:	1c03      	adds	r3, r0, #0
10002686:	220c      	movs	r2, #12
10002688:	601a      	str	r2, [r3, #0]
    return ((caddr_t)-1);
1000268a:	2301      	movs	r3, #1
1000268c:	425b      	negs	r3, r3
  }
}
1000268e:	1c18      	adds	r0, r3, #0
10002690:	46bd      	mov	sp, r7
10002692:	b004      	add	sp, #16
10002694:	bd80      	pop	{r7, pc}
10002696:	46c0      	nop			; (mov r8, r8)
10002698:	2000064c 	.word	0x2000064c
1000269c:	20000818 	.word	0x20000818
100026a0:	20003ffc 	.word	0x20003ffc

100026a4 <_init>:

/* Init */
void _init(void)
{}
100026a4:	b580      	push	{r7, lr}
100026a6:	af00      	add	r7, sp, #0
100026a8:	46bd      	mov	sp, r7
100026aa:	bd80      	pop	{r7, pc}

100026ac <XMC_USIC_CH_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
100026ac:	b580      	push	{r7, lr}
100026ae:	b082      	sub	sp, #8
100026b0:	af00      	add	r7, sp, #0
100026b2:	6078      	str	r0, [r7, #4]
100026b4:	6039      	str	r1, [r7, #0]
  channel->CCR |= event;
100026b6:	687b      	ldr	r3, [r7, #4]
100026b8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
100026ba:	683b      	ldr	r3, [r7, #0]
100026bc:	431a      	orrs	r2, r3
100026be:	687b      	ldr	r3, [r7, #4]
100026c0:	641a      	str	r2, [r3, #64]	; 0x40
}
100026c2:	46bd      	mov	sp, r7
100026c4:	b002      	add	sp, #8
100026c6:	bd80      	pop	{r7, pc}

100026c8 <XMC_USIC_CH_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
*/
__STATIC_INLINE void XMC_USIC_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
100026c8:	b580      	push	{r7, lr}
100026ca:	b082      	sub	sp, #8
100026cc:	af00      	add	r7, sp, #0
100026ce:	6078      	str	r0, [r7, #4]
100026d0:	6039      	str	r1, [r7, #0]
  channel->CCR &= (uint32_t)~event;
100026d2:	687b      	ldr	r3, [r7, #4]
100026d4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100026d6:	683a      	ldr	r2, [r7, #0]
100026d8:	43d2      	mvns	r2, r2
100026da:	401a      	ands	r2, r3
100026dc:	687b      	ldr	r3, [r7, #4]
100026de:	641a      	str	r2, [r3, #64]	; 0x40
}
100026e0:	46bd      	mov	sp, r7
100026e2:	b002      	add	sp, #8
100026e4:	bd80      	pop	{r7, pc}
100026e6:	46c0      	nop			; (mov r8, r8)

100026e8 <XMC_USIC_CH_GetTransmitBufferStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
100026e8:	b580      	push	{r7, lr}
100026ea:	b082      	sub	sp, #8
100026ec:	af00      	add	r7, sp, #0
100026ee:	6078      	str	r0, [r7, #4]
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
100026f0:	687b      	ldr	r3, [r7, #4]
100026f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
100026f4:	b2db      	uxtb	r3, r3
100026f6:	227f      	movs	r2, #127	; 0x7f
100026f8:	4393      	bics	r3, r2
100026fa:	b2db      	uxtb	r3, r3
}
100026fc:	1c18      	adds	r0, r3, #0
100026fe:	46bd      	mov	sp, r7
10002700:	b002      	add	sp, #8
10002702:	bd80      	pop	{r7, pc}

10002704 <XMC_USIC_CH_TXFIFO_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetEvent(), XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10002704:	b580      	push	{r7, lr}
10002706:	b082      	sub	sp, #8
10002708:	af00      	add	r7, sp, #0
1000270a:	6078      	str	r0, [r7, #4]
1000270c:	6039      	str	r1, [r7, #0]
  channel->TBCTR &= (uint32_t)~event;
1000270e:	687a      	ldr	r2, [r7, #4]
10002710:	2384      	movs	r3, #132	; 0x84
10002712:	005b      	lsls	r3, r3, #1
10002714:	58d3      	ldr	r3, [r2, r3]
10002716:	683a      	ldr	r2, [r7, #0]
10002718:	43d2      	mvns	r2, r2
1000271a:	401a      	ands	r2, r3
1000271c:	1c11      	adds	r1, r2, #0
1000271e:	687a      	ldr	r2, [r7, #4]
10002720:	2384      	movs	r3, #132	; 0x84
10002722:	005b      	lsls	r3, r3, #1
10002724:	50d1      	str	r1, [r2, r3]
}
10002726:	46bd      	mov	sp, r7
10002728:	b002      	add	sp, #8
1000272a:	bd80      	pop	{r7, pc}

1000272c <XMC_USIC_CH_TXFIFO_IsFull>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
1000272c:	b580      	push	{r7, lr}
1000272e:	b082      	sub	sp, #8
10002730:	af00      	add	r7, sp, #0
10002732:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
10002734:	687a      	ldr	r2, [r7, #4]
10002736:	238a      	movs	r3, #138	; 0x8a
10002738:	005b      	lsls	r3, r3, #1
1000273a:	58d2      	ldr	r2, [r2, r3]
1000273c:	2380      	movs	r3, #128	; 0x80
1000273e:	015b      	lsls	r3, r3, #5
10002740:	4013      	ands	r3, r2
10002742:	1e5a      	subs	r2, r3, #1
10002744:	4193      	sbcs	r3, r2
10002746:	b2db      	uxtb	r3, r3
}
10002748:	1c18      	adds	r0, r3, #0
1000274a:	46bd      	mov	sp, r7
1000274c:	b002      	add	sp, #8
1000274e:	bd80      	pop	{r7, pc}

10002750 <XMC_USIC_CH_TXFIFO_IsEmpty>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_Flush(), XMC_USIC_CH_TXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
10002750:	b580      	push	{r7, lr}
10002752:	b082      	sub	sp, #8
10002754:	af00      	add	r7, sp, #0
10002756:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TEMPTY_Msk);
10002758:	687a      	ldr	r2, [r7, #4]
1000275a:	238a      	movs	r3, #138	; 0x8a
1000275c:	005b      	lsls	r3, r3, #1
1000275e:	58d2      	ldr	r2, [r2, r3]
10002760:	2380      	movs	r3, #128	; 0x80
10002762:	011b      	lsls	r3, r3, #4
10002764:	4013      	ands	r3, r2
10002766:	1e5a      	subs	r2, r3, #1
10002768:	4193      	sbcs	r3, r2
1000276a:	b2db      	uxtb	r3, r3
}
1000276c:	1c18      	adds	r0, r3, #0
1000276e:	46bd      	mov	sp, r7
10002770:	b002      	add	sp, #8
10002772:	bd80      	pop	{r7, pc}

10002774 <XMC_USIC_CH_RXFIFO_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10002774:	b580      	push	{r7, lr}
10002776:	b082      	sub	sp, #8
10002778:	af00      	add	r7, sp, #0
1000277a:	6078      	str	r0, [r7, #4]
1000277c:	6039      	str	r1, [r7, #0]
  channel->RBCTR |= event;
1000277e:	687a      	ldr	r2, [r7, #4]
10002780:	2386      	movs	r3, #134	; 0x86
10002782:	005b      	lsls	r3, r3, #1
10002784:	58d2      	ldr	r2, [r2, r3]
10002786:	683b      	ldr	r3, [r7, #0]
10002788:	431a      	orrs	r2, r3
1000278a:	1c11      	adds	r1, r2, #0
1000278c:	687a      	ldr	r2, [r7, #4]
1000278e:	2386      	movs	r3, #134	; 0x86
10002790:	005b      	lsls	r3, r3, #1
10002792:	50d1      	str	r1, [r2, r3]
}
10002794:	46bd      	mov	sp, r7
10002796:	b002      	add	sp, #8
10002798:	bd80      	pop	{r7, pc}
1000279a:	46c0      	nop			; (mov r8, r8)

1000279c <XMC_USIC_CH_RXFIFO_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_GetEvent(), XMC_USIC_CH_RXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
1000279c:	b580      	push	{r7, lr}
1000279e:	b082      	sub	sp, #8
100027a0:	af00      	add	r7, sp, #0
100027a2:	6078      	str	r0, [r7, #4]
100027a4:	6039      	str	r1, [r7, #0]
  channel->RBCTR &= (uint32_t)~event;
100027a6:	687a      	ldr	r2, [r7, #4]
100027a8:	2386      	movs	r3, #134	; 0x86
100027aa:	005b      	lsls	r3, r3, #1
100027ac:	58d3      	ldr	r3, [r2, r3]
100027ae:	683a      	ldr	r2, [r7, #0]
100027b0:	43d2      	mvns	r2, r2
100027b2:	401a      	ands	r2, r3
100027b4:	1c11      	adds	r1, r2, #0
100027b6:	687a      	ldr	r2, [r7, #4]
100027b8:	2386      	movs	r3, #134	; 0x86
100027ba:	005b      	lsls	r3, r3, #1
100027bc:	50d1      	str	r1, [r2, r3]
}
100027be:	46bd      	mov	sp, r7
100027c0:	b002      	add	sp, #8
100027c2:	bd80      	pop	{r7, pc}

100027c4 <XMC_USIC_CH_RXFIFO_Flush>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
100027c4:	b580      	push	{r7, lr}
100027c6:	b082      	sub	sp, #8
100027c8:	af00      	add	r7, sp, #0
100027ca:	6078      	str	r0, [r7, #4]
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHRB_Msk;
100027cc:	687a      	ldr	r2, [r7, #4]
100027ce:	238c      	movs	r3, #140	; 0x8c
100027d0:	005b      	lsls	r3, r3, #1
100027d2:	2180      	movs	r1, #128	; 0x80
100027d4:	01c9      	lsls	r1, r1, #7
100027d6:	50d1      	str	r1, [r2, r3]
}
100027d8:	46bd      	mov	sp, r7
100027da:	b002      	add	sp, #8
100027dc:	bd80      	pop	{r7, pc}
100027de:	46c0      	nop			; (mov r8, r8)

100027e0 <XMC_USIC_CH_RXFIFO_IsEmpty>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_Flush(), XMC_USIC_CH_RXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
100027e0:	b580      	push	{r7, lr}
100027e2:	b082      	sub	sp, #8
100027e4:	af00      	add	r7, sp, #0
100027e6:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_REMPTY_Msk);
100027e8:	687a      	ldr	r2, [r7, #4]
100027ea:	238a      	movs	r3, #138	; 0x8a
100027ec:	005b      	lsls	r3, r3, #1
100027ee:	58d3      	ldr	r3, [r2, r3]
100027f0:	2208      	movs	r2, #8
100027f2:	4013      	ands	r3, r2
100027f4:	1e5a      	subs	r2, r3, #1
100027f6:	4193      	sbcs	r3, r2
100027f8:	b2db      	uxtb	r3, r3
}
100027fa:	1c18      	adds	r0, r3, #0
100027fc:	46bd      	mov	sp, r7
100027fe:	b002      	add	sp, #8
10002800:	bd80      	pop	{r7, pc}
10002802:	46c0      	nop			; (mov r8, r8)

10002804 <UART_Init>:
 *          UART_SUCCESS: for successful UART initialization.<BR>
 *          UART_STATUS_FAILURE  : If UART initialization fails.<BR>
 *
 */
UART_STATUS_t UART_Init(const UART_t *const handle)
{
10002804:	b590      	push	{r4, r7, lr}
10002806:	b085      	sub	sp, #20
10002808:	af00      	add	r7, sp, #0
1000280a:	6078      	str	r0, [r7, #4]
  UART_STATUS_t status = UART_STATUS_SUCCESS;
1000280c:	230f      	movs	r3, #15
1000280e:	18fb      	adds	r3, r7, r3
10002810:	2200      	movs	r2, #0
10002812:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("UART_Init : UART APP handle invalid", (((handle != NULL)&&
      (handle->config != NULL)) &&((handle->config->fptr_uart_config != NULL)&&
      (handle->runtime != NULL))));

  /*Initialize the multiplexers required for UART configuration*/
  status = handle->config->fptr_uart_config();
10002814:	687b      	ldr	r3, [r7, #4]
10002816:	685b      	ldr	r3, [r3, #4]
10002818:	685b      	ldr	r3, [r3, #4]
1000281a:	220f      	movs	r2, #15
1000281c:	18bc      	adds	r4, r7, r2
1000281e:	4798      	blx	r3
10002820:	1c03      	adds	r3, r0, #0
10002822:	7023      	strb	r3, [r4, #0]

  return status;
10002824:	230f      	movs	r3, #15
10002826:	18fb      	adds	r3, r7, r3
10002828:	781b      	ldrb	r3, [r3, #0]
}
1000282a:	1c18      	adds	r0, r3, #0
1000282c:	46bd      	mov	sp, r7
1000282e:	b005      	add	sp, #20
10002830:	bd90      	pop	{r4, r7, pc}
10002832:	46c0      	nop			; (mov r8, r8)

10002834 <UART_Receive>:
 *          UART_STATUS_BUFFER_INVALID: Either if buffer is NULL or count is 0.<BR>
 *          UART_STATUS_MODE_MISMATCH: If the configured mode is invalid.<BR>
 *
 */
UART_STATUS_t UART_Receive(const UART_t *const handle, uint8_t* data_ptr, uint32_t count)
{
10002834:	b590      	push	{r4, r7, lr}
10002836:	b087      	sub	sp, #28
10002838:	af00      	add	r7, sp, #0
1000283a:	60f8      	str	r0, [r7, #12]
1000283c:	60b9      	str	r1, [r7, #8]
1000283e:	607a      	str	r2, [r7, #4]
  UART_STATUS_t ret_stat = UART_STATUS_MODE_MISMATCH;
10002840:	2317      	movs	r3, #23
10002842:	18fb      	adds	r3, r7, r3
10002844:	2204      	movs	r2, #4
10002846:	701a      	strb	r2, [r3, #0]

  switch(handle->config->receive_mode)
10002848:	68fb      	ldr	r3, [r7, #12]
1000284a:	685b      	ldr	r3, [r3, #4]
1000284c:	222a      	movs	r2, #42	; 0x2a
1000284e:	5c9b      	ldrb	r3, [r3, r2]
10002850:	2b00      	cmp	r3, #0
10002852:	d000      	beq.n	10002856 <UART_Receive+0x22>
  case UART_TRANSFER_MODE_DIRECT:
    ret_stat = UART_lStartReceivePolling(handle, data_ptr, count);
    break;
#endif
  default:
    break;
10002854:	e00c      	b.n	10002870 <UART_Receive+0x3c>

  switch(handle->config->receive_mode)
  {
#ifdef UART_RX_INTERRUPT_USED
  case UART_TRANSFER_MODE_INTERRUPT:
    ret_stat = UART_StartReceiveIRQ(handle, data_ptr, count);
10002856:	2317      	movs	r3, #23
10002858:	18fc      	adds	r4, r7, r3
1000285a:	68f9      	ldr	r1, [r7, #12]
1000285c:	68ba      	ldr	r2, [r7, #8]
1000285e:	687b      	ldr	r3, [r7, #4]
10002860:	1c08      	adds	r0, r1, #0
10002862:	1c11      	adds	r1, r2, #0
10002864:	1c1a      	adds	r2, r3, #0
10002866:	f000 f80b 	bl	10002880 <UART_StartReceiveIRQ>
1000286a:	1c03      	adds	r3, r0, #0
1000286c:	7023      	strb	r3, [r4, #0]
    break;
1000286e:	46c0      	nop			; (mov r8, r8)
    break;
#endif
  default:
    break;
  }
  return ret_stat;
10002870:	2317      	movs	r3, #23
10002872:	18fb      	adds	r3, r7, r3
10002874:	781b      	ldrb	r3, [r3, #0]
}
10002876:	1c18      	adds	r0, r3, #0
10002878:	46bd      	mov	sp, r7
1000287a:	b007      	add	sp, #28
1000287c:	bd90      	pop	{r4, r7, pc}
1000287e:	46c0      	nop			; (mov r8, r8)

10002880 <UART_StartReceiveIRQ>:
 * request is registered.
 *
 *
 */
UART_STATUS_t UART_StartReceiveIRQ(const UART_t *const handle, uint8_t* data_ptr, uint32_t count)
{
10002880:	b580      	push	{r7, lr}
10002882:	b086      	sub	sp, #24
10002884:	af00      	add	r7, sp, #0
10002886:	60f8      	str	r0, [r7, #12]
10002888:	60b9      	str	r1, [r7, #8]
1000288a:	607a      	str	r2, [r7, #4]
  UART_STATUS_t ret_stat = UART_STATUS_MODE_MISMATCH;
1000288c:	2317      	movs	r3, #23
1000288e:	18fb      	adds	r3, r7, r3
10002890:	2204      	movs	r2, #4
10002892:	701a      	strb	r2, [r3, #0]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
10002894:	68fb      	ldr	r3, [r7, #12]
10002896:	689b      	ldr	r3, [r3, #8]
10002898:	613b      	str	r3, [r7, #16]

  XMC_ASSERT("UART_StartReceiveIRQ: UART APP handle invalid", ((handle != NULL)&&
            (handle->runtime != NULL)));

  if (handle->config->receive_mode == UART_TRANSFER_MODE_INTERRUPT)
1000289a:	68fb      	ldr	r3, [r7, #12]
1000289c:	685b      	ldr	r3, [r3, #4]
1000289e:	222a      	movs	r2, #42	; 0x2a
100028a0:	5c9b      	ldrb	r3, [r3, r2]
100028a2:	2b00      	cmp	r3, #0
100028a4:	d148      	bne.n	10002938 <UART_StartReceiveIRQ+0xb8>
  {
    ret_stat = UART_STATUS_BUSY;
100028a6:	2317      	movs	r3, #23
100028a8:	18fb      	adds	r3, r7, r3
100028aa:	2202      	movs	r2, #2
100028ac:	701a      	strb	r2, [r3, #0]
    if (ptr_runtime->rx_busy == false)
100028ae:	693b      	ldr	r3, [r7, #16]
100028b0:	7e5b      	ldrb	r3, [r3, #25]
100028b2:	b2db      	uxtb	r3, r3
100028b4:	2201      	movs	r2, #1
100028b6:	4053      	eors	r3, r2
100028b8:	b2db      	uxtb	r3, r3
100028ba:	2b00      	cmp	r3, #0
100028bc:	d03c      	beq.n	10002938 <UART_StartReceiveIRQ+0xb8>
    {
      /*If no active reception in progress*/
      if ((data_ptr != NULL) && (count > 0U))
100028be:	68bb      	ldr	r3, [r7, #8]
100028c0:	2b00      	cmp	r3, #0
100028c2:	d035      	beq.n	10002930 <UART_StartReceiveIRQ+0xb0>
100028c4:	687b      	ldr	r3, [r7, #4]
100028c6:	2b00      	cmp	r3, #0
100028c8:	d032      	beq.n	10002930 <UART_StartReceiveIRQ+0xb0>
      {
        /*Obtain the address of data buffer and
         * number of data bytes to be received*/
        ptr_runtime->rx_data = data_ptr;
100028ca:	693b      	ldr	r3, [r7, #16]
100028cc:	68ba      	ldr	r2, [r7, #8]
100028ce:	605a      	str	r2, [r3, #4]
        ptr_runtime->rx_data_count = count;
100028d0:	693b      	ldr	r3, [r7, #16]
100028d2:	687a      	ldr	r2, [r7, #4]
100028d4:	611a      	str	r2, [r3, #16]
        ptr_runtime->rx_busy = true;
100028d6:	693b      	ldr	r3, [r7, #16]
100028d8:	2201      	movs	r2, #1
100028da:	765a      	strb	r2, [r3, #25]
        ptr_runtime->rx_data_index = 0U;
100028dc:	693b      	ldr	r3, [r7, #16]
100028de:	2200      	movs	r2, #0
100028e0:	615a      	str	r2, [r3, #20]

        if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
100028e2:	68fb      	ldr	r3, [r7, #12]
100028e4:	685b      	ldr	r3, [r3, #4]
100028e6:	222c      	movs	r2, #44	; 0x2c
100028e8:	5c9b      	ldrb	r3, [r3, r2]
100028ea:	2b00      	cmp	r3, #0
100028ec:	d013      	beq.n	10002916 <UART_StartReceiveIRQ+0x96>
        {
          /*Clear the receive FIFO, configure the trigger lime
           * and enable the receive events*/
          XMC_USIC_CH_RXFIFO_Flush(handle->channel);
100028ee:	68fb      	ldr	r3, [r7, #12]
100028f0:	681b      	ldr	r3, [r3, #0]
100028f2:	1c18      	adds	r0, r3, #0
100028f4:	f7ff ff66 	bl	100027c4 <XMC_USIC_CH_RXFIFO_Flush>

          /*Configure the FIFO trigger limit based on the required data size*/
          UART_lReconfigureRxFIFO(handle, count);
100028f8:	68fa      	ldr	r2, [r7, #12]
100028fa:	687b      	ldr	r3, [r7, #4]
100028fc:	1c10      	adds	r0, r2, #0
100028fe:	1c19      	adds	r1, r3, #0
10002900:	f000 f93e 	bl	10002b80 <UART_lReconfigureRxFIFO>

          XMC_USIC_CH_RXFIFO_EnableEvent(handle->channel,
10002904:	68fb      	ldr	r3, [r7, #12]
10002906:	681a      	ldr	r2, [r3, #0]
10002908:	23c0      	movs	r3, #192	; 0xc0
1000290a:	05db      	lsls	r3, r3, #23
1000290c:	1c10      	adds	r0, r2, #0
1000290e:	1c19      	adds	r1, r3, #0
10002910:	f7ff ff30 	bl	10002774 <XMC_USIC_CH_RXFIFO_EnableEvent>
10002914:	e007      	b.n	10002926 <UART_StartReceiveIRQ+0xa6>
            (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
            (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
        }
        else
        {
          XMC_USIC_CH_EnableEvent(handle->channel,
10002916:	68fb      	ldr	r3, [r7, #12]
10002918:	681a      	ldr	r2, [r3, #0]
1000291a:	23c0      	movs	r3, #192	; 0xc0
1000291c:	021b      	lsls	r3, r3, #8
1000291e:	1c10      	adds	r0, r2, #0
10002920:	1c19      	adds	r1, r3, #0
10002922:	f7ff fec3 	bl	100026ac <XMC_USIC_CH_EnableEvent>
          (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE));
        }
        ret_stat = UART_STATUS_SUCCESS;
10002926:	2317      	movs	r3, #23
10002928:	18fb      	adds	r3, r7, r3
1000292a:	2200      	movs	r2, #0
1000292c:	701a      	strb	r2, [r3, #0]
1000292e:	e003      	b.n	10002938 <UART_StartReceiveIRQ+0xb8>
      }
      else
      {
        ret_stat = UART_STATUS_BUFFER_INVALID;
10002930:	2317      	movs	r3, #23
10002932:	18fb      	adds	r3, r7, r3
10002934:	2203      	movs	r2, #3
10002936:	701a      	strb	r2, [r3, #0]
      }
    }
  }
  return ret_stat;
10002938:	2317      	movs	r3, #23
1000293a:	18fb      	adds	r3, r7, r3
1000293c:	781b      	ldrb	r3, [r3, #0]
}
1000293e:	1c18      	adds	r0, r3, #0
10002940:	46bd      	mov	sp, r7
10002942:	b006      	add	sp, #24
10002944:	bd80      	pop	{r7, pc}
10002946:	46c0      	nop			; (mov r8, r8)

10002948 <UART_lTransmitHandler>:
 *  * param[in]  handle UART APP handle pointer of type UART_t*
 *
 *  * return void
 */
void UART_lTransmitHandler(const UART_t * const handle)
{
10002948:	b580      	push	{r7, lr}
1000294a:	b084      	sub	sp, #16
1000294c:	af00      	add	r7, sp, #0
1000294e:	6078      	str	r0, [r7, #4]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
10002950:	687b      	ldr	r3, [r7, #4]
10002952:	689b      	ldr	r3, [r3, #8]
10002954:	60fb      	str	r3, [r7, #12]

  if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
10002956:	68fb      	ldr	r3, [r7, #12]
10002958:	68da      	ldr	r2, [r3, #12]
1000295a:	68fb      	ldr	r3, [r7, #12]
1000295c:	689b      	ldr	r3, [r3, #8]
1000295e:	429a      	cmp	r2, r3
10002960:	d241      	bcs.n	100029e6 <UART_lTransmitHandler+0x9e>
  {
    if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10002962:	687b      	ldr	r3, [r7, #4]
10002964:	685b      	ldr	r3, [r3, #4]
10002966:	222b      	movs	r2, #43	; 0x2b
10002968:	5c9b      	ldrb	r3, [r3, r2]
1000296a:	2b00      	cmp	r3, #0
1000296c:	d028      	beq.n	100029c0 <UART_lTransmitHandler+0x78>
    {
      /*When Transmit FIFO is enabled*/
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
1000296e:	e01a      	b.n	100029a6 <UART_lTransmitHandler+0x5e>
      {
        if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
10002970:	68fb      	ldr	r3, [r7, #12]
10002972:	68da      	ldr	r2, [r3, #12]
10002974:	68fb      	ldr	r3, [r7, #12]
10002976:	689b      	ldr	r3, [r3, #8]
10002978:	429a      	cmp	r2, r3
1000297a:	d212      	bcs.n	100029a2 <UART_lTransmitHandler+0x5a>
        {
          /*Load the FIFO byte by byte till either FIFO is full or all data is loaded*/
          XMC_UART_CH_Transmit(handle->channel,(uint16_t)ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
1000297c:	687b      	ldr	r3, [r7, #4]
1000297e:	6819      	ldr	r1, [r3, #0]
10002980:	68fb      	ldr	r3, [r7, #12]
10002982:	681a      	ldr	r2, [r3, #0]
10002984:	68fb      	ldr	r3, [r7, #12]
10002986:	68db      	ldr	r3, [r3, #12]
10002988:	18d3      	adds	r3, r2, r3
1000298a:	781b      	ldrb	r3, [r3, #0]
1000298c:	b29b      	uxth	r3, r3
1000298e:	1c08      	adds	r0, r1, #0
10002990:	1c19      	adds	r1, r3, #0
10002992:	f7ff fbbb 	bl	1000210c <XMC_UART_CH_Transmit>
          (ptr_runtime->tx_data_index)++;
10002996:	68fb      	ldr	r3, [r7, #12]
10002998:	68db      	ldr	r3, [r3, #12]
1000299a:	1c5a      	adds	r2, r3, #1
1000299c:	68fb      	ldr	r3, [r7, #12]
1000299e:	60da      	str	r2, [r3, #12]
100029a0:	e001      	b.n	100029a6 <UART_lTransmitHandler+0x5e>
        }
        else
        {
          break;
100029a2:	46c0      	nop			; (mov r8, r8)
100029a4:	e055      	b.n	10002a52 <UART_lTransmitHandler+0x10a>
  {
    if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      /*When Transmit FIFO is enabled*/
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
100029a6:	687b      	ldr	r3, [r7, #4]
100029a8:	681b      	ldr	r3, [r3, #0]
100029aa:	1c18      	adds	r0, r3, #0
100029ac:	f7ff febe 	bl	1000272c <XMC_USIC_CH_TXFIFO_IsFull>
100029b0:	1c03      	adds	r3, r0, #0
100029b2:	1c1a      	adds	r2, r3, #0
100029b4:	2301      	movs	r3, #1
100029b6:	4053      	eors	r3, r2
100029b8:	b2db      	uxtb	r3, r3
100029ba:	2b00      	cmp	r3, #0
100029bc:	d1d8      	bne.n	10002970 <UART_lTransmitHandler+0x28>
100029be:	e048      	b.n	10002a52 <UART_lTransmitHandler+0x10a>
      }
    }
    else
    {
      /*When Transmit FIFO is disabled*/
      XMC_UART_CH_Transmit(handle->channel,(uint16_t)ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
100029c0:	687b      	ldr	r3, [r7, #4]
100029c2:	6819      	ldr	r1, [r3, #0]
100029c4:	68fb      	ldr	r3, [r7, #12]
100029c6:	681a      	ldr	r2, [r3, #0]
100029c8:	68fb      	ldr	r3, [r7, #12]
100029ca:	68db      	ldr	r3, [r3, #12]
100029cc:	18d3      	adds	r3, r2, r3
100029ce:	781b      	ldrb	r3, [r3, #0]
100029d0:	b29b      	uxth	r3, r3
100029d2:	1c08      	adds	r0, r1, #0
100029d4:	1c19      	adds	r1, r3, #0
100029d6:	f7ff fb99 	bl	1000210c <XMC_UART_CH_Transmit>
      (ptr_runtime->tx_data_index)++;
100029da:	68fb      	ldr	r3, [r7, #12]
100029dc:	68db      	ldr	r3, [r3, #12]
100029de:	1c5a      	adds	r2, r3, #1
100029e0:	68fb      	ldr	r3, [r7, #12]
100029e2:	60da      	str	r2, [r3, #12]
100029e4:	e035      	b.n	10002a52 <UART_lTransmitHandler+0x10a>
    }
  }
  else
  {
    if (XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel) == true)
100029e6:	687b      	ldr	r3, [r7, #4]
100029e8:	681b      	ldr	r3, [r3, #0]
100029ea:	1c18      	adds	r0, r3, #0
100029ec:	f7ff feb0 	bl	10002750 <XMC_USIC_CH_TXFIFO_IsEmpty>
100029f0:	1e03      	subs	r3, r0, #0
100029f2:	d02e      	beq.n	10002a52 <UART_lTransmitHandler+0x10a>
    {
      if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
100029f4:	687b      	ldr	r3, [r7, #4]
100029f6:	685b      	ldr	r3, [r3, #4]
100029f8:	222b      	movs	r2, #43	; 0x2b
100029fa:	5c9b      	ldrb	r3, [r3, r2]
100029fc:	2b00      	cmp	r3, #0
100029fe:	d008      	beq.n	10002a12 <UART_lTransmitHandler+0xca>
      {
        /*Disable the transmit FIFO event*/
        XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
10002a00:	687b      	ldr	r3, [r7, #4]
10002a02:	681a      	ldr	r2, [r3, #0]
10002a04:	2380      	movs	r3, #128	; 0x80
10002a06:	05db      	lsls	r3, r3, #23
10002a08:	1c10      	adds	r0, r2, #0
10002a0a:	1c19      	adds	r1, r3, #0
10002a0c:	f7ff fe7a 	bl	10002704 <XMC_USIC_CH_TXFIFO_DisableEvent>
10002a10:	e007      	b.n	10002a22 <UART_lTransmitHandler+0xda>
      }
      else
      {
        /*Disable the standard transmit event*/
        XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
10002a12:	687b      	ldr	r3, [r7, #4]
10002a14:	681a      	ldr	r2, [r3, #0]
10002a16:	2380      	movs	r3, #128	; 0x80
10002a18:	019b      	lsls	r3, r3, #6
10002a1a:	1c10      	adds	r0, r2, #0
10002a1c:	1c19      	adds	r1, r3, #0
10002a1e:	f7ff fe53 	bl	100026c8 <XMC_USIC_CH_DisableEvent>
      }

      /*Wait for the transmit buffer to be free to ensure that all data is transmitted*/
      while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
10002a22:	46c0      	nop			; (mov r8, r8)
10002a24:	687b      	ldr	r3, [r7, #4]
10002a26:	681b      	ldr	r3, [r3, #0]
10002a28:	1c18      	adds	r0, r3, #0
10002a2a:	f7ff fe5d 	bl	100026e8 <XMC_USIC_CH_GetTransmitBufferStatus>
10002a2e:	1e03      	subs	r3, r0, #0
10002a30:	2b80      	cmp	r3, #128	; 0x80
10002a32:	d0f7      	beq.n	10002a24 <UART_lTransmitHandler+0xdc>
      {

      }
      /*All data is transmitted*/
      ptr_runtime->tx_busy = false;
10002a34:	68fb      	ldr	r3, [r7, #12]
10002a36:	2200      	movs	r2, #0
10002a38:	761a      	strb	r2, [r3, #24]
      ptr_runtime->tx_data = NULL;
10002a3a:	68fb      	ldr	r3, [r7, #12]
10002a3c:	2200      	movs	r2, #0
10002a3e:	601a      	str	r2, [r3, #0]

      if (handle->config->tx_cbhandler != NULL)
10002a40:	687b      	ldr	r3, [r7, #4]
10002a42:	685b      	ldr	r3, [r3, #4]
10002a44:	689b      	ldr	r3, [r3, #8]
10002a46:	2b00      	cmp	r3, #0
10002a48:	d003      	beq.n	10002a52 <UART_lTransmitHandler+0x10a>
      {
        /*Execute the callback function provided in the UART APP UI*/
        handle->config->tx_cbhandler();
10002a4a:	687b      	ldr	r3, [r7, #4]
10002a4c:	685b      	ldr	r3, [r3, #4]
10002a4e:	689b      	ldr	r3, [r3, #8]
10002a50:	4798      	blx	r3
      }
    }
  }
}
10002a52:	46bd      	mov	sp, r7
10002a54:	b004      	add	sp, #16
10002a56:	bd80      	pop	{r7, pc}

10002a58 <UART_lReceiveHandler>:
 * param[in]  handle UART APP handle pointer of type UART_t*
 *
 * return void
 */
void UART_lReceiveHandler(const UART_t * const handle)
{
10002a58:	b590      	push	{r4, r7, lr}
10002a5a:	b085      	sub	sp, #20
10002a5c:	af00      	add	r7, sp, #0
10002a5e:	6078      	str	r0, [r7, #4]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
10002a60:	687b      	ldr	r3, [r7, #4]
10002a62:	689b      	ldr	r3, [r3, #8]
10002a64:	60fb      	str	r3, [r7, #12]

  if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10002a66:	687b      	ldr	r3, [r7, #4]
10002a68:	685b      	ldr	r3, [r3, #4]
10002a6a:	222c      	movs	r2, #44	; 0x2c
10002a6c:	5c9b      	ldrb	r3, [r3, r2]
10002a6e:	2b00      	cmp	r3, #0
10002a70:	d051      	beq.n	10002b16 <UART_lReceiveHandler+0xbe>
  {
    /*When Receive FIFO is enabled*/
    while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
10002a72:	e033      	b.n	10002adc <UART_lReceiveHandler+0x84>
    {
      if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
10002a74:	68fb      	ldr	r3, [r7, #12]
10002a76:	695a      	ldr	r2, [r3, #20]
10002a78:	68fb      	ldr	r3, [r7, #12]
10002a7a:	691b      	ldr	r3, [r3, #16]
10002a7c:	429a      	cmp	r2, r3
10002a7e:	d211      	bcs.n	10002aa4 <UART_lReceiveHandler+0x4c>
      {
        /*Read all the content of Receive FIFO */
        ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)XMC_UART_CH_GetReceivedData(handle->channel);
10002a80:	68fb      	ldr	r3, [r7, #12]
10002a82:	685a      	ldr	r2, [r3, #4]
10002a84:	68fb      	ldr	r3, [r7, #12]
10002a86:	695b      	ldr	r3, [r3, #20]
10002a88:	18d4      	adds	r4, r2, r3
10002a8a:	687b      	ldr	r3, [r7, #4]
10002a8c:	681b      	ldr	r3, [r3, #0]
10002a8e:	1c18      	adds	r0, r3, #0
10002a90:	f7ff fb6a 	bl	10002168 <XMC_UART_CH_GetReceivedData>
10002a94:	1c03      	adds	r3, r0, #0
10002a96:	b2db      	uxtb	r3, r3
10002a98:	7023      	strb	r3, [r4, #0]
        (ptr_runtime->rx_data_index)++;
10002a9a:	68fb      	ldr	r3, [r7, #12]
10002a9c:	695b      	ldr	r3, [r3, #20]
10002a9e:	1c5a      	adds	r2, r3, #1
10002aa0:	68fb      	ldr	r3, [r7, #12]
10002aa2:	615a      	str	r2, [r3, #20]
      }

      if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
10002aa4:	68fb      	ldr	r3, [r7, #12]
10002aa6:	695a      	ldr	r2, [r3, #20]
10002aa8:	68fb      	ldr	r3, [r7, #12]
10002aaa:	691b      	ldr	r3, [r3, #16]
10002aac:	429a      	cmp	r2, r3
10002aae:	d115      	bne.n	10002adc <UART_lReceiveHandler+0x84>
      {
        /*Reception complete*/
        ptr_runtime->rx_busy = false;
10002ab0:	68fb      	ldr	r3, [r7, #12]
10002ab2:	2200      	movs	r2, #0
10002ab4:	765a      	strb	r2, [r3, #25]
        /*Disable both standard receive and alternative receive FIFO events*/
        XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
10002ab6:	687b      	ldr	r3, [r7, #4]
10002ab8:	681a      	ldr	r2, [r3, #0]
10002aba:	23c0      	movs	r3, #192	; 0xc0
10002abc:	05db      	lsls	r3, r3, #23
10002abe:	1c10      	adds	r0, r2, #0
10002ac0:	1c19      	adds	r1, r3, #0
10002ac2:	f7ff fe6b 	bl	1000279c <XMC_USIC_CH_RXFIFO_DisableEvent>
            (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
            (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
        if (handle->config->rx_cbhandler != NULL)
10002ac6:	687b      	ldr	r3, [r7, #4]
10002ac8:	685b      	ldr	r3, [r3, #4]
10002aca:	68db      	ldr	r3, [r3, #12]
10002acc:	2b00      	cmp	r3, #0
10002ace:	d004      	beq.n	10002ada <UART_lReceiveHandler+0x82>
        {
          /*Execute the 'End of reception' callback function*/
          handle->config->rx_cbhandler();
10002ad0:	687b      	ldr	r3, [r7, #4]
10002ad2:	685b      	ldr	r3, [r3, #4]
10002ad4:	68db      	ldr	r3, [r3, #12]
10002ad6:	4798      	blx	r3
        }
        break;
10002ad8:	e00c      	b.n	10002af4 <UART_lReceiveHandler+0x9c>
10002ada:	e00b      	b.n	10002af4 <UART_lReceiveHandler+0x9c>
  UART_RUNTIME_t * ptr_runtime = handle->runtime;

  if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    /*When Receive FIFO is enabled*/
    while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
10002adc:	687b      	ldr	r3, [r7, #4]
10002ade:	681b      	ldr	r3, [r3, #0]
10002ae0:	1c18      	adds	r0, r3, #0
10002ae2:	f7ff fe7d 	bl	100027e0 <XMC_USIC_CH_RXFIFO_IsEmpty>
10002ae6:	1c03      	adds	r3, r0, #0
10002ae8:	1c1a      	adds	r2, r3, #0
10002aea:	2301      	movs	r3, #1
10002aec:	4053      	eors	r3, r2
10002aee:	b2db      	uxtb	r3, r3
10002af0:	2b00      	cmp	r3, #0
10002af2:	d1bf      	bne.n	10002a74 <UART_lReceiveHandler+0x1c>
        }
        break;
      }
    }
    /*Set the trigger limit if data still to be received*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
10002af4:	68fb      	ldr	r3, [r7, #12]
10002af6:	695a      	ldr	r2, [r3, #20]
10002af8:	68fb      	ldr	r3, [r7, #12]
10002afa:	691b      	ldr	r3, [r3, #16]
10002afc:	429a      	cmp	r2, r3
10002afe:	d23c      	bcs.n	10002b7a <UART_lReceiveHandler+0x122>
    {
      UART_lReconfigureRxFIFO(handle,
          (uint32_t)(ptr_runtime->rx_data_count - ptr_runtime->rx_data_index));
10002b00:	68fb      	ldr	r3, [r7, #12]
10002b02:	691a      	ldr	r2, [r3, #16]
10002b04:	68fb      	ldr	r3, [r7, #12]
10002b06:	695b      	ldr	r3, [r3, #20]
      }
    }
    /*Set the trigger limit if data still to be received*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
    {
      UART_lReconfigureRxFIFO(handle,
10002b08:	1ad3      	subs	r3, r2, r3
10002b0a:	687a      	ldr	r2, [r7, #4]
10002b0c:	1c10      	adds	r0, r2, #0
10002b0e:	1c19      	adds	r1, r3, #0
10002b10:	f000 f836 	bl	10002b80 <UART_lReconfigureRxFIFO>
10002b14:	e031      	b.n	10002b7a <UART_lReceiveHandler+0x122>
    }
  }
  else
  {
    /*When RxFIFO is disabled*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
10002b16:	68fb      	ldr	r3, [r7, #12]
10002b18:	695a      	ldr	r2, [r3, #20]
10002b1a:	68fb      	ldr	r3, [r7, #12]
10002b1c:	691b      	ldr	r3, [r3, #16]
10002b1e:	429a      	cmp	r2, r3
10002b20:	d211      	bcs.n	10002b46 <UART_lReceiveHandler+0xee>
    {
      ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)XMC_UART_CH_GetReceivedData(handle->channel);
10002b22:	68fb      	ldr	r3, [r7, #12]
10002b24:	685a      	ldr	r2, [r3, #4]
10002b26:	68fb      	ldr	r3, [r7, #12]
10002b28:	695b      	ldr	r3, [r3, #20]
10002b2a:	18d4      	adds	r4, r2, r3
10002b2c:	687b      	ldr	r3, [r7, #4]
10002b2e:	681b      	ldr	r3, [r3, #0]
10002b30:	1c18      	adds	r0, r3, #0
10002b32:	f7ff fb19 	bl	10002168 <XMC_UART_CH_GetReceivedData>
10002b36:	1c03      	adds	r3, r0, #0
10002b38:	b2db      	uxtb	r3, r3
10002b3a:	7023      	strb	r3, [r4, #0]
      (ptr_runtime->rx_data_index)++;
10002b3c:	68fb      	ldr	r3, [r7, #12]
10002b3e:	695b      	ldr	r3, [r3, #20]
10002b40:	1c5a      	adds	r2, r3, #1
10002b42:	68fb      	ldr	r3, [r7, #12]
10002b44:	615a      	str	r2, [r3, #20]
    }

    if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
10002b46:	68fb      	ldr	r3, [r7, #12]
10002b48:	695a      	ldr	r2, [r3, #20]
10002b4a:	68fb      	ldr	r3, [r7, #12]
10002b4c:	691b      	ldr	r3, [r3, #16]
10002b4e:	429a      	cmp	r2, r3
10002b50:	d113      	bne.n	10002b7a <UART_lReceiveHandler+0x122>
    {
      /*Reception complete*/
      ptr_runtime->rx_busy = false;
10002b52:	68fb      	ldr	r3, [r7, #12]
10002b54:	2200      	movs	r2, #0
10002b56:	765a      	strb	r2, [r3, #25]
      /*Disable both standard receive and alternative receive FIFO events*/
      XMC_USIC_CH_DisableEvent(handle->channel,
10002b58:	687b      	ldr	r3, [r7, #4]
10002b5a:	681a      	ldr	r2, [r3, #0]
10002b5c:	23c0      	movs	r3, #192	; 0xc0
10002b5e:	021b      	lsls	r3, r3, #8
10002b60:	1c10      	adds	r0, r2, #0
10002b62:	1c19      	adds	r1, r3, #0
10002b64:	f7ff fdb0 	bl	100026c8 <XMC_USIC_CH_DisableEvent>
          (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE | (uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE));

      if (handle->config->rx_cbhandler != NULL)
10002b68:	687b      	ldr	r3, [r7, #4]
10002b6a:	685b      	ldr	r3, [r3, #4]
10002b6c:	68db      	ldr	r3, [r3, #12]
10002b6e:	2b00      	cmp	r3, #0
10002b70:	d003      	beq.n	10002b7a <UART_lReceiveHandler+0x122>
      {
        /*Execute the 'End of reception' callback function*/
        handle->config->rx_cbhandler();
10002b72:	687b      	ldr	r3, [r7, #4]
10002b74:	685b      	ldr	r3, [r3, #4]
10002b76:	68db      	ldr	r3, [r3, #12]
10002b78:	4798      	blx	r3
      }
    }
  }
}
10002b7a:	46bd      	mov	sp, r7
10002b7c:	b005      	add	sp, #20
10002b7e:	bd90      	pop	{r4, r7, pc}

10002b80 <UART_lReconfigureRxFIFO>:
 * param[in] uint8_t  number of bytes to be received.
 *
 * return void.
 */
static void UART_lReconfigureRxFIFO(const UART_t * const handle, uint32_t data_size)
{
10002b80:	b580      	push	{r7, lr}
10002b82:	b084      	sub	sp, #16
10002b84:	af00      	add	r7, sp, #0
10002b86:	6078      	str	r0, [r7, #4]
10002b88:	6039      	str	r1, [r7, #0]
  uint32_t fifo_size;
  uint32_t ret_limit_val = 0U;
10002b8a:	2300      	movs	r3, #0
10002b8c:	60fb      	str	r3, [r7, #12]

  /*Get FIFO size in bytes*/
  fifo_size = (uint32_t)(0x01UL << (uint8_t)(handle->config->rx_fifo_size));
10002b8e:	687b      	ldr	r3, [r7, #4]
10002b90:	685b      	ldr	r3, [r3, #4]
10002b92:	222c      	movs	r2, #44	; 0x2c
10002b94:	5c9b      	ldrb	r3, [r3, r2]
10002b96:	1c1a      	adds	r2, r3, #0
10002b98:	2301      	movs	r3, #1
10002b9a:	4093      	lsls	r3, r2
10002b9c:	60bb      	str	r3, [r7, #8]
  /*If data size is more than FIFO size, configure the limit to the FIFO size*/
  if (data_size < fifo_size)
10002b9e:	683a      	ldr	r2, [r7, #0]
10002ba0:	68bb      	ldr	r3, [r7, #8]
10002ba2:	429a      	cmp	r2, r3
10002ba4:	d203      	bcs.n	10002bae <UART_lReconfigureRxFIFO+0x2e>
  {
    ret_limit_val = (uint32_t)(data_size - 1U);
10002ba6:	683b      	ldr	r3, [r7, #0]
10002ba8:	3b01      	subs	r3, #1
10002baa:	60fb      	str	r3, [r7, #12]
10002bac:	e002      	b.n	10002bb4 <UART_lReconfigureRxFIFO+0x34>
  }
  else
  {
    ret_limit_val = (uint32_t)(fifo_size - 1U);
10002bae:	68bb      	ldr	r3, [r7, #8]
10002bb0:	3b01      	subs	r3, #1
10002bb2:	60fb      	str	r3, [r7, #12]
  }
  /*Set the limit value*/
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel,
10002bb4:	687b      	ldr	r3, [r7, #4]
10002bb6:	6819      	ldr	r1, [r3, #0]
        handle->config->rx_fifo_size, ret_limit_val);
10002bb8:	687b      	ldr	r3, [r7, #4]
10002bba:	685b      	ldr	r3, [r3, #4]
  else
  {
    ret_limit_val = (uint32_t)(fifo_size - 1U);
  }
  /*Set the limit value*/
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel,
10002bbc:	222c      	movs	r2, #44	; 0x2c
10002bbe:	5c9a      	ldrb	r2, [r3, r2]
10002bc0:	68fb      	ldr	r3, [r7, #12]
10002bc2:	1c08      	adds	r0, r1, #0
10002bc4:	1c11      	adds	r1, r2, #0
10002bc6:	1c1a      	adds	r2, r3, #0
10002bc8:	f7ff fc8a 	bl	100024e0 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit>
        handle->config->rx_fifo_size, ret_limit_val);
}
10002bcc:	46bd      	mov	sp, r7
10002bce:	b004      	add	sp, #16
10002bd0:	bd80      	pop	{r7, pc}
10002bd2:	46c0      	nop			; (mov r8, r8)

10002bd4 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
10002bd4:	b580      	push	{r7, lr}
10002bd6:	b082      	sub	sp, #8
10002bd8:	af00      	add	r7, sp, #0
10002bda:	1c02      	adds	r2, r0, #0
10002bdc:	1dfb      	adds	r3, r7, #7
10002bde:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10002be0:	1dfb      	adds	r3, r7, #7
10002be2:	781b      	ldrb	r3, [r3, #0]
10002be4:	2b7f      	cmp	r3, #127	; 0x7f
10002be6:	d809      	bhi.n	10002bfc <__NVIC_EnableIRQ+0x28>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
10002be8:	4b06      	ldr	r3, [pc, #24]	; (10002c04 <__NVIC_EnableIRQ+0x30>)
10002bea:	1dfa      	adds	r2, r7, #7
10002bec:	7812      	ldrb	r2, [r2, #0]
10002bee:	1c11      	adds	r1, r2, #0
10002bf0:	221f      	movs	r2, #31
10002bf2:	400a      	ands	r2, r1
10002bf4:	2101      	movs	r1, #1
10002bf6:	4091      	lsls	r1, r2
10002bf8:	1c0a      	adds	r2, r1, #0
10002bfa:	601a      	str	r2, [r3, #0]
    __COMPILER_BARRIER();
  }
}
10002bfc:	46bd      	mov	sp, r7
10002bfe:	b002      	add	sp, #8
10002c00:	bd80      	pop	{r7, pc}
10002c02:	46c0      	nop			; (mov r8, r8)
10002c04:	e000e100 	.word	0xe000e100

10002c08 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
10002c08:	b5b0      	push	{r4, r5, r7, lr}
10002c0a:	b082      	sub	sp, #8
10002c0c:	af00      	add	r7, sp, #0
10002c0e:	1c02      	adds	r2, r0, #0
10002c10:	6039      	str	r1, [r7, #0]
10002c12:	1dfb      	adds	r3, r7, #7
10002c14:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10002c16:	1dfb      	adds	r3, r7, #7
10002c18:	781b      	ldrb	r3, [r3, #0]
10002c1a:	2b7f      	cmp	r3, #127	; 0x7f
10002c1c:	d827      	bhi.n	10002c6e <__NVIC_SetPriority+0x66>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002c1e:	4c2d      	ldr	r4, [pc, #180]	; (10002cd4 <__NVIC_SetPriority+0xcc>)
10002c20:	1dfb      	adds	r3, r7, #7
10002c22:	781b      	ldrb	r3, [r3, #0]
10002c24:	b25b      	sxtb	r3, r3
10002c26:	089b      	lsrs	r3, r3, #2
10002c28:	492a      	ldr	r1, [pc, #168]	; (10002cd4 <__NVIC_SetPriority+0xcc>)
10002c2a:	1dfa      	adds	r2, r7, #7
10002c2c:	7812      	ldrb	r2, [r2, #0]
10002c2e:	b252      	sxtb	r2, r2
10002c30:	0892      	lsrs	r2, r2, #2
10002c32:	32c0      	adds	r2, #192	; 0xc0
10002c34:	0092      	lsls	r2, r2, #2
10002c36:	5852      	ldr	r2, [r2, r1]
10002c38:	1df9      	adds	r1, r7, #7
10002c3a:	7809      	ldrb	r1, [r1, #0]
10002c3c:	1c08      	adds	r0, r1, #0
10002c3e:	2103      	movs	r1, #3
10002c40:	4001      	ands	r1, r0
10002c42:	00c9      	lsls	r1, r1, #3
10002c44:	1c08      	adds	r0, r1, #0
10002c46:	21ff      	movs	r1, #255	; 0xff
10002c48:	4081      	lsls	r1, r0
10002c4a:	43c9      	mvns	r1, r1
10002c4c:	4011      	ands	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10002c4e:	683a      	ldr	r2, [r7, #0]
10002c50:	0192      	lsls	r2, r2, #6
10002c52:	20ff      	movs	r0, #255	; 0xff
10002c54:	4002      	ands	r2, r0
10002c56:	1df8      	adds	r0, r7, #7
10002c58:	7800      	ldrb	r0, [r0, #0]
10002c5a:	1c05      	adds	r5, r0, #0
10002c5c:	2003      	movs	r0, #3
10002c5e:	4028      	ands	r0, r5
10002c60:	00c0      	lsls	r0, r0, #3
10002c62:	4082      	lsls	r2, r0
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002c64:	430a      	orrs	r2, r1
10002c66:	33c0      	adds	r3, #192	; 0xc0
10002c68:	009b      	lsls	r3, r3, #2
10002c6a:	511a      	str	r2, [r3, r4]
10002c6c:	e02e      	b.n	10002ccc <__NVIC_SetPriority+0xc4>
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002c6e:	4c1a      	ldr	r4, [pc, #104]	; (10002cd8 <__NVIC_SetPriority+0xd0>)
10002c70:	1dfb      	adds	r3, r7, #7
10002c72:	781b      	ldrb	r3, [r3, #0]
10002c74:	1c1a      	adds	r2, r3, #0
10002c76:	230f      	movs	r3, #15
10002c78:	4013      	ands	r3, r2
10002c7a:	3b08      	subs	r3, #8
10002c7c:	0899      	lsrs	r1, r3, #2
10002c7e:	4a16      	ldr	r2, [pc, #88]	; (10002cd8 <__NVIC_SetPriority+0xd0>)
10002c80:	1dfb      	adds	r3, r7, #7
10002c82:	781b      	ldrb	r3, [r3, #0]
10002c84:	1c18      	adds	r0, r3, #0
10002c86:	230f      	movs	r3, #15
10002c88:	4003      	ands	r3, r0
10002c8a:	3b08      	subs	r3, #8
10002c8c:	089b      	lsrs	r3, r3, #2
10002c8e:	3306      	adds	r3, #6
10002c90:	009b      	lsls	r3, r3, #2
10002c92:	18d3      	adds	r3, r2, r3
10002c94:	685b      	ldr	r3, [r3, #4]
10002c96:	1dfa      	adds	r2, r7, #7
10002c98:	7812      	ldrb	r2, [r2, #0]
10002c9a:	1c10      	adds	r0, r2, #0
10002c9c:	2203      	movs	r2, #3
10002c9e:	4002      	ands	r2, r0
10002ca0:	00d2      	lsls	r2, r2, #3
10002ca2:	1c10      	adds	r0, r2, #0
10002ca4:	22ff      	movs	r2, #255	; 0xff
10002ca6:	4082      	lsls	r2, r0
10002ca8:	43d2      	mvns	r2, r2
10002caa:	401a      	ands	r2, r3
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10002cac:	683b      	ldr	r3, [r7, #0]
10002cae:	019b      	lsls	r3, r3, #6
10002cb0:	20ff      	movs	r0, #255	; 0xff
10002cb2:	4003      	ands	r3, r0
10002cb4:	1df8      	adds	r0, r7, #7
10002cb6:	7800      	ldrb	r0, [r0, #0]
10002cb8:	1c05      	adds	r5, r0, #0
10002cba:	2003      	movs	r0, #3
10002cbc:	4028      	ands	r0, r5
10002cbe:	00c0      	lsls	r0, r0, #3
10002cc0:	4083      	lsls	r3, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002cc2:	431a      	orrs	r2, r3
10002cc4:	1d8b      	adds	r3, r1, #6
10002cc6:	009b      	lsls	r3, r3, #2
10002cc8:	18e3      	adds	r3, r4, r3
10002cca:	605a      	str	r2, [r3, #4]
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
10002ccc:	46bd      	mov	sp, r7
10002cce:	b002      	add	sp, #8
10002cd0:	bdb0      	pop	{r4, r5, r7, pc}
10002cd2:	46c0      	nop			; (mov r8, r8)
10002cd4:	e000e100 	.word	0xe000e100
10002cd8:	e000ed00 	.word	0xe000ed00

10002cdc <XMC_USIC_CH_SetInputSource>:
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
10002cdc:	b580      	push	{r7, lr}
10002cde:	b082      	sub	sp, #8
10002ce0:	af00      	add	r7, sp, #0
10002ce2:	6078      	str	r0, [r7, #4]
10002ce4:	1c08      	adds	r0, r1, #0
10002ce6:	1c11      	adds	r1, r2, #0
10002ce8:	1cfb      	adds	r3, r7, #3
10002cea:	1c02      	adds	r2, r0, #0
10002cec:	701a      	strb	r2, [r3, #0]
10002cee:	1cbb      	adds	r3, r7, #2
10002cf0:	1c0a      	adds	r2, r1, #0
10002cf2:	701a      	strb	r2, [r3, #0]
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
10002cf4:	1cfb      	adds	r3, r7, #3
10002cf6:	7818      	ldrb	r0, [r3, #0]
10002cf8:	1cfb      	adds	r3, r7, #3
10002cfa:	781b      	ldrb	r3, [r3, #0]
10002cfc:	687a      	ldr	r2, [r7, #4]
10002cfe:	3306      	adds	r3, #6
10002d00:	009b      	lsls	r3, r3, #2
10002d02:	18d3      	adds	r3, r2, r3
10002d04:	685b      	ldr	r3, [r3, #4]
10002d06:	2207      	movs	r2, #7
10002d08:	4393      	bics	r3, r2
10002d0a:	1c1a      	adds	r2, r3, #0
                                    ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
10002d0c:	1cbb      	adds	r3, r7, #2
10002d0e:	781b      	ldrb	r3, [r3, #0]
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
10002d10:	431a      	orrs	r2, r3
10002d12:	6879      	ldr	r1, [r7, #4]
10002d14:	1d83      	adds	r3, r0, #6
10002d16:	009b      	lsls	r3, r3, #2
10002d18:	18cb      	adds	r3, r1, r3
10002d1a:	605a      	str	r2, [r3, #4]
                                    ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
}
10002d1c:	46bd      	mov	sp, r7
10002d1e:	b002      	add	sp, #8
10002d20:	bd80      	pop	{r7, pc}
10002d22:	46c0      	nop			; (mov r8, r8)

10002d24 <XMC_UART_CH_Init>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_Start(), XMC_UART_CH_Stop(), XMC_UART_CH_Transmit()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_Init(XMC_USIC_CH_t *const channel, const XMC_UART_CH_CONFIG_t *const config)
{
10002d24:	b580      	push	{r7, lr}
10002d26:	b082      	sub	sp, #8
10002d28:	af00      	add	r7, sp, #0
10002d2a:	6078      	str	r0, [r7, #4]
10002d2c:	6039      	str	r1, [r7, #0]
  XMC_UART_CH_InitEx(channel, config, true);
10002d2e:	687a      	ldr	r2, [r7, #4]
10002d30:	683b      	ldr	r3, [r7, #0]
10002d32:	1c10      	adds	r0, r2, #0
10002d34:	1c19      	adds	r1, r3, #0
10002d36:	2201      	movs	r2, #1
10002d38:	f7ff f97a 	bl	10002030 <XMC_UART_CH_InitEx>
}
10002d3c:	46bd      	mov	sp, r7
10002d3e:	b002      	add	sp, #8
10002d40:	bd80      	pop	{r7, pc}
10002d42:	46c0      	nop			; (mov r8, r8)

10002d44 <XMC_UART_CH_Start>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_Stop(), XMC_UART_CH_Transmit()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_Start(XMC_USIC_CH_t *const channel)
{
10002d44:	b580      	push	{r7, lr}
10002d46:	b082      	sub	sp, #8
10002d48:	af00      	add	r7, sp, #0
10002d4a:	6078      	str	r0, [r7, #4]
  channel->CCR = (uint32_t)(((channel->CCR) & (~USIC_CH_CCR_MODE_Msk)) | (uint32_t)XMC_USIC_CH_OPERATING_MODE_UART);
10002d4c:	687b      	ldr	r3, [r7, #4]
10002d4e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10002d50:	220f      	movs	r2, #15
10002d52:	4393      	bics	r3, r2
10002d54:	2202      	movs	r2, #2
10002d56:	431a      	orrs	r2, r3
10002d58:	687b      	ldr	r3, [r7, #4]
10002d5a:	641a      	str	r2, [r3, #64]	; 0x40
}
10002d5c:	46bd      	mov	sp, r7
10002d5e:	b002      	add	sp, #8
10002d60:	bd80      	pop	{r7, pc}
10002d62:	46c0      	nop			; (mov r8, r8)

10002d64 <UART_0_init>:
/**********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/
/*Channel initialization function*/
UART_STATUS_t UART_0_init()
{
10002d64:	b580      	push	{r7, lr}
10002d66:	b082      	sub	sp, #8
10002d68:	af00      	add	r7, sp, #0
  UART_STATUS_t status = UART_STATUS_SUCCESS;
10002d6a:	1dfb      	adds	r3, r7, #7
10002d6c:	2200      	movs	r2, #0
10002d6e:	701a      	strb	r2, [r3, #0]
  /*Configure Receive pin*/
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, 3U, &UART_0_rx_pin_config);
10002d70:	4a37      	ldr	r2, [pc, #220]	; (10002e50 <UART_0_init+0xec>)
10002d72:	4b38      	ldr	r3, [pc, #224]	; (10002e54 <UART_0_init+0xf0>)
10002d74:	1c10      	adds	r0, r2, #0
10002d76:	2103      	movs	r1, #3
10002d78:	1c1a      	adds	r2, r3, #0
10002d7a:	f7fe fa05 	bl	10001188 <XMC_GPIO_Init>
  /* Initialize USIC channel in UART mode*/
  XMC_UART_CH_Init(XMC_UART0_CH1, &UART_0_channel_config);
10002d7e:	4a36      	ldr	r2, [pc, #216]	; (10002e58 <UART_0_init+0xf4>)
10002d80:	4b36      	ldr	r3, [pc, #216]	; (10002e5c <UART_0_init+0xf8>)
10002d82:	1c10      	adds	r0, r2, #0
10002d84:	1c19      	adds	r1, r3, #0
10002d86:	f7ff ffcd 	bl	10002d24 <XMC_UART_CH_Init>
  /*Set input source path*/
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH1, XMC_USIC_CH_INPUT_DX0, 0U);
10002d8a:	4b33      	ldr	r3, [pc, #204]	; (10002e58 <UART_0_init+0xf4>)
10002d8c:	1c18      	adds	r0, r3, #0
10002d8e:	2100      	movs	r1, #0
10002d90:	2200      	movs	r2, #0
10002d92:	f7ff ffa3 	bl	10002cdc <XMC_USIC_CH_SetInputSource>
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH1, XMC_USIC_CH_INPUT_DX3, 0U);
10002d96:	4b30      	ldr	r3, [pc, #192]	; (10002e58 <UART_0_init+0xf4>)
10002d98:	1c18      	adds	r0, r3, #0
10002d9a:	2103      	movs	r1, #3
10002d9c:	2200      	movs	r2, #0
10002d9e:	f7ff ff9d 	bl	10002cdc <XMC_USIC_CH_SetInputSource>
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH1, XMC_USIC_CH_INPUT_DX5, 0U);
10002da2:	4b2d      	ldr	r3, [pc, #180]	; (10002e58 <UART_0_init+0xf4>)
10002da4:	1c18      	adds	r0, r3, #0
10002da6:	2105      	movs	r1, #5
10002da8:	2200      	movs	r2, #0
10002daa:	f7ff ff97 	bl	10002cdc <XMC_USIC_CH_SetInputSource>
  /*Configure transmit FIFO*/
  XMC_USIC_CH_TXFIFO_Configure(XMC_UART0_CH1,
10002dae:	4b2a      	ldr	r3, [pc, #168]	; (10002e58 <UART_0_init+0xf4>)
10002db0:	1c18      	adds	r0, r3, #0
10002db2:	2130      	movs	r1, #48	; 0x30
10002db4:	2204      	movs	r2, #4
10002db6:	2301      	movs	r3, #1
10002db8:	f7ff fb32 	bl	10002420 <XMC_USIC_CH_TXFIFO_Configure>
        48U,
        XMC_USIC_CH_FIFO_SIZE_16WORDS,
        1U);
  /*Configure receive FIFO*/
  XMC_USIC_CH_RXFIFO_Configure(XMC_UART0_CH1,
10002dbc:	4b26      	ldr	r3, [pc, #152]	; (10002e58 <UART_0_init+0xf4>)
10002dbe:	1c18      	adds	r0, r3, #0
10002dc0:	2120      	movs	r1, #32
10002dc2:	2204      	movs	r2, #4
10002dc4:	2300      	movs	r3, #0
10002dc6:	f7ff fb59 	bl	1000247c <XMC_USIC_CH_RXFIFO_Configure>
        32U,
        XMC_USIC_CH_FIFO_SIZE_16WORDS,
        0U);
  /* Start UART */
  XMC_UART_CH_Start(XMC_UART0_CH1);
10002dca:	4b23      	ldr	r3, [pc, #140]	; (10002e58 <UART_0_init+0xf4>)
10002dcc:	1c18      	adds	r0, r3, #0
10002dce:	f7ff ffb9 	bl	10002d44 <XMC_UART_CH_Start>

  /* Initialize UART TX pin */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, 2U, &UART_0_tx_pin_config);
10002dd2:	4a1f      	ldr	r2, [pc, #124]	; (10002e50 <UART_0_init+0xec>)
10002dd4:	4b22      	ldr	r3, [pc, #136]	; (10002e60 <UART_0_init+0xfc>)
10002dd6:	1c10      	adds	r0, r2, #0
10002dd8:	2102      	movs	r1, #2
10002dda:	1c1a      	adds	r2, r3, #0
10002ddc:	f7fe f9d4 	bl	10001188 <XMC_GPIO_Init>

  /*Set service request for UART protocol events*/
  XMC_USIC_CH_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL,
10002de0:	4b1d      	ldr	r3, [pc, #116]	; (10002e58 <UART_0_init+0xf4>)
10002de2:	1c18      	adds	r0, r3, #0
10002de4:	2110      	movs	r1, #16
10002de6:	2204      	movs	r2, #4
10002de8:	f7ff fb96 	bl	10002518 <XMC_USIC_CH_SetInterruptNodePointer>
     4U);
  /*Set service request for tx FIFO transmit interrupt*/
  XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
10002dec:	4b1a      	ldr	r3, [pc, #104]	; (10002e58 <UART_0_init+0xf4>)
10002dee:	1c18      	adds	r0, r3, #0
10002df0:	2110      	movs	r1, #16
10002df2:	2202      	movs	r2, #2
10002df4:	f7ff fbb0 	bl	10002558 <XMC_USIC_CH_TXFIFO_SetInterruptNodePointer>
      2U);
  /*Set service request for rx FIFO receive interrupt*/
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
10002df8:	4b17      	ldr	r3, [pc, #92]	; (10002e58 <UART_0_init+0xf4>)
10002dfa:	1c18      	adds	r0, r3, #0
10002dfc:	2110      	movs	r1, #16
10002dfe:	2200      	movs	r2, #0
10002e00:	f7ff fbce 	bl	100025a0 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
       0x0U);
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_UART0_CH1, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE,
10002e04:	4b14      	ldr	r3, [pc, #80]	; (10002e58 <UART_0_init+0xf4>)
10002e06:	1c18      	adds	r0, r3, #0
10002e08:	2113      	movs	r1, #19
10002e0a:	2200      	movs	r2, #0
10002e0c:	f7ff fbc8 	bl	100025a0 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
       0x0U);
  /*Set priority and enable NVIC node for transmit interrupt*/
  NVIC_SetPriority((IRQn_Type)11, 3U);
10002e10:	200b      	movs	r0, #11
10002e12:	2103      	movs	r1, #3
10002e14:	f7ff fef8 	bl	10002c08 <__NVIC_SetPriority>
  XMC_SCU_SetInterruptControl(11U, XMC_SCU_IRQCTRL_USIC0_SR2_IRQ11);
10002e18:	23b0      	movs	r3, #176	; 0xb0
10002e1a:	011b      	lsls	r3, r3, #4
10002e1c:	200b      	movs	r0, #11
10002e1e:	1c19      	adds	r1, r3, #0
10002e20:	f7fe fc2a 	bl	10001678 <XMC_SCU_SetInterruptControl>
  NVIC_EnableIRQ((IRQn_Type)11);
10002e24:	200b      	movs	r0, #11
10002e26:	f7ff fed5 	bl	10002bd4 <__NVIC_EnableIRQ>
  /*Set priority and enable NVIC node for receive interrupt*/
  NVIC_SetPriority((IRQn_Type)9, 3U);
10002e2a:	2009      	movs	r0, #9
10002e2c:	2103      	movs	r1, #3
10002e2e:	f7ff feeb 	bl	10002c08 <__NVIC_SetPriority>
  XMC_SCU_SetInterruptControl(9U, XMC_SCU_IRQCTRL_USIC0_SR0_IRQ9);
10002e32:	2390      	movs	r3, #144	; 0x90
10002e34:	011b      	lsls	r3, r3, #4
10002e36:	2009      	movs	r0, #9
10002e38:	1c19      	adds	r1, r3, #0
10002e3a:	f7fe fc1d 	bl	10001678 <XMC_SCU_SetInterruptControl>
  NVIC_EnableIRQ((IRQn_Type)9);
10002e3e:	2009      	movs	r0, #9
10002e40:	f7ff fec8 	bl	10002bd4 <__NVIC_EnableIRQ>
  return status;
10002e44:	1dfb      	adds	r3, r7, #7
10002e46:	781b      	ldrb	r3, [r3, #0]
}
10002e48:	1c18      	adds	r0, r3, #0
10002e4a:	46bd      	mov	sp, r7
10002e4c:	b002      	add	sp, #8
10002e4e:	bd80      	pop	{r7, pc}
10002e50:	40040100 	.word	0x40040100
10002e54:	100066fc 	.word	0x100066fc
10002e58:	48000200 	.word	0x48000200
10002e5c:	100066ac 	.word	0x100066ac
10002e60:	100066b8 	.word	0x100066b8

10002e64 <IRQ11_Handler>:
/*Interrupt handlers*/
/*Transmit ISR*/
void UART_0_TX_HANDLER()
{
10002e64:	b580      	push	{r7, lr}
10002e66:	af00      	add	r7, sp, #0
  UART_lTransmitHandler(&UART_0);
10002e68:	4b02      	ldr	r3, [pc, #8]	; (10002e74 <IRQ11_Handler+0x10>)
10002e6a:	1c18      	adds	r0, r3, #0
10002e6c:	f7ff fd6c 	bl	10002948 <UART_lTransmitHandler>
}
10002e70:	46bd      	mov	sp, r7
10002e72:	bd80      	pop	{r7, pc}
10002e74:	20000550 	.word	0x20000550

10002e78 <IRQ9_Handler>:

/*Receive ISR*/
void UART_0_RX_HANDLER()
{
10002e78:	b580      	push	{r7, lr}
10002e7a:	af00      	add	r7, sp, #0
  UART_lReceiveHandler(&UART_0);
10002e7c:	4b02      	ldr	r3, [pc, #8]	; (10002e88 <IRQ9_Handler+0x10>)
10002e7e:	1c18      	adds	r0, r3, #0
10002e80:	f7ff fdea 	bl	10002a58 <UART_lReceiveHandler>
}
10002e84:	46bd      	mov	sp, r7
10002e86:	bd80      	pop	{r7, pc}
10002e88:	20000550 	.word	0x20000550

10002e8c <XMC_USIC_CH_WriteToTBUFTCI>:
 * XMC_USIC_CH_WriteToTBUF() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_WriteToTBUFTCI(XMC_USIC_CH_t *const channel,
    const uint16_t data,
    const uint32_t transmit_control_information)
{
10002e8c:	b580      	push	{r7, lr}
10002e8e:	b084      	sub	sp, #16
10002e90:	af00      	add	r7, sp, #0
10002e92:	60f8      	str	r0, [r7, #12]
10002e94:	607a      	str	r2, [r7, #4]
10002e96:	230a      	movs	r3, #10
10002e98:	18fb      	adds	r3, r7, r3
10002e9a:	1c0a      	adds	r2, r1, #0
10002e9c:	801a      	strh	r2, [r3, #0]
  channel->TBUF[transmit_control_information] = data;
10002e9e:	230a      	movs	r3, #10
10002ea0:	18fb      	adds	r3, r7, r3
10002ea2:	8819      	ldrh	r1, [r3, #0]
10002ea4:	68fb      	ldr	r3, [r7, #12]
10002ea6:	687a      	ldr	r2, [r7, #4]
10002ea8:	3220      	adds	r2, #32
10002eaa:	0092      	lsls	r2, r2, #2
10002eac:	50d1      	str	r1, [r2, r3]
}
10002eae:	46bd      	mov	sp, r7
10002eb0:	b004      	add	sp, #16
10002eb2:	bd80      	pop	{r7, pc}

10002eb4 <XMC_USIC_CH_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10002eb4:	b580      	push	{r7, lr}
10002eb6:	b082      	sub	sp, #8
10002eb8:	af00      	add	r7, sp, #0
10002eba:	6078      	str	r0, [r7, #4]
10002ebc:	6039      	str	r1, [r7, #0]
  channel->CCR |= event;
10002ebe:	687b      	ldr	r3, [r7, #4]
10002ec0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
10002ec2:	683b      	ldr	r3, [r7, #0]
10002ec4:	431a      	orrs	r2, r3
10002ec6:	687b      	ldr	r3, [r7, #4]
10002ec8:	641a      	str	r2, [r3, #64]	; 0x40
}
10002eca:	46bd      	mov	sp, r7
10002ecc:	b002      	add	sp, #8
10002ece:	bd80      	pop	{r7, pc}

10002ed0 <XMC_USIC_CH_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
*/
__STATIC_INLINE void XMC_USIC_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10002ed0:	b580      	push	{r7, lr}
10002ed2:	b082      	sub	sp, #8
10002ed4:	af00      	add	r7, sp, #0
10002ed6:	6078      	str	r0, [r7, #4]
10002ed8:	6039      	str	r1, [r7, #0]
  channel->CCR &= (uint32_t)~event;
10002eda:	687b      	ldr	r3, [r7, #4]
10002edc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10002ede:	683a      	ldr	r2, [r7, #0]
10002ee0:	43d2      	mvns	r2, r2
10002ee2:	401a      	ands	r2, r3
10002ee4:	687b      	ldr	r3, [r7, #4]
10002ee6:	641a      	str	r2, [r3, #64]	; 0x40
}
10002ee8:	46bd      	mov	sp, r7
10002eea:	b002      	add	sp, #8
10002eec:	bd80      	pop	{r7, pc}
10002eee:	46c0      	nop			; (mov r8, r8)

10002ef0 <XMC_USIC_CH_GetTransmitBufferStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
10002ef0:	b580      	push	{r7, lr}
10002ef2:	b082      	sub	sp, #8
10002ef4:	af00      	add	r7, sp, #0
10002ef6:	6078      	str	r0, [r7, #4]
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
10002ef8:	687b      	ldr	r3, [r7, #4]
10002efa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10002efc:	b2db      	uxtb	r3, r3
10002efe:	227f      	movs	r2, #127	; 0x7f
10002f00:	4393      	bics	r3, r2
10002f02:	b2db      	uxtb	r3, r3
}
10002f04:	1c18      	adds	r0, r3, #0
10002f06:	46bd      	mov	sp, r7
10002f08:	b002      	add	sp, #8
10002f0a:	bd80      	pop	{r7, pc}

10002f0c <XMC_USIC_CH_GetReceiveBufferStatus>:
 * can be read from RBUF.
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_GetTransmitBufferStatus() \n\n\n
 */
__STATIC_INLINE uint32_t XMC_USIC_CH_GetReceiveBufferStatus(XMC_USIC_CH_t *const channel)
{
10002f0c:	b580      	push	{r7, lr}
10002f0e:	b082      	sub	sp, #8
10002f10:	af00      	add	r7, sp, #0
10002f12:	6078      	str	r0, [r7, #4]
  return ((uint32_t) (channel->RBUFSR & (USIC_CH_RBUFSR_RDV0_Msk | USIC_CH_RBUFSR_RDV1_Msk)));
10002f14:	687b      	ldr	r3, [r7, #4]
10002f16:	6d1a      	ldr	r2, [r3, #80]	; 0x50
10002f18:	23c0      	movs	r3, #192	; 0xc0
10002f1a:	01db      	lsls	r3, r3, #7
10002f1c:	4013      	ands	r3, r2
}
10002f1e:	1c18      	adds	r0, r3, #0
10002f20:	46bd      	mov	sp, r7
10002f22:	b002      	add	sp, #8
10002f24:	bd80      	pop	{r7, pc}
10002f26:	46c0      	nop			; (mov r8, r8)

10002f28 <XMC_USIC_CH_TriggerServiceRequest>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TriggerServiceRequest(XMC_USIC_CH_t *const channel, const uint32_t service_request_line)
{
10002f28:	b580      	push	{r7, lr}
10002f2a:	b082      	sub	sp, #8
10002f2c:	af00      	add	r7, sp, #0
10002f2e:	6078      	str	r0, [r7, #4]
10002f30:	6039      	str	r1, [r7, #0]
  channel->FMR = (uint32_t)(USIC_CH_FMR_SIO0_Msk << service_request_line);
10002f32:	683b      	ldr	r3, [r7, #0]
10002f34:	2280      	movs	r2, #128	; 0x80
10002f36:	0252      	lsls	r2, r2, #9
10002f38:	409a      	lsls	r2, r3
10002f3a:	687b      	ldr	r3, [r7, #4]
10002f3c:	669a      	str	r2, [r3, #104]	; 0x68
}
10002f3e:	46bd      	mov	sp, r7
10002f40:	b002      	add	sp, #8
10002f42:	bd80      	pop	{r7, pc}

10002f44 <XMC_USIC_CH_TXFIFO_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10002f44:	b580      	push	{r7, lr}
10002f46:	b082      	sub	sp, #8
10002f48:	af00      	add	r7, sp, #0
10002f4a:	6078      	str	r0, [r7, #4]
10002f4c:	6039      	str	r1, [r7, #0]
  channel->TBCTR |= event;
10002f4e:	687a      	ldr	r2, [r7, #4]
10002f50:	2384      	movs	r3, #132	; 0x84
10002f52:	005b      	lsls	r3, r3, #1
10002f54:	58d2      	ldr	r2, [r2, r3]
10002f56:	683b      	ldr	r3, [r7, #0]
10002f58:	431a      	orrs	r2, r3
10002f5a:	1c11      	adds	r1, r2, #0
10002f5c:	687a      	ldr	r2, [r7, #4]
10002f5e:	2384      	movs	r3, #132	; 0x84
10002f60:	005b      	lsls	r3, r3, #1
10002f62:	50d1      	str	r1, [r2, r3]
}
10002f64:	46bd      	mov	sp, r7
10002f66:	b002      	add	sp, #8
10002f68:	bd80      	pop	{r7, pc}
10002f6a:	46c0      	nop			; (mov r8, r8)

10002f6c <XMC_USIC_CH_TXFIFO_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetEvent(), XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10002f6c:	b580      	push	{r7, lr}
10002f6e:	b082      	sub	sp, #8
10002f70:	af00      	add	r7, sp, #0
10002f72:	6078      	str	r0, [r7, #4]
10002f74:	6039      	str	r1, [r7, #0]
  channel->TBCTR &= (uint32_t)~event;
10002f76:	687a      	ldr	r2, [r7, #4]
10002f78:	2384      	movs	r3, #132	; 0x84
10002f7a:	005b      	lsls	r3, r3, #1
10002f7c:	58d3      	ldr	r3, [r2, r3]
10002f7e:	683a      	ldr	r2, [r7, #0]
10002f80:	43d2      	mvns	r2, r2
10002f82:	401a      	ands	r2, r3
10002f84:	1c11      	adds	r1, r2, #0
10002f86:	687a      	ldr	r2, [r7, #4]
10002f88:	2384      	movs	r3, #132	; 0x84
10002f8a:	005b      	lsls	r3, r3, #1
10002f8c:	50d1      	str	r1, [r2, r3]
}
10002f8e:	46bd      	mov	sp, r7
10002f90:	b002      	add	sp, #8
10002f92:	bd80      	pop	{r7, pc}

10002f94 <XMC_USIC_CH_TXFIFO_PutDataHPCMode>:
 * XMC_USIC_CH_EnableFrameLengthControl() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_PutDataHPCMode(XMC_USIC_CH_t *const channel,
    const uint16_t data,
    const uint32_t frame_length)
{
10002f94:	b580      	push	{r7, lr}
10002f96:	b084      	sub	sp, #16
10002f98:	af00      	add	r7, sp, #0
10002f9a:	60f8      	str	r0, [r7, #12]
10002f9c:	607a      	str	r2, [r7, #4]
10002f9e:	230a      	movs	r3, #10
10002fa0:	18fb      	adds	r3, r7, r3
10002fa2:	1c0a      	adds	r2, r1, #0
10002fa4:	801a      	strh	r2, [r3, #0]
  channel->IN[frame_length] = data;
10002fa6:	230a      	movs	r3, #10
10002fa8:	18fb      	adds	r3, r7, r3
10002faa:	8819      	ldrh	r1, [r3, #0]
10002fac:	68fb      	ldr	r3, [r7, #12]
10002fae:	687a      	ldr	r2, [r7, #4]
10002fb0:	3260      	adds	r2, #96	; 0x60
10002fb2:	0092      	lsls	r2, r2, #2
10002fb4:	50d1      	str	r1, [r2, r3]
}
10002fb6:	46bd      	mov	sp, r7
10002fb8:	b004      	add	sp, #16
10002fba:	bd80      	pop	{r7, pc}

10002fbc <XMC_USIC_CH_TXFIFO_Flush>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
10002fbc:	b580      	push	{r7, lr}
10002fbe:	b082      	sub	sp, #8
10002fc0:	af00      	add	r7, sp, #0
10002fc2:	6078      	str	r0, [r7, #4]
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHTB_Msk;
10002fc4:	687a      	ldr	r2, [r7, #4]
10002fc6:	238c      	movs	r3, #140	; 0x8c
10002fc8:	005b      	lsls	r3, r3, #1
10002fca:	2180      	movs	r1, #128	; 0x80
10002fcc:	0209      	lsls	r1, r1, #8
10002fce:	50d1      	str	r1, [r2, r3]
}
10002fd0:	46bd      	mov	sp, r7
10002fd2:	b002      	add	sp, #8
10002fd4:	bd80      	pop	{r7, pc}
10002fd6:	46c0      	nop			; (mov r8, r8)

10002fd8 <XMC_USIC_CH_TXFIFO_IsFull>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
10002fd8:	b580      	push	{r7, lr}
10002fda:	b082      	sub	sp, #8
10002fdc:	af00      	add	r7, sp, #0
10002fde:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
10002fe0:	687a      	ldr	r2, [r7, #4]
10002fe2:	238a      	movs	r3, #138	; 0x8a
10002fe4:	005b      	lsls	r3, r3, #1
10002fe6:	58d2      	ldr	r2, [r2, r3]
10002fe8:	2380      	movs	r3, #128	; 0x80
10002fea:	015b      	lsls	r3, r3, #5
10002fec:	4013      	ands	r3, r2
10002fee:	1e5a      	subs	r2, r3, #1
10002ff0:	4193      	sbcs	r3, r2
10002ff2:	b2db      	uxtb	r3, r3
}
10002ff4:	1c18      	adds	r0, r3, #0
10002ff6:	46bd      	mov	sp, r7
10002ff8:	b002      	add	sp, #8
10002ffa:	bd80      	pop	{r7, pc}

10002ffc <XMC_USIC_CH_TXFIFO_IsEmpty>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_Flush(), XMC_USIC_CH_TXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
10002ffc:	b580      	push	{r7, lr}
10002ffe:	b082      	sub	sp, #8
10003000:	af00      	add	r7, sp, #0
10003002:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TEMPTY_Msk);
10003004:	687a      	ldr	r2, [r7, #4]
10003006:	238a      	movs	r3, #138	; 0x8a
10003008:	005b      	lsls	r3, r3, #1
1000300a:	58d2      	ldr	r2, [r2, r3]
1000300c:	2380      	movs	r3, #128	; 0x80
1000300e:	011b      	lsls	r3, r3, #4
10003010:	4013      	ands	r3, r2
10003012:	1e5a      	subs	r2, r3, #1
10003014:	4193      	sbcs	r3, r2
10003016:	b2db      	uxtb	r3, r3
}
10003018:	1c18      	adds	r0, r3, #0
1000301a:	46bd      	mov	sp, r7
1000301c:	b002      	add	sp, #8
1000301e:	bd80      	pop	{r7, pc}

10003020 <XMC_USIC_CH_RXFIFO_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_GetEvent(), XMC_USIC_CH_RXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10003020:	b580      	push	{r7, lr}
10003022:	b082      	sub	sp, #8
10003024:	af00      	add	r7, sp, #0
10003026:	6078      	str	r0, [r7, #4]
10003028:	6039      	str	r1, [r7, #0]
  channel->RBCTR &= (uint32_t)~event;
1000302a:	687a      	ldr	r2, [r7, #4]
1000302c:	2386      	movs	r3, #134	; 0x86
1000302e:	005b      	lsls	r3, r3, #1
10003030:	58d3      	ldr	r3, [r2, r3]
10003032:	683a      	ldr	r2, [r7, #0]
10003034:	43d2      	mvns	r2, r2
10003036:	401a      	ands	r2, r3
10003038:	1c11      	adds	r1, r2, #0
1000303a:	687a      	ldr	r2, [r7, #4]
1000303c:	2386      	movs	r3, #134	; 0x86
1000303e:	005b      	lsls	r3, r3, #1
10003040:	50d1      	str	r1, [r2, r3]
}
10003042:	46bd      	mov	sp, r7
10003044:	b002      	add	sp, #8
10003046:	bd80      	pop	{r7, pc}

10003048 <XMC_USIC_CH_RXFIFO_IsEmpty>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_Flush(), XMC_USIC_CH_RXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
10003048:	b580      	push	{r7, lr}
1000304a:	b082      	sub	sp, #8
1000304c:	af00      	add	r7, sp, #0
1000304e:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_REMPTY_Msk);
10003050:	687a      	ldr	r2, [r7, #4]
10003052:	238a      	movs	r3, #138	; 0x8a
10003054:	005b      	lsls	r3, r3, #1
10003056:	58d3      	ldr	r3, [r2, r3]
10003058:	2208      	movs	r2, #8
1000305a:	4013      	ands	r3, r2
1000305c:	1e5a      	subs	r2, r3, #1
1000305e:	4193      	sbcs	r3, r2
10003060:	b2db      	uxtb	r3, r3
}
10003062:	1c18      	adds	r0, r3, #0
10003064:	46bd      	mov	sp, r7
10003066:	b002      	add	sp, #8
10003068:	bd80      	pop	{r7, pc}
1000306a:	46c0      	nop			; (mov r8, r8)

1000306c <XMC_SPI_CH_SetTransmitMode>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SPI_CH_Transmit()
 */
__STATIC_INLINE void XMC_SPI_CH_SetTransmitMode(XMC_USIC_CH_t *const channel, const XMC_SPI_CH_MODE_t mode)
{
1000306c:	b580      	push	{r7, lr}
1000306e:	b082      	sub	sp, #8
10003070:	af00      	add	r7, sp, #0
10003072:	6078      	str	r0, [r7, #4]
10003074:	1c0a      	adds	r2, r1, #0
10003076:	1cfb      	adds	r3, r7, #3
10003078:	701a      	strb	r2, [r3, #0]
  channel->CCR = (channel->CCR & (uint32_t)(~USIC_CH_CCR_HPCEN_Msk)) |
1000307a:	687b      	ldr	r3, [r7, #4]
1000307c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000307e:	22c0      	movs	r2, #192	; 0xc0
10003080:	4393      	bics	r3, r2
10003082:	1c1a      	adds	r2, r3, #0
                 (((uint32_t) mode << USIC_CH_CCR_HPCEN_Pos) & (uint32_t)USIC_CH_CCR_HPCEN_Msk);
10003084:	1cfb      	adds	r3, r7, #3
10003086:	781b      	ldrb	r3, [r3, #0]
10003088:	019b      	lsls	r3, r3, #6
1000308a:	21ff      	movs	r1, #255	; 0xff
1000308c:	400b      	ands	r3, r1
 * \par<b>Related APIs:</b><BR>
 * XMC_SPI_CH_Transmit()
 */
__STATIC_INLINE void XMC_SPI_CH_SetTransmitMode(XMC_USIC_CH_t *const channel, const XMC_SPI_CH_MODE_t mode)
{
  channel->CCR = (channel->CCR & (uint32_t)(~USIC_CH_CCR_HPCEN_Msk)) |
1000308e:	431a      	orrs	r2, r3
10003090:	687b      	ldr	r3, [r7, #4]
10003092:	641a      	str	r2, [r3, #64]	; 0x40
                 (((uint32_t) mode << USIC_CH_CCR_HPCEN_Pos) & (uint32_t)USIC_CH_CCR_HPCEN_Msk);
}
10003094:	46bd      	mov	sp, r7
10003096:	b002      	add	sp, #8
10003098:	bd80      	pop	{r7, pc}
1000309a:	46c0      	nop			; (mov r8, r8)

1000309c <SPI_MASTER_Init>:

/*
 * This function initializes the SPI channel, based on UI configuration.
 */
SPI_MASTER_STATUS_t SPI_MASTER_Init(SPI_MASTER_t* const handle)
{
1000309c:	b590      	push	{r4, r7, lr}
1000309e:	b085      	sub	sp, #20
100030a0:	af00      	add	r7, sp, #0
100030a2:	6078      	str	r0, [r7, #4]
  SPI_MASTER_STATUS_t status;

  XMC_ASSERT("SPI_MASTER_Init:handle NULL" , (handle != NULL));

  /* Configure the port registers and data input registers of SPI channel */
  status = handle->config->fptr_spi_master_config();
100030a4:	687b      	ldr	r3, [r7, #4]
100030a6:	685b      	ldr	r3, [r3, #4]
100030a8:	685b      	ldr	r3, [r3, #4]
100030aa:	220f      	movs	r2, #15
100030ac:	18bc      	adds	r4, r7, r2
100030ae:	4798      	blx	r3
100030b0:	1c03      	adds	r3, r0, #0
100030b2:	7023      	strb	r3, [r4, #0]

  return status;
100030b4:	230f      	movs	r3, #15
100030b6:	18fb      	adds	r3, r7, r3
100030b8:	781b      	ldrb	r3, [r3, #0]
}
100030ba:	1c18      	adds	r0, r3, #0
100030bc:	46bd      	mov	sp, r7
100030be:	b005      	add	sp, #20
100030c0:	bd90      	pop	{r4, r7, pc}
100030c2:	46c0      	nop			; (mov r8, r8)

100030c4 <SPI_MASTER_Transmit>:

  return status;
}

SPI_MASTER_STATUS_t SPI_MASTER_Transmit(const SPI_MASTER_t *const handle, uint8_t* dataptr, uint32_t count)
{
100030c4:	b590      	push	{r4, r7, lr}
100030c6:	b087      	sub	sp, #28
100030c8:	af00      	add	r7, sp, #0
100030ca:	60f8      	str	r0, [r7, #12]
100030cc:	60b9      	str	r1, [r7, #8]
100030ce:	607a      	str	r2, [r7, #4]
  SPI_MASTER_STATUS_t status;
  
   status = SPI_MASTER_STATUS_FAILURE;
100030d0:	2317      	movs	r3, #23
100030d2:	18fb      	adds	r3, r7, r3
100030d4:	2201      	movs	r2, #1
100030d6:	701a      	strb	r2, [r3, #0]

#if (SPI_MASTER_INTERRUPT_TRANSMIT_MODE == 1U)
  if (handle->config->transmit_mode == SPI_MASTER_TRANSFER_MODE_INTERRUPT)
100030d8:	68fb      	ldr	r3, [r7, #12]
100030da:	685b      	ldr	r3, [r3, #4]
100030dc:	2284      	movs	r2, #132	; 0x84
100030de:	5c9b      	ldrb	r3, [r3, r2]
100030e0:	2b00      	cmp	r3, #0
100030e2:	d10b      	bne.n	100030fc <SPI_MASTER_Transmit+0x38>
  {
    status = SPI_MASTER_StartTransmitIRQ(handle, dataptr, count);
100030e4:	2317      	movs	r3, #23
100030e6:	18fc      	adds	r4, r7, r3
100030e8:	68f9      	ldr	r1, [r7, #12]
100030ea:	68ba      	ldr	r2, [r7, #8]
100030ec:	687b      	ldr	r3, [r7, #4]
100030ee:	1c08      	adds	r0, r1, #0
100030f0:	1c11      	adds	r1, r2, #0
100030f2:	1c1a      	adds	r2, r3, #0
100030f4:	f000 f80a 	bl	1000310c <SPI_MASTER_StartTransmitIRQ>
100030f8:	1c03      	adds	r3, r0, #0
100030fa:	7023      	strb	r3, [r4, #0]
  {
    status = SPI_MASTER_lStartTransmitPolling(handle, dataptr, count);
  }
#endif

  return status;
100030fc:	2317      	movs	r3, #23
100030fe:	18fb      	adds	r3, r7, r3
10003100:	781b      	ldrb	r3, [r3, #0]
}
10003102:	1c18      	adds	r0, r3, #0
10003104:	46bd      	mov	sp, r7
10003106:	b007      	add	sp, #28
10003108:	bd90      	pop	{r4, r7, pc}
1000310a:	46c0      	nop			; (mov r8, r8)

1000310c <SPI_MASTER_StartTransmitIRQ>:
#if (SPI_MASTER_INTERRUPT_TRANSMIT_MODE == 1U)
/*
 * Transmit the number of data words specified.
 */
SPI_MASTER_STATUS_t SPI_MASTER_StartTransmitIRQ(const SPI_MASTER_t *const handle, uint8_t* dataptr, uint32_t count)
{
1000310c:	b580      	push	{r7, lr}
1000310e:	b088      	sub	sp, #32
10003110:	af00      	add	r7, sp, #0
10003112:	60f8      	str	r0, [r7, #12]
10003114:	60b9      	str	r1, [r7, #8]
10003116:	607a      	str	r2, [r7, #4]
  SPI_MASTER_STATUS_t status;
  uint32_t bytes_per_word = SPI_MASTER_1_BYTE_PER_WORD; /* This is to support the word length 8 and 16.
10003118:	2301      	movs	r3, #1
1000311a:	61bb      	str	r3, [r7, #24]
                                                           Specify the number of bytes for the configured word length */
  SPI_MASTER_RUNTIME_t * runtime_handle;

  XMC_ASSERT("SPI_MASTER_StartTransmitIRQ:handle NULL" , (handle != NULL));

  status = SPI_MASTER_STATUS_MODE_MISMATCH;
1000311c:	231f      	movs	r3, #31
1000311e:	18fb      	adds	r3, r7, r3
10003120:	2204      	movs	r2, #4
10003122:	701a      	strb	r2, [r3, #0]
  runtime_handle = handle->runtime;
10003124:	68fb      	ldr	r3, [r7, #12]
10003126:	689b      	ldr	r3, [r3, #8]
10003128:	617b      	str	r3, [r7, #20]

  if (handle->config->transmit_mode == SPI_MASTER_TRANSFER_MODE_INTERRUPT)
1000312a:	68fb      	ldr	r3, [r7, #12]
1000312c:	685b      	ldr	r3, [r3, #4]
1000312e:	2284      	movs	r2, #132	; 0x84
10003130:	5c9b      	ldrb	r3, [r3, r2]
10003132:	2b00      	cmp	r3, #0
10003134:	d164      	bne.n	10003200 <SPI_MASTER_StartTransmitIRQ+0xf4>
  {
    /* Check whether SPI channel is free or not */
    if ((dataptr != NULL) && (count > 0U))
10003136:	68bb      	ldr	r3, [r7, #8]
10003138:	2b00      	cmp	r3, #0
1000313a:	d05d      	beq.n	100031f8 <SPI_MASTER_StartTransmitIRQ+0xec>
1000313c:	687b      	ldr	r3, [r7, #4]
1000313e:	2b00      	cmp	r3, #0
10003140:	d05a      	beq.n	100031f8 <SPI_MASTER_StartTransmitIRQ+0xec>
    {
      status = SPI_MASTER_STATUS_BUSY;
10003142:	231f      	movs	r3, #31
10003144:	18fb      	adds	r3, r7, r3
10003146:	2202      	movs	r2, #2
10003148:	701a      	strb	r2, [r3, #0]
      /*Check data pointer is valid or not*/
      if (false == runtime_handle->tx_busy)
1000314a:	697b      	ldr	r3, [r7, #20]
1000314c:	2220      	movs	r2, #32
1000314e:	5c9b      	ldrb	r3, [r3, r2]
10003150:	b2db      	uxtb	r3, r3
10003152:	2201      	movs	r2, #1
10003154:	4053      	eors	r3, r2
10003156:	b2db      	uxtb	r3, r3
10003158:	2b00      	cmp	r3, #0
1000315a:	d04c      	beq.n	100031f6 <SPI_MASTER_StartTransmitIRQ+0xea>
      {
        if (handle->runtime->word_length > SPI_MASTER_WORD_LENGTH_8_BIT)
1000315c:	68fb      	ldr	r3, [r7, #12]
1000315e:	689b      	ldr	r3, [r3, #8]
10003160:	681b      	ldr	r3, [r3, #0]
10003162:	2b08      	cmp	r3, #8
10003164:	d901      	bls.n	1000316a <SPI_MASTER_StartTransmitIRQ+0x5e>
        {
          bytes_per_word = SPI_MASTER_2_BYTES_PER_WORD; /* Word length is 16-bits */
10003166:	2302      	movs	r3, #2
10003168:	61bb      	str	r3, [r7, #24]
        }

        /* Obtain the address of data, size of data */
        runtime_handle->tx_data = dataptr;
1000316a:	697b      	ldr	r3, [r7, #20]
1000316c:	68ba      	ldr	r2, [r7, #8]
1000316e:	619a      	str	r2, [r3, #24]
        runtime_handle->tx_data_count = (uint32_t)count << (bytes_per_word - 1U);
10003170:	69bb      	ldr	r3, [r7, #24]
10003172:	3b01      	subs	r3, #1
10003174:	1c1a      	adds	r2, r3, #0
10003176:	687b      	ldr	r3, [r7, #4]
10003178:	4093      	lsls	r3, r2
1000317a:	1c1a      	adds	r2, r3, #0
1000317c:	697b      	ldr	r3, [r7, #20]
1000317e:	605a      	str	r2, [r3, #4]
        /* Initialize to first index and set the busy flag */
        runtime_handle->tx_data_index = 0U;
10003180:	697b      	ldr	r3, [r7, #20]
10003182:	2200      	movs	r2, #0
10003184:	609a      	str	r2, [r3, #8]
        runtime_handle->tx_busy = true;
10003186:	697b      	ldr	r3, [r7, #20]
10003188:	2220      	movs	r2, #32
1000318a:	2101      	movs	r1, #1
1000318c:	5499      	strb	r1, [r3, r2]

        /* Enable the transmit buffer event */
        if ((uint32_t)handle->config->tx_fifo_size > 0U)
1000318e:	68fb      	ldr	r3, [r7, #12]
10003190:	685b      	ldr	r3, [r3, #4]
10003192:	227c      	movs	r2, #124	; 0x7c
10003194:	5c9b      	ldrb	r3, [r3, r2]
10003196:	2b00      	cmp	r3, #0
10003198:	d00d      	beq.n	100031b6 <SPI_MASTER_StartTransmitIRQ+0xaa>
        {
          /* Flush the Transmit FIFO */
          XMC_USIC_CH_TXFIFO_Flush(handle->channel);
1000319a:	68fb      	ldr	r3, [r7, #12]
1000319c:	681b      	ldr	r3, [r3, #0]
1000319e:	1c18      	adds	r0, r3, #0
100031a0:	f7ff ff0c 	bl	10002fbc <XMC_USIC_CH_TXFIFO_Flush>
          XMC_USIC_CH_TXFIFO_EnableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
100031a4:	68fb      	ldr	r3, [r7, #12]
100031a6:	681a      	ldr	r2, [r3, #0]
100031a8:	2380      	movs	r3, #128	; 0x80
100031aa:	05db      	lsls	r3, r3, #23
100031ac:	1c10      	adds	r0, r2, #0
100031ae:	1c19      	adds	r1, r3, #0
100031b0:	f7ff fec8 	bl	10002f44 <XMC_USIC_CH_TXFIFO_EnableEvent>
100031b4:	e007      	b.n	100031c6 <SPI_MASTER_StartTransmitIRQ+0xba>
        }
        else
        {
          XMC_USIC_CH_EnableEvent(handle->channel,(uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
100031b6:	68fb      	ldr	r3, [r7, #12]
100031b8:	681a      	ldr	r2, [r3, #0]
100031ba:	2380      	movs	r3, #128	; 0x80
100031bc:	019b      	lsls	r3, r3, #6
100031be:	1c10      	adds	r0, r2, #0
100031c0:	1c19      	adds	r1, r3, #0
100031c2:	f7ff fe77 	bl	10002eb4 <XMC_USIC_CH_EnableEvent>
        }
        XMC_SPI_CH_SetTransmitMode(handle->channel, runtime_handle->spi_master_mode);
100031c6:	68fb      	ldr	r3, [r7, #12]
100031c8:	681a      	ldr	r2, [r3, #0]
100031ca:	697b      	ldr	r3, [r7, #20]
100031cc:	7f1b      	ldrb	r3, [r3, #28]
100031ce:	b2db      	uxtb	r3, r3
100031d0:	1c10      	adds	r0, r2, #0
100031d2:	1c19      	adds	r1, r3, #0
100031d4:	f7ff ff4a 	bl	1000306c <XMC_SPI_CH_SetTransmitMode>
        status = SPI_MASTER_STATUS_SUCCESS;
100031d8:	231f      	movs	r3, #31
100031da:	18fb      	adds	r3, r7, r3
100031dc:	2200      	movs	r2, #0
100031de:	701a      	strb	r2, [r3, #0]

        /* Trigger the transmit buffer interrupt */
        XMC_USIC_CH_TriggerServiceRequest(handle->channel, (uint32_t)handle->config->tx_sr);
100031e0:	68fb      	ldr	r3, [r7, #12]
100031e2:	6819      	ldr	r1, [r3, #0]
100031e4:	68fb      	ldr	r3, [r7, #12]
100031e6:	685b      	ldr	r3, [r3, #4]
100031e8:	2289      	movs	r2, #137	; 0x89
100031ea:	5c9b      	ldrb	r3, [r3, r2]
100031ec:	1c08      	adds	r0, r1, #0
100031ee:	1c19      	adds	r1, r3, #0
100031f0:	f7ff fe9a 	bl	10002f28 <XMC_USIC_CH_TriggerServiceRequest>
    /* Check whether SPI channel is free or not */
    if ((dataptr != NULL) && (count > 0U))
    {
      status = SPI_MASTER_STATUS_BUSY;
      /*Check data pointer is valid or not*/
      if (false == runtime_handle->tx_busy)
100031f4:	e004      	b.n	10003200 <SPI_MASTER_StartTransmitIRQ+0xf4>
100031f6:	e003      	b.n	10003200 <SPI_MASTER_StartTransmitIRQ+0xf4>
        XMC_USIC_CH_TriggerServiceRequest(handle->channel, (uint32_t)handle->config->tx_sr);
      }
    }
    else
    {
      status = SPI_MASTER_STATUS_BUFFER_INVALID;
100031f8:	231f      	movs	r3, #31
100031fa:	18fb      	adds	r3, r7, r3
100031fc:	2203      	movs	r2, #3
100031fe:	701a      	strb	r2, [r3, #0]
    }
  }
  return status;
10003200:	231f      	movs	r3, #31
10003202:	18fb      	adds	r3, r7, r3
10003204:	781b      	ldrb	r3, [r3, #0]
}
10003206:	1c18      	adds	r0, r3, #0
10003208:	46bd      	mov	sp, r7
1000320a:	b008      	add	sp, #32
1000320c:	bd80      	pop	{r7, pc}
1000320e:	46c0      	nop			; (mov r8, r8)

10003210 <SPI_MASTER_lTransmitHandler>:
 * Transmit interrupt handler for the APP.
 * This is a common interrupt handling function called for different instances of the APP.
 *
 */
void SPI_MASTER_lTransmitHandler(const SPI_MASTER_t * const handle)
{
10003210:	b590      	push	{r4, r7, lr}
10003212:	b087      	sub	sp, #28
10003214:	af00      	add	r7, sp, #0
10003216:	6078      	str	r0, [r7, #4]
  uint16_t data; /* Data to be loaded into the TBUF */
  uint32_t bytes_per_word = SPI_MASTER_1_BYTE_PER_WORD; /* This is to support the word length 8 and 16.*/
10003218:	2301      	movs	r3, #1
1000321a:	613b      	str	r3, [r7, #16]
  SPI_MASTER_RUNTIME_t * runtime_handle = handle->runtime;
1000321c:	687b      	ldr	r3, [r7, #4]
1000321e:	689b      	ldr	r3, [r3, #8]
10003220:	60fb      	str	r3, [r7, #12]

  if (handle->runtime->word_length > SPI_MASTER_WORD_LENGTH_8_BIT)
10003222:	687b      	ldr	r3, [r7, #4]
10003224:	689b      	ldr	r3, [r3, #8]
10003226:	681b      	ldr	r3, [r3, #0]
10003228:	2b08      	cmp	r3, #8
1000322a:	d901      	bls.n	10003230 <SPI_MASTER_lTransmitHandler+0x20>
  {
    bytes_per_word = SPI_MASTER_2_BYTES_PER_WORD; /* Word length is 16-bits */
1000322c:	2302      	movs	r3, #2
1000322e:	613b      	str	r3, [r7, #16]
  }

  if (runtime_handle->tx_data_index < runtime_handle->tx_data_count)
10003230:	68fb      	ldr	r3, [r7, #12]
10003232:	689a      	ldr	r2, [r3, #8]
10003234:	68fb      	ldr	r3, [r7, #12]
10003236:	685b      	ldr	r3, [r3, #4]
10003238:	429a      	cmp	r2, r3
1000323a:	d300      	bcc.n	1000323e <SPI_MASTER_lTransmitHandler+0x2e>
1000323c:	e09b      	b.n	10003376 <SPI_MASTER_lTransmitHandler+0x166>
  {
    data = 0U;
1000323e:	2316      	movs	r3, #22
10003240:	18fb      	adds	r3, r7, r3
10003242:	2200      	movs	r2, #0
10003244:	801a      	strh	r2, [r3, #0]
    /*When Transmit FIFO is enabled*/
    if ((uint32_t)handle->config->tx_fifo_size > 0U)
10003246:	687b      	ldr	r3, [r7, #4]
10003248:	685b      	ldr	r3, [r3, #4]
1000324a:	227c      	movs	r2, #124	; 0x7c
1000324c:	5c9b      	ldrb	r3, [r3, r2]
1000324e:	2b00      	cmp	r3, #0
10003250:	d053      	beq.n	100032fa <SPI_MASTER_lTransmitHandler+0xea>
    {
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
10003252:	e045      	b.n	100032e0 <SPI_MASTER_lTransmitHandler+0xd0>
      {
        if (runtime_handle->tx_data_index < runtime_handle->tx_data_count)
10003254:	68fb      	ldr	r3, [r7, #12]
10003256:	689a      	ldr	r2, [r3, #8]
10003258:	68fb      	ldr	r3, [r7, #12]
1000325a:	685b      	ldr	r3, [r3, #4]
1000325c:	429a      	cmp	r2, r3
1000325e:	d23d      	bcs.n	100032dc <SPI_MASTER_lTransmitHandler+0xcc>
        {
          /*Load the FIFO byte by byte till either FIFO is full or all data is loaded*/
          if (runtime_handle->tx_data_dummy == true)
10003260:	68fb      	ldr	r3, [r7, #12]
10003262:	2221      	movs	r2, #33	; 0x21
10003264:	5c9b      	ldrb	r3, [r3, r2]
10003266:	b2db      	uxtb	r3, r3
10003268:	2b00      	cmp	r3, #0
1000326a:	d00c      	beq.n	10003286 <SPI_MASTER_lTransmitHandler+0x76>
          {
            XMC_USIC_CH_TXFIFO_PutDataHPCMode(handle->channel, 0xFFFFU, (uint32_t)runtime_handle->spi_master_mode);
1000326c:	687b      	ldr	r3, [r7, #4]
1000326e:	681a      	ldr	r2, [r3, #0]
10003270:	68fb      	ldr	r3, [r7, #12]
10003272:	7f1b      	ldrb	r3, [r3, #28]
10003274:	b2db      	uxtb	r3, r3
10003276:	1c1c      	adds	r4, r3, #0
10003278:	4b60      	ldr	r3, [pc, #384]	; (100033fc <SPI_MASTER_lTransmitHandler+0x1ec>)
1000327a:	1c10      	adds	r0, r2, #0
1000327c:	1c19      	adds	r1, r3, #0
1000327e:	1c22      	adds	r2, r4, #0
10003280:	f7ff fe88 	bl	10002f94 <XMC_USIC_CH_TXFIFO_PutDataHPCMode>
10003284:	e023      	b.n	100032ce <SPI_MASTER_lTransmitHandler+0xbe>
          }
          else
          {
            if(bytes_per_word == SPI_MASTER_2_BYTES_PER_WORD)
10003286:	693b      	ldr	r3, [r7, #16]
10003288:	2b02      	cmp	r3, #2
1000328a:	d109      	bne.n	100032a0 <SPI_MASTER_lTransmitHandler+0x90>
            {
              data = *((uint16_t*)&runtime_handle->tx_data[runtime_handle->tx_data_index]);
1000328c:	68fb      	ldr	r3, [r7, #12]
1000328e:	699a      	ldr	r2, [r3, #24]
10003290:	68fb      	ldr	r3, [r7, #12]
10003292:	689b      	ldr	r3, [r3, #8]
10003294:	18d2      	adds	r2, r2, r3
10003296:	2316      	movs	r3, #22
10003298:	18fb      	adds	r3, r7, r3
1000329a:	8812      	ldrh	r2, [r2, #0]
1000329c:	801a      	strh	r2, [r3, #0]
1000329e:	e008      	b.n	100032b2 <SPI_MASTER_lTransmitHandler+0xa2>
            }
            else
            {
              data = runtime_handle->tx_data[runtime_handle->tx_data_index];
100032a0:	68fb      	ldr	r3, [r7, #12]
100032a2:	699a      	ldr	r2, [r3, #24]
100032a4:	68fb      	ldr	r3, [r7, #12]
100032a6:	689b      	ldr	r3, [r3, #8]
100032a8:	18d3      	adds	r3, r2, r3
100032aa:	781a      	ldrb	r2, [r3, #0]
100032ac:	2316      	movs	r3, #22
100032ae:	18fb      	adds	r3, r7, r3
100032b0:	801a      	strh	r2, [r3, #0]
            }
            XMC_USIC_CH_TXFIFO_PutDataHPCMode(handle->channel, data, (uint32_t)runtime_handle->spi_master_mode);
100032b2:	687b      	ldr	r3, [r7, #4]
100032b4:	681a      	ldr	r2, [r3, #0]
100032b6:	68fb      	ldr	r3, [r7, #12]
100032b8:	7f1b      	ldrb	r3, [r3, #28]
100032ba:	b2db      	uxtb	r3, r3
100032bc:	1c1c      	adds	r4, r3, #0
100032be:	2316      	movs	r3, #22
100032c0:	18fb      	adds	r3, r7, r3
100032c2:	881b      	ldrh	r3, [r3, #0]
100032c4:	1c10      	adds	r0, r2, #0
100032c6:	1c19      	adds	r1, r3, #0
100032c8:	1c22      	adds	r2, r4, #0
100032ca:	f7ff fe63 	bl	10002f94 <XMC_USIC_CH_TXFIFO_PutDataHPCMode>
          }
          (runtime_handle->tx_data_index)+= bytes_per_word;
100032ce:	68fb      	ldr	r3, [r7, #12]
100032d0:	689a      	ldr	r2, [r3, #8]
100032d2:	693b      	ldr	r3, [r7, #16]
100032d4:	18d2      	adds	r2, r2, r3
100032d6:	68fb      	ldr	r3, [r7, #12]
100032d8:	609a      	str	r2, [r3, #8]
100032da:	e001      	b.n	100032e0 <SPI_MASTER_lTransmitHandler+0xd0>
        }
        else
        {
          break;
100032dc:	46c0      	nop			; (mov r8, r8)
100032de:	e089      	b.n	100033f4 <SPI_MASTER_lTransmitHandler+0x1e4>
    data = 0U;
    /*When Transmit FIFO is enabled*/
    if ((uint32_t)handle->config->tx_fifo_size > 0U)
    {
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
100032e0:	687b      	ldr	r3, [r7, #4]
100032e2:	681b      	ldr	r3, [r3, #0]
100032e4:	1c18      	adds	r0, r3, #0
100032e6:	f7ff fe77 	bl	10002fd8 <XMC_USIC_CH_TXFIFO_IsFull>
100032ea:	1c03      	adds	r3, r0, #0
100032ec:	1c1a      	adds	r2, r3, #0
100032ee:	2301      	movs	r3, #1
100032f0:	4053      	eors	r3, r2
100032f2:	b2db      	uxtb	r3, r3
100032f4:	2b00      	cmp	r3, #0
100032f6:	d1ad      	bne.n	10003254 <SPI_MASTER_lTransmitHandler+0x44>
100032f8:	e07c      	b.n	100033f4 <SPI_MASTER_lTransmitHandler+0x1e4>
        }
      }
    }
    else/*When Transmit FIFO is disabled*/
    {
      if (runtime_handle->tx_data_dummy == true)
100032fa:	68fb      	ldr	r3, [r7, #12]
100032fc:	2221      	movs	r2, #33	; 0x21
100032fe:	5c9b      	ldrb	r3, [r3, r2]
10003300:	b2db      	uxtb	r3, r3
10003302:	2b00      	cmp	r3, #0
10003304:	d00c      	beq.n	10003320 <SPI_MASTER_lTransmitHandler+0x110>
      {
        XMC_USIC_CH_WriteToTBUFTCI(handle->channel, 0xFFFFU, (uint32_t)runtime_handle->spi_master_mode);
10003306:	687b      	ldr	r3, [r7, #4]
10003308:	681a      	ldr	r2, [r3, #0]
1000330a:	68fb      	ldr	r3, [r7, #12]
1000330c:	7f1b      	ldrb	r3, [r3, #28]
1000330e:	b2db      	uxtb	r3, r3
10003310:	1c1c      	adds	r4, r3, #0
10003312:	4b3a      	ldr	r3, [pc, #232]	; (100033fc <SPI_MASTER_lTransmitHandler+0x1ec>)
10003314:	1c10      	adds	r0, r2, #0
10003316:	1c19      	adds	r1, r3, #0
10003318:	1c22      	adds	r2, r4, #0
1000331a:	f7ff fdb7 	bl	10002e8c <XMC_USIC_CH_WriteToTBUFTCI>
1000331e:	e023      	b.n	10003368 <SPI_MASTER_lTransmitHandler+0x158>
      }
      else
      {
        if(bytes_per_word == SPI_MASTER_2_BYTES_PER_WORD)
10003320:	693b      	ldr	r3, [r7, #16]
10003322:	2b02      	cmp	r3, #2
10003324:	d109      	bne.n	1000333a <SPI_MASTER_lTransmitHandler+0x12a>
        {
          data = *((uint16_t*)&runtime_handle->tx_data[runtime_handle->tx_data_index]);
10003326:	68fb      	ldr	r3, [r7, #12]
10003328:	699a      	ldr	r2, [r3, #24]
1000332a:	68fb      	ldr	r3, [r7, #12]
1000332c:	689b      	ldr	r3, [r3, #8]
1000332e:	18d2      	adds	r2, r2, r3
10003330:	2316      	movs	r3, #22
10003332:	18fb      	adds	r3, r7, r3
10003334:	8812      	ldrh	r2, [r2, #0]
10003336:	801a      	strh	r2, [r3, #0]
10003338:	e008      	b.n	1000334c <SPI_MASTER_lTransmitHandler+0x13c>
        }
        else
        {
          data = runtime_handle->tx_data[runtime_handle->tx_data_index];
1000333a:	68fb      	ldr	r3, [r7, #12]
1000333c:	699a      	ldr	r2, [r3, #24]
1000333e:	68fb      	ldr	r3, [r7, #12]
10003340:	689b      	ldr	r3, [r3, #8]
10003342:	18d3      	adds	r3, r2, r3
10003344:	781a      	ldrb	r2, [r3, #0]
10003346:	2316      	movs	r3, #22
10003348:	18fb      	adds	r3, r7, r3
1000334a:	801a      	strh	r2, [r3, #0]
        }
        XMC_USIC_CH_WriteToTBUFTCI(handle->channel, data, (uint32_t)runtime_handle->spi_master_mode);
1000334c:	687b      	ldr	r3, [r7, #4]
1000334e:	681a      	ldr	r2, [r3, #0]
10003350:	68fb      	ldr	r3, [r7, #12]
10003352:	7f1b      	ldrb	r3, [r3, #28]
10003354:	b2db      	uxtb	r3, r3
10003356:	1c1c      	adds	r4, r3, #0
10003358:	2316      	movs	r3, #22
1000335a:	18fb      	adds	r3, r7, r3
1000335c:	881b      	ldrh	r3, [r3, #0]
1000335e:	1c10      	adds	r0, r2, #0
10003360:	1c19      	adds	r1, r3, #0
10003362:	1c22      	adds	r2, r4, #0
10003364:	f7ff fd92 	bl	10002e8c <XMC_USIC_CH_WriteToTBUFTCI>
      }
      (runtime_handle->tx_data_index)+= bytes_per_word;
10003368:	68fb      	ldr	r3, [r7, #12]
1000336a:	689a      	ldr	r2, [r3, #8]
1000336c:	693b      	ldr	r3, [r7, #16]
1000336e:	18d2      	adds	r2, r2, r3
10003370:	68fb      	ldr	r3, [r7, #12]
10003372:	609a      	str	r2, [r3, #8]
10003374:	e03e      	b.n	100033f4 <SPI_MASTER_lTransmitHandler+0x1e4>
    }
  }
  else
  {
    if (XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel) == true)
10003376:	687b      	ldr	r3, [r7, #4]
10003378:	681b      	ldr	r3, [r3, #0]
1000337a:	1c18      	adds	r0, r3, #0
1000337c:	f7ff fe3e 	bl	10002ffc <XMC_USIC_CH_TXFIFO_IsEmpty>
10003380:	1e03      	subs	r3, r0, #0
10003382:	d037      	beq.n	100033f4 <SPI_MASTER_lTransmitHandler+0x1e4>
    {
      /* Clear the flag */
      if ((uint32_t)handle->config->tx_fifo_size > 0U)
10003384:	687b      	ldr	r3, [r7, #4]
10003386:	685b      	ldr	r3, [r3, #4]
10003388:	227c      	movs	r2, #124	; 0x7c
1000338a:	5c9b      	ldrb	r3, [r3, r2]
1000338c:	2b00      	cmp	r3, #0
1000338e:	d008      	beq.n	100033a2 <SPI_MASTER_lTransmitHandler+0x192>
      {
        /* Clear the transmit FIFO event */
        XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
10003390:	687b      	ldr	r3, [r7, #4]
10003392:	681a      	ldr	r2, [r3, #0]
10003394:	2380      	movs	r3, #128	; 0x80
10003396:	05db      	lsls	r3, r3, #23
10003398:	1c10      	adds	r0, r2, #0
1000339a:	1c19      	adds	r1, r3, #0
1000339c:	f7ff fde6 	bl	10002f6c <XMC_USIC_CH_TXFIFO_DisableEvent>
100033a0:	e007      	b.n	100033b2 <SPI_MASTER_lTransmitHandler+0x1a2>
      }
      else
      {
        /* Clear the standard transmit event */
        XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
100033a2:	687b      	ldr	r3, [r7, #4]
100033a4:	681a      	ldr	r2, [r3, #0]
100033a6:	2380      	movs	r3, #128	; 0x80
100033a8:	019b      	lsls	r3, r3, #6
100033aa:	1c10      	adds	r0, r2, #0
100033ac:	1c19      	adds	r1, r3, #0
100033ae:	f7ff fd8f 	bl	10002ed0 <XMC_USIC_CH_DisableEvent>
      }

      /* Wait for the transmit buffer to be free to ensure that all data is transmitted */
      while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
100033b2:	46c0      	nop			; (mov r8, r8)
100033b4:	687b      	ldr	r3, [r7, #4]
100033b6:	681b      	ldr	r3, [r3, #0]
100033b8:	1c18      	adds	r0, r3, #0
100033ba:	f7ff fd99 	bl	10002ef0 <XMC_USIC_CH_GetTransmitBufferStatus>
100033be:	1e03      	subs	r3, r0, #0
100033c0:	2b80      	cmp	r3, #128	; 0x80
100033c2:	d0f7      	beq.n	100033b4 <SPI_MASTER_lTransmitHandler+0x1a4>
      {

      }

      /* All data is transmitted */
      runtime_handle->tx_busy = false;
100033c4:	68fb      	ldr	r3, [r7, #12]
100033c6:	2220      	movs	r2, #32
100033c8:	2100      	movs	r1, #0
100033ca:	5499      	strb	r1, [r3, r2]
      runtime_handle->tx_data = NULL;
100033cc:	68fb      	ldr	r3, [r7, #12]
100033ce:	2200      	movs	r2, #0
100033d0:	619a      	str	r2, [r3, #24]

      if ((handle->config->tx_cbhandler != NULL) && (runtime_handle->rx_busy == false))
100033d2:	687b      	ldr	r3, [r7, #4]
100033d4:	685b      	ldr	r3, [r3, #4]
100033d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
100033d8:	2b00      	cmp	r3, #0
100033da:	d00b      	beq.n	100033f4 <SPI_MASTER_lTransmitHandler+0x1e4>
100033dc:	68fb      	ldr	r3, [r7, #12]
100033de:	7fdb      	ldrb	r3, [r3, #31]
100033e0:	b2db      	uxtb	r3, r3
100033e2:	2201      	movs	r2, #1
100033e4:	4053      	eors	r3, r2
100033e6:	b2db      	uxtb	r3, r3
100033e8:	2b00      	cmp	r3, #0
100033ea:	d003      	beq.n	100033f4 <SPI_MASTER_lTransmitHandler+0x1e4>
      {
        /* Execute the callback function provided in the SPI_MASTER APP UI */
        handle->config->tx_cbhandler();
100033ec:	687b      	ldr	r3, [r7, #4]
100033ee:	685b      	ldr	r3, [r3, #4]
100033f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
100033f2:	4798      	blx	r3
      }
    }
  }
}
100033f4:	46bd      	mov	sp, r7
100033f6:	b007      	add	sp, #28
100033f8:	bd90      	pop	{r4, r7, pc}
100033fa:	46c0      	nop			; (mov r8, r8)
100033fc:	0000ffff 	.word	0x0000ffff

10003400 <SPI_MASTER_lReceiveHandler>:
/*
 * Receive interrupt handler for the APP.
 * This is a common interrupt handling function for different instances of the SPI_MASTER APP.
 */
void SPI_MASTER_lReceiveHandler(const SPI_MASTER_t * const handle)
{
10003400:	b590      	push	{r4, r7, lr}
10003402:	b087      	sub	sp, #28
10003404:	af00      	add	r7, sp, #0
10003406:	6078      	str	r0, [r7, #4]
  uint16_t data; /* Data to be loaded into the TBUF */
  uint32_t bytes_per_word = SPI_MASTER_1_BYTE_PER_WORD; /* This is to support the word length 8 and 16. */
10003408:	2301      	movs	r3, #1
1000340a:	617b      	str	r3, [r7, #20]
  SPI_MASTER_RUNTIME_t * runtime_handle = handle->runtime;
1000340c:	687b      	ldr	r3, [r7, #4]
1000340e:	689b      	ldr	r3, [r3, #8]
10003410:	613b      	str	r3, [r7, #16]

  data = 0U;
10003412:	230e      	movs	r3, #14
10003414:	18fb      	adds	r3, r7, r3
10003416:	2200      	movs	r2, #0
10003418:	801a      	strh	r2, [r3, #0]

  if (handle->runtime->word_length > SPI_MASTER_WORD_LENGTH_8_BIT)
1000341a:	687b      	ldr	r3, [r7, #4]
1000341c:	689b      	ldr	r3, [r3, #8]
1000341e:	681b      	ldr	r3, [r3, #0]
10003420:	2b08      	cmp	r3, #8
10003422:	d901      	bls.n	10003428 <SPI_MASTER_lReceiveHandler+0x28>
  {
    bytes_per_word = SPI_MASTER_2_BYTES_PER_WORD; /* Word length is 16-bits */
10003424:	2302      	movs	r3, #2
10003426:	617b      	str	r3, [r7, #20]
  }

  if ((uint32_t)handle->config->rx_fifo_size > 0U)
10003428:	687b      	ldr	r3, [r7, #4]
1000342a:	685b      	ldr	r3, [r3, #4]
1000342c:	227d      	movs	r2, #125	; 0x7d
1000342e:	5c9b      	ldrb	r3, [r3, r2]
10003430:	2b00      	cmp	r3, #0
10003432:	d020      	beq.n	10003476 <SPI_MASTER_lReceiveHandler+0x76>
  {
    /* read the FIFO */
    SPI_MASTER_lFIFORead(handle, bytes_per_word);
10003434:	687a      	ldr	r2, [r7, #4]
10003436:	697b      	ldr	r3, [r7, #20]
10003438:	1c10      	adds	r0, r2, #0
1000343a:	1c19      	adds	r1, r3, #0
1000343c:	f000 f8c4 	bl	100035c8 <SPI_MASTER_lFIFORead>
    /* Reconfigure the RXFIFO trigger limit based on pending receive bytes */
    if ((runtime_handle->rx_data_count - runtime_handle->rx_data_index) <= (1UL << (handle->config->rx_fifo_size - 1)))
10003440:	693b      	ldr	r3, [r7, #16]
10003442:	68da      	ldr	r2, [r3, #12]
10003444:	693b      	ldr	r3, [r7, #16]
10003446:	691b      	ldr	r3, [r3, #16]
10003448:	1ad2      	subs	r2, r2, r3
1000344a:	687b      	ldr	r3, [r7, #4]
1000344c:	685b      	ldr	r3, [r3, #4]
1000344e:	217d      	movs	r1, #125	; 0x7d
10003450:	5c5b      	ldrb	r3, [r3, r1]
10003452:	3b01      	subs	r3, #1
10003454:	2101      	movs	r1, #1
10003456:	4099      	lsls	r1, r3
10003458:	1c0b      	adds	r3, r1, #0
1000345a:	429a      	cmp	r2, r3
1000345c:	d900      	bls.n	10003460 <SPI_MASTER_lReceiveHandler+0x60>
1000345e:	e0b0      	b.n	100035c2 <SPI_MASTER_lReceiveHandler+0x1c2>
    {
      SPI_MASTER_lReconfigureRxFIFO(handle, (uint32_t)(runtime_handle->rx_data_count - runtime_handle->rx_data_index));
10003460:	693b      	ldr	r3, [r7, #16]
10003462:	68da      	ldr	r2, [r3, #12]
10003464:	693b      	ldr	r3, [r7, #16]
10003466:	691b      	ldr	r3, [r3, #16]
10003468:	1ad3      	subs	r3, r2, r3
1000346a:	687a      	ldr	r2, [r7, #4]
1000346c:	1c10      	adds	r0, r2, #0
1000346e:	1c19      	adds	r1, r3, #0
10003470:	f000 f916 	bl	100036a0 <SPI_MASTER_lReconfigureRxFIFO>
10003474:	e0a5      	b.n	100035c2 <SPI_MASTER_lReceiveHandler+0x1c2>
    }
  }
  else
  {
    /* When RxFIFO is disabled */
    if ((XMC_USIC_CH_GetReceiveBufferStatus(handle->channel) & (uint32_t)XMC_USIC_CH_RBUF_STATUS_DATA_VALID0) != 0U )
10003476:	687b      	ldr	r3, [r7, #4]
10003478:	681b      	ldr	r3, [r3, #0]
1000347a:	1c18      	adds	r0, r3, #0
1000347c:	f7ff fd46 	bl	10002f0c <XMC_USIC_CH_GetReceiveBufferStatus>
10003480:	1c02      	adds	r2, r0, #0
10003482:	2380      	movs	r3, #128	; 0x80
10003484:	019b      	lsls	r3, r3, #6
10003486:	4013      	ands	r3, r2
10003488:	d02e      	beq.n	100034e8 <SPI_MASTER_lReceiveHandler+0xe8>
    {
      if (runtime_handle->rx_data_index < runtime_handle->rx_data_count)
1000348a:	693b      	ldr	r3, [r7, #16]
1000348c:	691a      	ldr	r2, [r3, #16]
1000348e:	693b      	ldr	r3, [r7, #16]
10003490:	68db      	ldr	r3, [r3, #12]
10003492:	429a      	cmp	r2, r3
10003494:	d228      	bcs.n	100034e8 <SPI_MASTER_lReceiveHandler+0xe8>
      {
        data = XMC_SPI_CH_GetReceivedData(handle->channel);
10003496:	687b      	ldr	r3, [r7, #4]
10003498:	681b      	ldr	r3, [r3, #0]
1000349a:	220e      	movs	r2, #14
1000349c:	18bc      	adds	r4, r7, r2
1000349e:	1c18      	adds	r0, r3, #0
100034a0:	f7fe fd70 	bl	10001f84 <XMC_SPI_CH_GetReceivedData>
100034a4:	1c03      	adds	r3, r0, #0
100034a6:	8023      	strh	r3, [r4, #0]

        runtime_handle->rx_data[runtime_handle->rx_data_index] = (uint8_t)data;
100034a8:	693b      	ldr	r3, [r7, #16]
100034aa:	695a      	ldr	r2, [r3, #20]
100034ac:	693b      	ldr	r3, [r7, #16]
100034ae:	691b      	ldr	r3, [r3, #16]
100034b0:	18d3      	adds	r3, r2, r3
100034b2:	220e      	movs	r2, #14
100034b4:	18ba      	adds	r2, r7, r2
100034b6:	8812      	ldrh	r2, [r2, #0]
100034b8:	b2d2      	uxtb	r2, r2
100034ba:	701a      	strb	r2, [r3, #0]

        if (bytes_per_word == SPI_MASTER_2_BYTES_PER_WORD)
100034bc:	697b      	ldr	r3, [r7, #20]
100034be:	2b02      	cmp	r3, #2
100034c0:	d10c      	bne.n	100034dc <SPI_MASTER_lReceiveHandler+0xdc>
        {
          runtime_handle->rx_data[runtime_handle->rx_data_index + 1U] = (uint8_t)((uint16_t)data >> 8);
100034c2:	693b      	ldr	r3, [r7, #16]
100034c4:	695a      	ldr	r2, [r3, #20]
100034c6:	693b      	ldr	r3, [r7, #16]
100034c8:	691b      	ldr	r3, [r3, #16]
100034ca:	3301      	adds	r3, #1
100034cc:	18d3      	adds	r3, r2, r3
100034ce:	220e      	movs	r2, #14
100034d0:	18ba      	adds	r2, r7, r2
100034d2:	8812      	ldrh	r2, [r2, #0]
100034d4:	0a12      	lsrs	r2, r2, #8
100034d6:	b292      	uxth	r2, r2
100034d8:	b2d2      	uxtb	r2, r2
100034da:	701a      	strb	r2, [r3, #0]
        }

        (runtime_handle->rx_data_index)+= bytes_per_word;
100034dc:	693b      	ldr	r3, [r7, #16]
100034de:	691a      	ldr	r2, [r3, #16]
100034e0:	697b      	ldr	r3, [r7, #20]
100034e2:	18d2      	adds	r2, r2, r3
100034e4:	693b      	ldr	r3, [r7, #16]
100034e6:	611a      	str	r2, [r3, #16]
      }
    }
    if ((XMC_USIC_CH_GetReceiveBufferStatus(handle->channel) & (uint32_t)XMC_USIC_CH_RBUF_STATUS_DATA_VALID1) != 0U)
100034e8:	687b      	ldr	r3, [r7, #4]
100034ea:	681b      	ldr	r3, [r3, #0]
100034ec:	1c18      	adds	r0, r3, #0
100034ee:	f7ff fd0d 	bl	10002f0c <XMC_USIC_CH_GetReceiveBufferStatus>
100034f2:	1c02      	adds	r2, r0, #0
100034f4:	2380      	movs	r3, #128	; 0x80
100034f6:	01db      	lsls	r3, r3, #7
100034f8:	4013      	ands	r3, r2
100034fa:	d02e      	beq.n	1000355a <SPI_MASTER_lReceiveHandler+0x15a>
    {
      if (runtime_handle->rx_data_index < runtime_handle->rx_data_count)
100034fc:	693b      	ldr	r3, [r7, #16]
100034fe:	691a      	ldr	r2, [r3, #16]
10003500:	693b      	ldr	r3, [r7, #16]
10003502:	68db      	ldr	r3, [r3, #12]
10003504:	429a      	cmp	r2, r3
10003506:	d228      	bcs.n	1000355a <SPI_MASTER_lReceiveHandler+0x15a>
      {
        data = XMC_SPI_CH_GetReceivedData(handle->channel);
10003508:	687b      	ldr	r3, [r7, #4]
1000350a:	681b      	ldr	r3, [r3, #0]
1000350c:	220e      	movs	r2, #14
1000350e:	18bc      	adds	r4, r7, r2
10003510:	1c18      	adds	r0, r3, #0
10003512:	f7fe fd37 	bl	10001f84 <XMC_SPI_CH_GetReceivedData>
10003516:	1c03      	adds	r3, r0, #0
10003518:	8023      	strh	r3, [r4, #0]

        runtime_handle->rx_data[runtime_handle->rx_data_index] = (uint8_t)data;
1000351a:	693b      	ldr	r3, [r7, #16]
1000351c:	695a      	ldr	r2, [r3, #20]
1000351e:	693b      	ldr	r3, [r7, #16]
10003520:	691b      	ldr	r3, [r3, #16]
10003522:	18d3      	adds	r3, r2, r3
10003524:	220e      	movs	r2, #14
10003526:	18ba      	adds	r2, r7, r2
10003528:	8812      	ldrh	r2, [r2, #0]
1000352a:	b2d2      	uxtb	r2, r2
1000352c:	701a      	strb	r2, [r3, #0]

        if (bytes_per_word == SPI_MASTER_2_BYTES_PER_WORD)
1000352e:	697b      	ldr	r3, [r7, #20]
10003530:	2b02      	cmp	r3, #2
10003532:	d10c      	bne.n	1000354e <SPI_MASTER_lReceiveHandler+0x14e>
        {
          runtime_handle->rx_data[runtime_handle->rx_data_index + 1U] = (uint8_t)((uint16_t)data >> 8);
10003534:	693b      	ldr	r3, [r7, #16]
10003536:	695a      	ldr	r2, [r3, #20]
10003538:	693b      	ldr	r3, [r7, #16]
1000353a:	691b      	ldr	r3, [r3, #16]
1000353c:	3301      	adds	r3, #1
1000353e:	18d3      	adds	r3, r2, r3
10003540:	220e      	movs	r2, #14
10003542:	18ba      	adds	r2, r7, r2
10003544:	8812      	ldrh	r2, [r2, #0]
10003546:	0a12      	lsrs	r2, r2, #8
10003548:	b292      	uxth	r2, r2
1000354a:	b2d2      	uxtb	r2, r2
1000354c:	701a      	strb	r2, [r3, #0]
        }

        (runtime_handle->rx_data_index)+= bytes_per_word;
1000354e:	693b      	ldr	r3, [r7, #16]
10003550:	691a      	ldr	r2, [r3, #16]
10003552:	697b      	ldr	r3, [r7, #20]
10003554:	18d2      	adds	r2, r2, r3
10003556:	693b      	ldr	r3, [r7, #16]
10003558:	611a      	str	r2, [r3, #16]
      }
    }

    if (runtime_handle->rx_data_index == runtime_handle->rx_data_count)
1000355a:	693b      	ldr	r3, [r7, #16]
1000355c:	691a      	ldr	r2, [r3, #16]
1000355e:	693b      	ldr	r3, [r7, #16]
10003560:	68db      	ldr	r3, [r3, #12]
10003562:	429a      	cmp	r2, r3
10003564:	d12d      	bne.n	100035c2 <SPI_MASTER_lReceiveHandler+0x1c2>
    {
      /* Disable both standard receive and alternative receive FIFO events */
      if ((uint32_t)handle->config->rx_fifo_size > 0U)
10003566:	687b      	ldr	r3, [r7, #4]
10003568:	685b      	ldr	r3, [r3, #4]
1000356a:	227d      	movs	r2, #125	; 0x7d
1000356c:	5c9b      	ldrb	r3, [r3, r2]
1000356e:	2b00      	cmp	r3, #0
10003570:	d008      	beq.n	10003584 <SPI_MASTER_lReceiveHandler+0x184>
      {
        /* Enable the receive FIFO events */
        XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,(uint32_t)SPI_MASTER_FIFO_RECEIVE_EVENT);
10003572:	687b      	ldr	r3, [r7, #4]
10003574:	681a      	ldr	r2, [r3, #0]
10003576:	23c0      	movs	r3, #192	; 0xc0
10003578:	05db      	lsls	r3, r3, #23
1000357a:	1c10      	adds	r0, r2, #0
1000357c:	1c19      	adds	r1, r3, #0
1000357e:	f7ff fd4f 	bl	10003020 <XMC_USIC_CH_RXFIFO_DisableEvent>
10003582:	e007      	b.n	10003594 <SPI_MASTER_lReceiveHandler+0x194>
      }
      else
      {
        XMC_SPI_CH_DisableEvent(handle->channel, (uint32_t)SPI_MASTER_RECEIVE_EVENT);
10003584:	687b      	ldr	r3, [r7, #4]
10003586:	681a      	ldr	r2, [r3, #0]
10003588:	23c0      	movs	r3, #192	; 0xc0
1000358a:	021b      	lsls	r3, r3, #8
1000358c:	1c10      	adds	r0, r2, #0
1000358e:	1c19      	adds	r1, r3, #0
10003590:	f7fe fd18 	bl	10001fc4 <XMC_SPI_CH_DisableEvent>
      }
      /* Reception complete */
      runtime_handle->rx_busy = false;
10003594:	693b      	ldr	r3, [r7, #16]
10003596:	2200      	movs	r2, #0
10003598:	77da      	strb	r2, [r3, #31]
      runtime_handle->tx_data_dummy = false;
1000359a:	693b      	ldr	r3, [r7, #16]
1000359c:	2221      	movs	r2, #33	; 0x21
1000359e:	2100      	movs	r1, #0
100035a0:	5499      	strb	r1, [r3, r2]
      runtime_handle->rx_data_dummy = true;
100035a2:	693b      	ldr	r3, [r7, #16]
100035a4:	2222      	movs	r2, #34	; 0x22
100035a6:	2101      	movs	r1, #1
100035a8:	5499      	strb	r1, [r3, r2]
      runtime_handle->rx_data = NULL;
100035aa:	693b      	ldr	r3, [r7, #16]
100035ac:	2200      	movs	r2, #0
100035ae:	615a      	str	r2, [r3, #20]

      if (handle->config->rx_cbhandler != NULL)
100035b0:	687b      	ldr	r3, [r7, #4]
100035b2:	685b      	ldr	r3, [r3, #4]
100035b4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
100035b6:	2b00      	cmp	r3, #0
100035b8:	d003      	beq.n	100035c2 <SPI_MASTER_lReceiveHandler+0x1c2>
      {
        /* Execute the 'End of reception' callback function */
        handle->config->rx_cbhandler();
100035ba:	687b      	ldr	r3, [r7, #4]
100035bc:	685b      	ldr	r3, [r3, #4]
100035be:	6f5b      	ldr	r3, [r3, #116]	; 0x74
100035c0:	4798      	blx	r3
      }
    }
  }
}
100035c2:	46bd      	mov	sp, r7
100035c4:	b007      	add	sp, #28
100035c6:	bd90      	pop	{r4, r7, pc}

100035c8 <SPI_MASTER_lFIFORead>:

/*
 * Read the data from FIFO until it becomes empty.
 */
void SPI_MASTER_lFIFORead(const SPI_MASTER_t * const handle, const uint32_t bytes_per_word)
{
100035c8:	b590      	push	{r4, r7, lr}
100035ca:	b085      	sub	sp, #20
100035cc:	af00      	add	r7, sp, #0
100035ce:	6078      	str	r0, [r7, #4]
100035d0:	6039      	str	r1, [r7, #0]
  SPI_MASTER_RUNTIME_t * runtime_handle;
  uint16_t data;

  runtime_handle = handle->runtime;
100035d2:	687b      	ldr	r3, [r7, #4]
100035d4:	689b      	ldr	r3, [r3, #8]
100035d6:	60fb      	str	r3, [r7, #12]
  data = 0U;
100035d8:	230a      	movs	r3, #10
100035da:	18fb      	adds	r3, r7, r3
100035dc:	2200      	movs	r2, #0
100035de:	801a      	strh	r2, [r3, #0]

  /* When Receive FIFO is enabled*/
  while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
100035e0:	e04e      	b.n	10003680 <SPI_MASTER_lFIFORead+0xb8>
  {
    if (runtime_handle->rx_data_index < runtime_handle->rx_data_count)
100035e2:	68fb      	ldr	r3, [r7, #12]
100035e4:	691a      	ldr	r2, [r3, #16]
100035e6:	68fb      	ldr	r3, [r7, #12]
100035e8:	68db      	ldr	r3, [r3, #12]
100035ea:	429a      	cmp	r2, r3
100035ec:	d228      	bcs.n	10003640 <SPI_MASTER_lFIFORead+0x78>
    {
      data = XMC_SPI_CH_GetReceivedData(handle->channel);
100035ee:	687b      	ldr	r3, [r7, #4]
100035f0:	681b      	ldr	r3, [r3, #0]
100035f2:	220a      	movs	r2, #10
100035f4:	18bc      	adds	r4, r7, r2
100035f6:	1c18      	adds	r0, r3, #0
100035f8:	f7fe fcc4 	bl	10001f84 <XMC_SPI_CH_GetReceivedData>
100035fc:	1c03      	adds	r3, r0, #0
100035fe:	8023      	strh	r3, [r4, #0]
      runtime_handle->rx_data[runtime_handle->rx_data_index] = (uint8_t)data;
10003600:	68fb      	ldr	r3, [r7, #12]
10003602:	695a      	ldr	r2, [r3, #20]
10003604:	68fb      	ldr	r3, [r7, #12]
10003606:	691b      	ldr	r3, [r3, #16]
10003608:	18d3      	adds	r3, r2, r3
1000360a:	220a      	movs	r2, #10
1000360c:	18ba      	adds	r2, r7, r2
1000360e:	8812      	ldrh	r2, [r2, #0]
10003610:	b2d2      	uxtb	r2, r2
10003612:	701a      	strb	r2, [r3, #0]

      if (bytes_per_word == SPI_MASTER_2_BYTES_PER_WORD)
10003614:	683b      	ldr	r3, [r7, #0]
10003616:	2b02      	cmp	r3, #2
10003618:	d10c      	bne.n	10003634 <SPI_MASTER_lFIFORead+0x6c>
      {
        runtime_handle->rx_data[runtime_handle->rx_data_index + 1U] = (uint8_t)((uint16_t)data >> 8);
1000361a:	68fb      	ldr	r3, [r7, #12]
1000361c:	695a      	ldr	r2, [r3, #20]
1000361e:	68fb      	ldr	r3, [r7, #12]
10003620:	691b      	ldr	r3, [r3, #16]
10003622:	3301      	adds	r3, #1
10003624:	18d3      	adds	r3, r2, r3
10003626:	220a      	movs	r2, #10
10003628:	18ba      	adds	r2, r7, r2
1000362a:	8812      	ldrh	r2, [r2, #0]
1000362c:	0a12      	lsrs	r2, r2, #8
1000362e:	b292      	uxth	r2, r2
10003630:	b2d2      	uxtb	r2, r2
10003632:	701a      	strb	r2, [r3, #0]
      }
      (runtime_handle->rx_data_index)+= bytes_per_word;
10003634:	68fb      	ldr	r3, [r7, #12]
10003636:	691a      	ldr	r2, [r3, #16]
10003638:	683b      	ldr	r3, [r7, #0]
1000363a:	18d2      	adds	r2, r2, r3
1000363c:	68fb      	ldr	r3, [r7, #12]
1000363e:	611a      	str	r2, [r3, #16]
    }

    if (runtime_handle->rx_data_index == runtime_handle->rx_data_count)
10003640:	68fb      	ldr	r3, [r7, #12]
10003642:	691a      	ldr	r2, [r3, #16]
10003644:	68fb      	ldr	r3, [r7, #12]
10003646:	68db      	ldr	r3, [r3, #12]
10003648:	429a      	cmp	r2, r3
1000364a:	d119      	bne.n	10003680 <SPI_MASTER_lFIFORead+0xb8>
    {
      /*Reception complete*/
      runtime_handle->rx_busy = false;
1000364c:	68fb      	ldr	r3, [r7, #12]
1000364e:	2200      	movs	r2, #0
10003650:	77da      	strb	r2, [r3, #31]
      runtime_handle->tx_data_dummy = false;
10003652:	68fb      	ldr	r3, [r7, #12]
10003654:	2221      	movs	r2, #33	; 0x21
10003656:	2100      	movs	r1, #0
10003658:	5499      	strb	r1, [r3, r2]
      /*Disable both standard receive and alternative receive FIFO events*/
      XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,(uint32_t)SPI_MASTER_FIFO_RECEIVE_EVENT);
1000365a:	687b      	ldr	r3, [r7, #4]
1000365c:	681a      	ldr	r2, [r3, #0]
1000365e:	23c0      	movs	r3, #192	; 0xc0
10003660:	05db      	lsls	r3, r3, #23
10003662:	1c10      	adds	r0, r2, #0
10003664:	1c19      	adds	r1, r3, #0
10003666:	f7ff fcdb 	bl	10003020 <XMC_USIC_CH_RXFIFO_DisableEvent>
      if (handle->config->rx_cbhandler != NULL)
1000366a:	687b      	ldr	r3, [r7, #4]
1000366c:	685b      	ldr	r3, [r3, #4]
1000366e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
10003670:	2b00      	cmp	r3, #0
10003672:	d004      	beq.n	1000367e <SPI_MASTER_lFIFORead+0xb6>
      {
        /* Execute the 'End of reception' callback function */
        handle->config->rx_cbhandler();
10003674:	687b      	ldr	r3, [r7, #4]
10003676:	685b      	ldr	r3, [r3, #4]
10003678:	6f5b      	ldr	r3, [r3, #116]	; 0x74
1000367a:	4798      	blx	r3
      }
      break;
1000367c:	e00c      	b.n	10003698 <SPI_MASTER_lFIFORead+0xd0>
1000367e:	e00b      	b.n	10003698 <SPI_MASTER_lFIFORead+0xd0>

  runtime_handle = handle->runtime;
  data = 0U;

  /* When Receive FIFO is enabled*/
  while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
10003680:	687b      	ldr	r3, [r7, #4]
10003682:	681b      	ldr	r3, [r3, #0]
10003684:	1c18      	adds	r0, r3, #0
10003686:	f7ff fcdf 	bl	10003048 <XMC_USIC_CH_RXFIFO_IsEmpty>
1000368a:	1c03      	adds	r3, r0, #0
1000368c:	1c1a      	adds	r2, r3, #0
1000368e:	2301      	movs	r3, #1
10003690:	4053      	eors	r3, r2
10003692:	b2db      	uxtb	r3, r3
10003694:	2b00      	cmp	r3, #0
10003696:	d1a4      	bne.n	100035e2 <SPI_MASTER_lFIFORead+0x1a>
        handle->config->rx_cbhandler();
      }
      break;
    }
  }
}
10003698:	46bd      	mov	sp, r7
1000369a:	b005      	add	sp, #20
1000369c:	bd90      	pop	{r4, r7, pc}
1000369e:	46c0      	nop			; (mov r8, r8)

100036a0 <SPI_MASTER_lReconfigureRxFIFO>:

/*
 * This function configures the FIFO settings
 */
static void SPI_MASTER_lReconfigureRxFIFO(const SPI_MASTER_t * const handle, uint32_t data_size)
{
100036a0:	b580      	push	{r7, lr}
100036a2:	b084      	sub	sp, #16
100036a4:	af00      	add	r7, sp, #0
100036a6:	6078      	str	r0, [r7, #4]
100036a8:	6039      	str	r1, [r7, #0]
  uint32_t fifo_size;
  uint32_t ret_limit_val;

  if (((uint32_t)handle->config->rx_fifo_size > 0U) && (data_size > 0U))
100036aa:	687b      	ldr	r3, [r7, #4]
100036ac:	685b      	ldr	r3, [r3, #4]
100036ae:	227d      	movs	r2, #125	; 0x7d
100036b0:	5c9b      	ldrb	r3, [r3, r2]
100036b2:	2b00      	cmp	r3, #0
100036b4:	d029      	beq.n	1000370a <SPI_MASTER_lReconfigureRxFIFO+0x6a>
100036b6:	683b      	ldr	r3, [r7, #0]
100036b8:	2b00      	cmp	r3, #0
100036ba:	d026      	beq.n	1000370a <SPI_MASTER_lReconfigureRxFIFO+0x6a>
  {
	fifo_size = 1UL << (handle->config->rx_fifo_size - 1);
100036bc:	687b      	ldr	r3, [r7, #4]
100036be:	685b      	ldr	r3, [r3, #4]
100036c0:	227d      	movs	r2, #125	; 0x7d
100036c2:	5c9b      	ldrb	r3, [r3, r2]
100036c4:	3b01      	subs	r3, #1
100036c6:	2201      	movs	r2, #1
100036c8:	409a      	lsls	r2, r3
100036ca:	1c13      	adds	r3, r2, #0
100036cc:	60bb      	str	r3, [r7, #8]

    if (handle->runtime->word_length > SPI_MASTER_WORD_LENGTH_8_BIT)
100036ce:	687b      	ldr	r3, [r7, #4]
100036d0:	689b      	ldr	r3, [r3, #8]
100036d2:	681b      	ldr	r3, [r3, #0]
100036d4:	2b08      	cmp	r3, #8
100036d6:	d902      	bls.n	100036de <SPI_MASTER_lReconfigureRxFIFO+0x3e>
	{
	  /* Data size is divided by 2, to change the trigger limit according the word length */
	  data_size = (uint32_t)data_size >> 1U;
100036d8:	683b      	ldr	r3, [r7, #0]
100036da:	085b      	lsrs	r3, r3, #1
100036dc:	603b      	str	r3, [r7, #0]
	}

	/*If data size is more than FIFO size, configure the limit to the FIFO size*/
	if (data_size <= fifo_size)
100036de:	683a      	ldr	r2, [r7, #0]
100036e0:	68bb      	ldr	r3, [r7, #8]
100036e2:	429a      	cmp	r2, r3
100036e4:	d803      	bhi.n	100036ee <SPI_MASTER_lReconfigureRxFIFO+0x4e>
	{
	  ret_limit_val = data_size - 1U;
100036e6:	683b      	ldr	r3, [r7, #0]
100036e8:	3b01      	subs	r3, #1
100036ea:	60fb      	str	r3, [r7, #12]
100036ec:	e001      	b.n	100036f2 <SPI_MASTER_lReconfigureRxFIFO+0x52>
	}
	else
	{
	  ret_limit_val = fifo_size;
100036ee:	68bb      	ldr	r3, [r7, #8]
100036f0:	60fb      	str	r3, [r7, #12]
	}

	/*Set the limit value*/
	XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel, handle->config->rx_fifo_size, ret_limit_val);
100036f2:	687b      	ldr	r3, [r7, #4]
100036f4:	6819      	ldr	r1, [r3, #0]
100036f6:	687b      	ldr	r3, [r7, #4]
100036f8:	685b      	ldr	r3, [r3, #4]
100036fa:	227d      	movs	r2, #125	; 0x7d
100036fc:	5c9a      	ldrb	r2, [r3, r2]
100036fe:	68fb      	ldr	r3, [r7, #12]
10003700:	1c08      	adds	r0, r1, #0
10003702:	1c11      	adds	r1, r2, #0
10003704:	1c1a      	adds	r2, r3, #0
10003706:	f7fe feeb 	bl	100024e0 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit>
  }
}
1000370a:	46bd      	mov	sp, r7
1000370c:	b004      	add	sp, #16
1000370e:	bd80      	pop	{r7, pc}

10003710 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
10003710:	b580      	push	{r7, lr}
10003712:	b082      	sub	sp, #8
10003714:	af00      	add	r7, sp, #0
10003716:	1c02      	adds	r2, r0, #0
10003718:	1dfb      	adds	r3, r7, #7
1000371a:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
1000371c:	1dfb      	adds	r3, r7, #7
1000371e:	781b      	ldrb	r3, [r3, #0]
10003720:	2b7f      	cmp	r3, #127	; 0x7f
10003722:	d809      	bhi.n	10003738 <__NVIC_EnableIRQ+0x28>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
10003724:	4b06      	ldr	r3, [pc, #24]	; (10003740 <__NVIC_EnableIRQ+0x30>)
10003726:	1dfa      	adds	r2, r7, #7
10003728:	7812      	ldrb	r2, [r2, #0]
1000372a:	1c11      	adds	r1, r2, #0
1000372c:	221f      	movs	r2, #31
1000372e:	400a      	ands	r2, r1
10003730:	2101      	movs	r1, #1
10003732:	4091      	lsls	r1, r2
10003734:	1c0a      	adds	r2, r1, #0
10003736:	601a      	str	r2, [r3, #0]
    __COMPILER_BARRIER();
  }
}
10003738:	46bd      	mov	sp, r7
1000373a:	b002      	add	sp, #8
1000373c:	bd80      	pop	{r7, pc}
1000373e:	46c0      	nop			; (mov r8, r8)
10003740:	e000e100 	.word	0xe000e100

10003744 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
10003744:	b5b0      	push	{r4, r5, r7, lr}
10003746:	b082      	sub	sp, #8
10003748:	af00      	add	r7, sp, #0
1000374a:	1c02      	adds	r2, r0, #0
1000374c:	6039      	str	r1, [r7, #0]
1000374e:	1dfb      	adds	r3, r7, #7
10003750:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10003752:	1dfb      	adds	r3, r7, #7
10003754:	781b      	ldrb	r3, [r3, #0]
10003756:	2b7f      	cmp	r3, #127	; 0x7f
10003758:	d827      	bhi.n	100037aa <__NVIC_SetPriority+0x66>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1000375a:	4c2d      	ldr	r4, [pc, #180]	; (10003810 <__NVIC_SetPriority+0xcc>)
1000375c:	1dfb      	adds	r3, r7, #7
1000375e:	781b      	ldrb	r3, [r3, #0]
10003760:	b25b      	sxtb	r3, r3
10003762:	089b      	lsrs	r3, r3, #2
10003764:	492a      	ldr	r1, [pc, #168]	; (10003810 <__NVIC_SetPriority+0xcc>)
10003766:	1dfa      	adds	r2, r7, #7
10003768:	7812      	ldrb	r2, [r2, #0]
1000376a:	b252      	sxtb	r2, r2
1000376c:	0892      	lsrs	r2, r2, #2
1000376e:	32c0      	adds	r2, #192	; 0xc0
10003770:	0092      	lsls	r2, r2, #2
10003772:	5852      	ldr	r2, [r2, r1]
10003774:	1df9      	adds	r1, r7, #7
10003776:	7809      	ldrb	r1, [r1, #0]
10003778:	1c08      	adds	r0, r1, #0
1000377a:	2103      	movs	r1, #3
1000377c:	4001      	ands	r1, r0
1000377e:	00c9      	lsls	r1, r1, #3
10003780:	1c08      	adds	r0, r1, #0
10003782:	21ff      	movs	r1, #255	; 0xff
10003784:	4081      	lsls	r1, r0
10003786:	43c9      	mvns	r1, r1
10003788:	4011      	ands	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
1000378a:	683a      	ldr	r2, [r7, #0]
1000378c:	0192      	lsls	r2, r2, #6
1000378e:	20ff      	movs	r0, #255	; 0xff
10003790:	4002      	ands	r2, r0
10003792:	1df8      	adds	r0, r7, #7
10003794:	7800      	ldrb	r0, [r0, #0]
10003796:	1c05      	adds	r5, r0, #0
10003798:	2003      	movs	r0, #3
1000379a:	4028      	ands	r0, r5
1000379c:	00c0      	lsls	r0, r0, #3
1000379e:	4082      	lsls	r2, r0
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100037a0:	430a      	orrs	r2, r1
100037a2:	33c0      	adds	r3, #192	; 0xc0
100037a4:	009b      	lsls	r3, r3, #2
100037a6:	511a      	str	r2, [r3, r4]
100037a8:	e02e      	b.n	10003808 <__NVIC_SetPriority+0xc4>
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100037aa:	4c1a      	ldr	r4, [pc, #104]	; (10003814 <__NVIC_SetPriority+0xd0>)
100037ac:	1dfb      	adds	r3, r7, #7
100037ae:	781b      	ldrb	r3, [r3, #0]
100037b0:	1c1a      	adds	r2, r3, #0
100037b2:	230f      	movs	r3, #15
100037b4:	4013      	ands	r3, r2
100037b6:	3b08      	subs	r3, #8
100037b8:	0899      	lsrs	r1, r3, #2
100037ba:	4a16      	ldr	r2, [pc, #88]	; (10003814 <__NVIC_SetPriority+0xd0>)
100037bc:	1dfb      	adds	r3, r7, #7
100037be:	781b      	ldrb	r3, [r3, #0]
100037c0:	1c18      	adds	r0, r3, #0
100037c2:	230f      	movs	r3, #15
100037c4:	4003      	ands	r3, r0
100037c6:	3b08      	subs	r3, #8
100037c8:	089b      	lsrs	r3, r3, #2
100037ca:	3306      	adds	r3, #6
100037cc:	009b      	lsls	r3, r3, #2
100037ce:	18d3      	adds	r3, r2, r3
100037d0:	685b      	ldr	r3, [r3, #4]
100037d2:	1dfa      	adds	r2, r7, #7
100037d4:	7812      	ldrb	r2, [r2, #0]
100037d6:	1c10      	adds	r0, r2, #0
100037d8:	2203      	movs	r2, #3
100037da:	4002      	ands	r2, r0
100037dc:	00d2      	lsls	r2, r2, #3
100037de:	1c10      	adds	r0, r2, #0
100037e0:	22ff      	movs	r2, #255	; 0xff
100037e2:	4082      	lsls	r2, r0
100037e4:	43d2      	mvns	r2, r2
100037e6:	401a      	ands	r2, r3
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
100037e8:	683b      	ldr	r3, [r7, #0]
100037ea:	019b      	lsls	r3, r3, #6
100037ec:	20ff      	movs	r0, #255	; 0xff
100037ee:	4003      	ands	r3, r0
100037f0:	1df8      	adds	r0, r7, #7
100037f2:	7800      	ldrb	r0, [r0, #0]
100037f4:	1c05      	adds	r5, r0, #0
100037f6:	2003      	movs	r0, #3
100037f8:	4028      	ands	r0, r5
100037fa:	00c0      	lsls	r0, r0, #3
100037fc:	4083      	lsls	r3, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100037fe:	431a      	orrs	r2, r3
10003800:	1d8b      	adds	r3, r1, #6
10003802:	009b      	lsls	r3, r3, #2
10003804:	18e3      	adds	r3, r4, r3
10003806:	605a      	str	r2, [r3, #4]
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
10003808:	46bd      	mov	sp, r7
1000380a:	b002      	add	sp, #8
1000380c:	bdb0      	pop	{r4, r5, r7, pc}
1000380e:	46c0      	nop			; (mov r8, r8)
10003810:	e000e100 	.word	0xe000e100
10003814:	e000ed00 	.word	0xe000ed00

10003818 <XMC_USIC_CH_SetInputSource>:
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
10003818:	b580      	push	{r7, lr}
1000381a:	b082      	sub	sp, #8
1000381c:	af00      	add	r7, sp, #0
1000381e:	6078      	str	r0, [r7, #4]
10003820:	1c08      	adds	r0, r1, #0
10003822:	1c11      	adds	r1, r2, #0
10003824:	1cfb      	adds	r3, r7, #3
10003826:	1c02      	adds	r2, r0, #0
10003828:	701a      	strb	r2, [r3, #0]
1000382a:	1cbb      	adds	r3, r7, #2
1000382c:	1c0a      	adds	r2, r1, #0
1000382e:	701a      	strb	r2, [r3, #0]
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
10003830:	1cfb      	adds	r3, r7, #3
10003832:	7818      	ldrb	r0, [r3, #0]
10003834:	1cfb      	adds	r3, r7, #3
10003836:	781b      	ldrb	r3, [r3, #0]
10003838:	687a      	ldr	r2, [r7, #4]
1000383a:	3306      	adds	r3, #6
1000383c:	009b      	lsls	r3, r3, #2
1000383e:	18d3      	adds	r3, r2, r3
10003840:	685b      	ldr	r3, [r3, #4]
10003842:	2207      	movs	r2, #7
10003844:	4393      	bics	r3, r2
10003846:	1c1a      	adds	r2, r3, #0
                                    ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
10003848:	1cbb      	adds	r3, r7, #2
1000384a:	781b      	ldrb	r3, [r3, #0]
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
1000384c:	431a      	orrs	r2, r3
1000384e:	6879      	ldr	r1, [r7, #4]
10003850:	1d83      	adds	r3, r0, #6
10003852:	009b      	lsls	r3, r3, #2
10003854:	18cb      	adds	r3, r1, r3
10003856:	605a      	str	r2, [r3, #4]
                                    ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
}
10003858:	46bd      	mov	sp, r7
1000385a:	b002      	add	sp, #8
1000385c:	bd80      	pop	{r7, pc}
1000385e:	46c0      	nop			; (mov r8, r8)

10003860 <XMC_USIC_CH_SetWordLength>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetFrameLength()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetWordLength(XMC_USIC_CH_t *const channel, const uint8_t word_length)
{
10003860:	b580      	push	{r7, lr}
10003862:	b082      	sub	sp, #8
10003864:	af00      	add	r7, sp, #0
10003866:	6078      	str	r0, [r7, #4]
10003868:	1c0a      	adds	r2, r1, #0
1000386a:	1cfb      	adds	r3, r7, #3
1000386c:	701a      	strb	r2, [r3, #0]
  channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_WLE_Msk)) |
1000386e:	687b      	ldr	r3, [r7, #4]
10003870:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10003872:	4a06      	ldr	r2, [pc, #24]	; (1000388c <XMC_USIC_CH_SetWordLength+0x2c>)
10003874:	401a      	ands	r2, r3
                  (uint32_t)(((uint32_t)word_length - 1UL)  << USIC_CH_SCTR_WLE_Pos);
10003876:	1cfb      	adds	r3, r7, #3
10003878:	781b      	ldrb	r3, [r3, #0]
1000387a:	3b01      	subs	r3, #1
1000387c:	061b      	lsls	r3, r3, #24
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetFrameLength()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetWordLength(XMC_USIC_CH_t *const channel, const uint8_t word_length)
{
  channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_WLE_Msk)) |
1000387e:	431a      	orrs	r2, r3
10003880:	687b      	ldr	r3, [r7, #4]
10003882:	635a      	str	r2, [r3, #52]	; 0x34
                  (uint32_t)(((uint32_t)word_length - 1UL)  << USIC_CH_SCTR_WLE_Pos);
}
10003884:	46bd      	mov	sp, r7
10003886:	b002      	add	sp, #8
10003888:	bd80      	pop	{r7, pc}
1000388a:	46c0      	nop			; (mov r8, r8)
1000388c:	f0ffffff 	.word	0xf0ffffff

10003890 <XMC_USIC_CH_SetFrameLength>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetWordLength(), XMC_USIC_CH_EnableFrameLengthControl() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetFrameLength(XMC_USIC_CH_t *const channel, const uint8_t frame_length)
{
10003890:	b580      	push	{r7, lr}
10003892:	b082      	sub	sp, #8
10003894:	af00      	add	r7, sp, #0
10003896:	6078      	str	r0, [r7, #4]
10003898:	1c0a      	adds	r2, r1, #0
1000389a:	1cfb      	adds	r3, r7, #3
1000389c:	701a      	strb	r2, [r3, #0]
  channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_FLE_Msk)) |
1000389e:	687b      	ldr	r3, [r7, #4]
100038a0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
100038a2:	4a06      	ldr	r2, [pc, #24]	; (100038bc <XMC_USIC_CH_SetFrameLength+0x2c>)
100038a4:	401a      	ands	r2, r3
                  (((uint32_t)frame_length - 0x1U)  << USIC_CH_SCTR_FLE_Pos);
100038a6:	1cfb      	adds	r3, r7, #3
100038a8:	781b      	ldrb	r3, [r3, #0]
100038aa:	3b01      	subs	r3, #1
100038ac:	041b      	lsls	r3, r3, #16
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetWordLength(), XMC_USIC_CH_EnableFrameLengthControl() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetFrameLength(XMC_USIC_CH_t *const channel, const uint8_t frame_length)
{
  channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_FLE_Msk)) |
100038ae:	431a      	orrs	r2, r3
100038b0:	687b      	ldr	r3, [r7, #4]
100038b2:	635a      	str	r2, [r3, #52]	; 0x34
                  (((uint32_t)frame_length - 0x1U)  << USIC_CH_SCTR_FLE_Pos);
}
100038b4:	46bd      	mov	sp, r7
100038b6:	b002      	add	sp, #8
100038b8:	bd80      	pop	{r7, pc}
100038ba:	46c0      	nop			; (mov r8, r8)
100038bc:	ffc0ffff 	.word	0xffc0ffff

100038c0 <XMC_USIC_CH_ConfigureShiftClockOutput>:
 *
 */
__STATIC_INLINE void XMC_USIC_CH_ConfigureShiftClockOutput(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t passive_level,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t clock_output)
{
100038c0:	b580      	push	{r7, lr}
100038c2:	b084      	sub	sp, #16
100038c4:	af00      	add	r7, sp, #0
100038c6:	60f8      	str	r0, [r7, #12]
100038c8:	60b9      	str	r1, [r7, #8]
100038ca:	607a      	str	r2, [r7, #4]
  channel->BRG = (uint32_t)(channel->BRG & (~(USIC_CH_BRG_SCLKCFG_Msk |
100038cc:	68fb      	ldr	r3, [r7, #12]
100038ce:	695b      	ldr	r3, [r3, #20]
100038d0:	4a05      	ldr	r2, [pc, #20]	; (100038e8 <XMC_USIC_CH_ConfigureShiftClockOutput+0x28>)
100038d2:	401a      	ands	r2, r3
                            USIC_CH_BRG_SCLKOSEL_Msk))) |
                 (uint32_t)passive_level |
100038d4:	68bb      	ldr	r3, [r7, #8]
__STATIC_INLINE void XMC_USIC_CH_ConfigureShiftClockOutput(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t passive_level,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t clock_output)
{
  channel->BRG = (uint32_t)(channel->BRG & (~(USIC_CH_BRG_SCLKCFG_Msk |
                            USIC_CH_BRG_SCLKOSEL_Msk))) |
100038d6:	431a      	orrs	r2, r3
                 (uint32_t)passive_level |
100038d8:	687b      	ldr	r3, [r7, #4]
100038da:	431a      	orrs	r2, r3
 */
__STATIC_INLINE void XMC_USIC_CH_ConfigureShiftClockOutput(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t passive_level,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t clock_output)
{
  channel->BRG = (uint32_t)(channel->BRG & (~(USIC_CH_BRG_SCLKCFG_Msk |
100038dc:	68fb      	ldr	r3, [r7, #12]
100038de:	615a      	str	r2, [r3, #20]
                            USIC_CH_BRG_SCLKOSEL_Msk))) |
                 (uint32_t)passive_level |
                 (uint32_t)clock_output;
}
100038e0:	46bd      	mov	sp, r7
100038e2:	b004      	add	sp, #16
100038e4:	bd80      	pop	{r7, pc}
100038e6:	46c0      	nop			; (mov r8, r8)
100038e8:	2fffffff 	.word	0x2fffffff

100038ec <XMC_USIC_CH_SetMode>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_Enable(), XMC_USIC_CH_Enable() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetMode(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_OPERATING_MODE_t mode)
{
100038ec:	b580      	push	{r7, lr}
100038ee:	b082      	sub	sp, #8
100038f0:	af00      	add	r7, sp, #0
100038f2:	6078      	str	r0, [r7, #4]
100038f4:	1c0a      	adds	r2, r1, #0
100038f6:	1cfb      	adds	r3, r7, #3
100038f8:	701a      	strb	r2, [r3, #0]
  channel->CCR = (uint32_t)(channel->CCR & (~(USIC_CH_CCR_MODE_Msk))) | (uint32_t)mode;
100038fa:	687b      	ldr	r3, [r7, #4]
100038fc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100038fe:	220f      	movs	r2, #15
10003900:	4393      	bics	r3, r2
10003902:	1c1a      	adds	r2, r3, #0
10003904:	1cfb      	adds	r3, r7, #3
10003906:	781b      	ldrb	r3, [r3, #0]
10003908:	431a      	orrs	r2, r3
1000390a:	687b      	ldr	r3, [r7, #4]
1000390c:	641a      	str	r2, [r3, #64]	; 0x40
}
1000390e:	46bd      	mov	sp, r7
10003910:	b002      	add	sp, #8
10003912:	bd80      	pop	{r7, pc}

10003914 <XMC_SPI_CH_Init>:
 * <li>Set polarity for the Slave signal,</li>
 * <li>Enable Frame end mode(MSLS signal is kept active after transmission of a frame)</li>
 * </ul>
 */
__STATIC_INLINE void XMC_SPI_CH_Init(XMC_USIC_CH_t *const channel, const XMC_SPI_CH_CONFIG_t *const config)
{
10003914:	b580      	push	{r7, lr}
10003916:	b082      	sub	sp, #8
10003918:	af00      	add	r7, sp, #0
1000391a:	6078      	str	r0, [r7, #4]
1000391c:	6039      	str	r1, [r7, #0]
  XMC_SPI_CH_InitEx(channel, config, true);
1000391e:	687a      	ldr	r2, [r7, #4]
10003920:	683b      	ldr	r3, [r7, #0]
10003922:	1c10      	adds	r0, r2, #0
10003924:	1c19      	adds	r1, r3, #0
10003926:	2201      	movs	r2, #1
10003928:	f7fe facc 	bl	10001ec4 <XMC_SPI_CH_InitEx>
}
1000392c:	46bd      	mov	sp, r7
1000392e:	b002      	add	sp, #8
10003930:	bd80      	pop	{r7, pc}
10003932:	46c0      	nop			; (mov r8, r8)

10003934 <XMC_SPI_CH_Start>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SPI_CH_Init(), XMC_SPI_CH_Stop()
 */
__STATIC_INLINE void XMC_SPI_CH_Start(XMC_USIC_CH_t *const channel)
{
10003934:	b580      	push	{r7, lr}
10003936:	b082      	sub	sp, #8
10003938:	af00      	add	r7, sp, #0
1000393a:	6078      	str	r0, [r7, #4]
  /* USIC channel in SPI mode */
  XMC_USIC_CH_SetMode(channel, XMC_USIC_CH_OPERATING_MODE_SPI);
1000393c:	687b      	ldr	r3, [r7, #4]
1000393e:	1c18      	adds	r0, r3, #0
10003940:	2101      	movs	r1, #1
10003942:	f7ff ffd3 	bl	100038ec <XMC_USIC_CH_SetMode>
}
10003946:	46bd      	mov	sp, r7
10003948:	b002      	add	sp, #8
1000394a:	bd80      	pop	{r7, pc}

1000394c <XMC_SPI_CH_SetBitOrderMsbFirst>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SPI_CH_SetBitOrderLsbFirst()
 */
__STATIC_INLINE void XMC_SPI_CH_SetBitOrderMsbFirst(XMC_USIC_CH_t *const channel)
{
1000394c:	b580      	push	{r7, lr}
1000394e:	b082      	sub	sp, #8
10003950:	af00      	add	r7, sp, #0
10003952:	6078      	str	r0, [r7, #4]
  channel->SCTR |= (uint32_t)USIC_CH_SCTR_SDIR_Msk;
10003954:	687b      	ldr	r3, [r7, #4]
10003956:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10003958:	2201      	movs	r2, #1
1000395a:	431a      	orrs	r2, r3
1000395c:	687b      	ldr	r3, [r7, #4]
1000395e:	635a      	str	r2, [r3, #52]	; 0x34
}
10003960:	46bd      	mov	sp, r7
10003962:	b002      	add	sp, #8
10003964:	bd80      	pop	{r7, pc}
10003966:	46c0      	nop			; (mov r8, r8)

10003968 <XMC_SPI_CH_SetSlaveSelectDelay>:
 * This delay is dependent on the peripheral clock. The maximum possible value supported by this API
 * is 30 clock cycles.
 *
 */
__STATIC_INLINE void XMC_SPI_CH_SetSlaveSelectDelay(XMC_USIC_CH_t *const channel, uint32_t sclk_period)
{
10003968:	b580      	push	{r7, lr}
1000396a:	b082      	sub	sp, #8
1000396c:	af00      	add	r7, sp, #0
1000396e:	6078      	str	r0, [r7, #4]
10003970:	6039      	str	r1, [r7, #0]

  channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
10003972:	687b      	ldr	r3, [r7, #4]
10003974:	695b      	ldr	r3, [r3, #20]
10003976:	4a07      	ldr	r2, [pc, #28]	; (10003994 <XMC_SPI_CH_SetSlaveSelectDelay+0x2c>)
10003978:	401a      	ands	r2, r3
                                   USIC_CH_BRG_PCTQ_Msk)) |
                 (((sclk_period - 1U) << USIC_CH_BRG_DCTQ_Pos) | (0x01U << USIC_CH_BRG_PCTQ_Pos));
1000397a:	683b      	ldr	r3, [r7, #0]
1000397c:	3b01      	subs	r3, #1
1000397e:	029b      	lsls	r3, r3, #10
 */
__STATIC_INLINE void XMC_SPI_CH_SetSlaveSelectDelay(XMC_USIC_CH_t *const channel, uint32_t sclk_period)
{

  channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                   USIC_CH_BRG_PCTQ_Msk)) |
10003980:	4313      	orrs	r3, r2
10003982:	2280      	movs	r2, #128	; 0x80
10003984:	0052      	lsls	r2, r2, #1
10003986:	431a      	orrs	r2, r3
 *
 */
__STATIC_INLINE void XMC_SPI_CH_SetSlaveSelectDelay(XMC_USIC_CH_t *const channel, uint32_t sclk_period)
{

  channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
10003988:	687b      	ldr	r3, [r7, #4]
1000398a:	615a      	str	r2, [r3, #20]
                                   USIC_CH_BRG_PCTQ_Msk)) |
                 (((sclk_period - 1U) << USIC_CH_BRG_DCTQ_Pos) | (0x01U << USIC_CH_BRG_PCTQ_Pos));
}
1000398c:	46bd      	mov	sp, r7
1000398e:	b002      	add	sp, #8
10003990:	bd80      	pop	{r7, pc}
10003992:	46c0      	nop			; (mov r8, r8)
10003994:	ffff80ff 	.word	0xffff80ff

10003998 <XMC_SPI_CH_ConfigureShiftClockOutput>:
 * period. These settings are applicable only in master mode.
 */
__STATIC_INLINE void XMC_SPI_CH_ConfigureShiftClockOutput(XMC_USIC_CH_t *const channel,
    const XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t passive_level,
    const XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_t clock_output)
{
10003998:	b580      	push	{r7, lr}
1000399a:	b084      	sub	sp, #16
1000399c:	af00      	add	r7, sp, #0
1000399e:	60f8      	str	r0, [r7, #12]
100039a0:	60b9      	str	r1, [r7, #8]
100039a2:	607a      	str	r2, [r7, #4]
  XMC_USIC_CH_ConfigureShiftClockOutput(channel, (XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t)passive_level,
100039a4:	68f9      	ldr	r1, [r7, #12]
100039a6:	68ba      	ldr	r2, [r7, #8]
100039a8:	687b      	ldr	r3, [r7, #4]
100039aa:	1c08      	adds	r0, r1, #0
100039ac:	1c11      	adds	r1, r2, #0
100039ae:	1c1a      	adds	r2, r3, #0
100039b0:	f7ff ff86 	bl	100038c0 <XMC_USIC_CH_ConfigureShiftClockOutput>
                                        (XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t)clock_output);
}
100039b4:	46bd      	mov	sp, r7
100039b6:	b004      	add	sp, #16
100039b8:	bd80      	pop	{r7, pc}
100039ba:	46c0      	nop			; (mov r8, r8)

100039bc <XMC_SPI_CH_SetWordLength>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SPI_CH_SetFrameLength()
 */
__STATIC_INLINE void XMC_SPI_CH_SetWordLength(XMC_USIC_CH_t *const channel, const uint8_t word_length)
{
100039bc:	b580      	push	{r7, lr}
100039be:	b082      	sub	sp, #8
100039c0:	af00      	add	r7, sp, #0
100039c2:	6078      	str	r0, [r7, #4]
100039c4:	1c0a      	adds	r2, r1, #0
100039c6:	1cfb      	adds	r3, r7, #3
100039c8:	701a      	strb	r2, [r3, #0]
  XMC_USIC_CH_SetWordLength(channel, word_length);
100039ca:	687a      	ldr	r2, [r7, #4]
100039cc:	1cfb      	adds	r3, r7, #3
100039ce:	781b      	ldrb	r3, [r3, #0]
100039d0:	1c10      	adds	r0, r2, #0
100039d2:	1c19      	adds	r1, r3, #0
100039d4:	f7ff ff44 	bl	10003860 <XMC_USIC_CH_SetWordLength>
}
100039d8:	46bd      	mov	sp, r7
100039da:	b002      	add	sp, #8
100039dc:	bd80      	pop	{r7, pc}
100039de:	46c0      	nop			; (mov r8, r8)

100039e0 <XMC_SPI_CH_SetFrameLength>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetWordLength(), XMC_USIC_CH_EnableFrameLengthControl(), XMC_SPI_CH_DisableSlaveSelect()
 */
__STATIC_INLINE void XMC_SPI_CH_SetFrameLength(XMC_USIC_CH_t *const channel, const uint8_t frame_length)
{
100039e0:	b580      	push	{r7, lr}
100039e2:	b082      	sub	sp, #8
100039e4:	af00      	add	r7, sp, #0
100039e6:	6078      	str	r0, [r7, #4]
100039e8:	1c0a      	adds	r2, r1, #0
100039ea:	1cfb      	adds	r3, r7, #3
100039ec:	701a      	strb	r2, [r3, #0]
  XMC_USIC_CH_SetFrameLength(channel, frame_length);
100039ee:	687a      	ldr	r2, [r7, #4]
100039f0:	1cfb      	adds	r3, r7, #3
100039f2:	781b      	ldrb	r3, [r3, #0]
100039f4:	1c10      	adds	r0, r2, #0
100039f6:	1c19      	adds	r1, r3, #0
100039f8:	f7ff ff4a 	bl	10003890 <XMC_USIC_CH_SetFrameLength>
}
100039fc:	46bd      	mov	sp, r7
100039fe:	b002      	add	sp, #8
10003a00:	bd80      	pop	{r7, pc}
10003a02:	46c0      	nop			; (mov r8, r8)

10003a04 <XMC_SPI_CH_SetInputSource>:
 * the SPI communication.
 */
__STATIC_INLINE void XMC_SPI_CH_SetInputSource(XMC_USIC_CH_t *const channel,
    const XMC_SPI_CH_INPUT_t input,
    const uint8_t source)
{
10003a04:	b580      	push	{r7, lr}
10003a06:	b082      	sub	sp, #8
10003a08:	af00      	add	r7, sp, #0
10003a0a:	6078      	str	r0, [r7, #4]
10003a0c:	1c08      	adds	r0, r1, #0
10003a0e:	1c11      	adds	r1, r2, #0
10003a10:	1cfb      	adds	r3, r7, #3
10003a12:	1c02      	adds	r2, r0, #0
10003a14:	701a      	strb	r2, [r3, #0]
10003a16:	1cbb      	adds	r3, r7, #2
10003a18:	1c0a      	adds	r2, r1, #0
10003a1a:	701a      	strb	r2, [r3, #0]
  channel->DXCR[input] = (uint32_t)(channel->DXCR[input] & (~USIC_CH_DX0CR_DSEN_Msk)) | USIC_CH_DX0CR_INSW_Msk;
10003a1c:	1cfb      	adds	r3, r7, #3
10003a1e:	7818      	ldrb	r0, [r3, #0]
10003a20:	1cfb      	adds	r3, r7, #3
10003a22:	781b      	ldrb	r3, [r3, #0]
10003a24:	687a      	ldr	r2, [r7, #4]
10003a26:	3306      	adds	r3, #6
10003a28:	009b      	lsls	r3, r3, #2
10003a2a:	18d3      	adds	r3, r2, r3
10003a2c:	685b      	ldr	r3, [r3, #4]
10003a2e:	2250      	movs	r2, #80	; 0x50
10003a30:	4393      	bics	r3, r2
10003a32:	2210      	movs	r2, #16
10003a34:	431a      	orrs	r2, r3
10003a36:	6879      	ldr	r1, [r7, #4]
10003a38:	1d83      	adds	r3, r0, #6
10003a3a:	009b      	lsls	r3, r3, #2
10003a3c:	18cb      	adds	r3, r1, r3
10003a3e:	605a      	str	r2, [r3, #4]
  XMC_USIC_CH_SetInputSource(channel, (XMC_USIC_CH_INPUT_t)input, source);
10003a40:	6879      	ldr	r1, [r7, #4]
10003a42:	1cfb      	adds	r3, r7, #3
10003a44:	781a      	ldrb	r2, [r3, #0]
10003a46:	1cbb      	adds	r3, r7, #2
10003a48:	781b      	ldrb	r3, [r3, #0]
10003a4a:	1c08      	adds	r0, r1, #0
10003a4c:	1c11      	adds	r1, r2, #0
10003a4e:	1c1a      	adds	r2, r3, #0
10003a50:	f7ff fee2 	bl	10003818 <XMC_USIC_CH_SetInputSource>
}
10003a54:	46bd      	mov	sp, r7
10003a56:	b002      	add	sp, #8
10003a58:	bd80      	pop	{r7, pc}
10003a5a:	46c0      	nop			; (mov r8, r8)

10003a5c <SPI_MASTER_0_lInit>:
 * @brief Configure the port registers and data input registers of SPI channel
 *
 * @param[in] handle Pointer to an object of SPI_MASTER configuration
 */
static SPI_MASTER_STATUS_t SPI_MASTER_0_lInit(void)
{
10003a5c:	b580      	push	{r7, lr}
10003a5e:	b082      	sub	sp, #8
10003a60:	af00      	add	r7, sp, #0
  SPI_MASTER_STATUS_t status;
  status = SPI_MASTER_STATUS_SUCCESS; 
10003a62:	1dfb      	adds	r3, r7, #7
10003a64:	2200      	movs	r2, #0
10003a66:	701a      	strb	r2, [r3, #0]
  /* LLD initialization */
  XMC_SPI_CH_Init(XMC_SPI0_CH0, &SPI_MASTER_0_Channel_Config);
10003a68:	2390      	movs	r3, #144	; 0x90
10003a6a:	05da      	lsls	r2, r3, #23
10003a6c:	4b59      	ldr	r3, [pc, #356]	; (10003bd4 <SPI_MASTER_0_lInit+0x178>)
10003a6e:	1c10      	adds	r0, r2, #0
10003a70:	1c19      	adds	r1, r3, #0
10003a72:	f7ff ff4f 	bl	10003914 <XMC_SPI_CH_Init>
                             
  XMC_SPI_CH_SetBitOrderMsbFirst(XMC_SPI0_CH0);
10003a76:	2390      	movs	r3, #144	; 0x90
10003a78:	05db      	lsls	r3, r3, #23
10003a7a:	1c18      	adds	r0, r3, #0
10003a7c:	f7ff ff66 	bl	1000394c <XMC_SPI_CH_SetBitOrderMsbFirst>
          
  XMC_SPI_CH_SetWordLength(XMC_SPI0_CH0, (uint8_t)8);
10003a80:	2390      	movs	r3, #144	; 0x90
10003a82:	05db      	lsls	r3, r3, #23
10003a84:	1c18      	adds	r0, r3, #0
10003a86:	2108      	movs	r1, #8
10003a88:	f7ff ff98 	bl	100039bc <XMC_SPI_CH_SetWordLength>

  XMC_SPI_CH_SetFrameLength(XMC_SPI0_CH0, (uint8_t)64);
10003a8c:	2390      	movs	r3, #144	; 0x90
10003a8e:	05db      	lsls	r3, r3, #23
10003a90:	1c18      	adds	r0, r3, #0
10003a92:	2140      	movs	r1, #64	; 0x40
10003a94:	f7ff ffa4 	bl	100039e0 <XMC_SPI_CH_SetFrameLength>

  /* Configure the clock polarity and clock delay */
  XMC_SPI_CH_ConfigureShiftClockOutput(XMC_SPI0_CH0,
10003a98:	2390      	movs	r3, #144	; 0x90
10003a9a:	05db      	lsls	r3, r3, #23
10003a9c:	1c18      	adds	r0, r3, #0
10003a9e:	2100      	movs	r1, #0
10003aa0:	2200      	movs	r2, #0
10003aa2:	f7ff ff79 	bl	10003998 <XMC_SPI_CH_ConfigureShiftClockOutput>
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_DISABLED,
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK);
  /* Configure Leading/Trailing delay */
  XMC_SPI_CH_SetSlaveSelectDelay(XMC_SPI0_CH0, 2U);
10003aa6:	2390      	movs	r3, #144	; 0x90
10003aa8:	05db      	lsls	r3, r3, #23
10003aaa:	1c18      	adds	r0, r3, #0
10003aac:	2102      	movs	r1, #2
10003aae:	f7ff ff5b 	bl	10003968 <XMC_SPI_CH_SetSlaveSelectDelay>

               
  /* Configure the input pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, (uint8_t)4, &SPI_MASTER_0_MISO_Config.port_config);
10003ab2:	4a49      	ldr	r2, [pc, #292]	; (10003bd8 <SPI_MASTER_0_lInit+0x17c>)
10003ab4:	4b49      	ldr	r3, [pc, #292]	; (10003bdc <SPI_MASTER_0_lInit+0x180>)
10003ab6:	1c10      	adds	r0, r2, #0
10003ab8:	2104      	movs	r1, #4
10003aba:	1c1a      	adds	r2, r3, #0
10003abc:	f7fd fb64 	bl	10001188 <XMC_GPIO_Init>

  /* Configure the data input line selected */
  XMC_SPI_CH_SetInputSource(XMC_SPI0_CH0, XMC_SPI_CH_INPUT_DIN0, (uint8_t)SPI_MASTER_INPUT_G);
10003ac0:	2390      	movs	r3, #144	; 0x90
10003ac2:	05db      	lsls	r3, r3, #23
10003ac4:	1c18      	adds	r0, r3, #0
10003ac6:	2100      	movs	r1, #0
10003ac8:	2206      	movs	r2, #6
10003aca:	f7ff ff9b 	bl	10003a04 <XMC_SPI_CH_SetInputSource>
  XMC_SPI_CH_SetInputSource(XMC_SPI0_CH0, XMC_SPI_CH_INPUT_DIN1, (uint8_t)SPI_MASTER_INPUT_F);
10003ace:	2390      	movs	r3, #144	; 0x90
10003ad0:	05db      	lsls	r3, r3, #23
10003ad2:	1c18      	adds	r0, r3, #0
10003ad4:	2103      	movs	r1, #3
10003ad6:	2205      	movs	r2, #5
10003ad8:	f7ff ff94 	bl	10003a04 <XMC_SPI_CH_SetInputSource>
  XMC_SPI_CH_SetInputSource(XMC_SPI0_CH0, XMC_SPI_CH_INPUT_DIN2, (uint8_t)SPI_MASTER_INPUT_A);
10003adc:	2390      	movs	r3, #144	; 0x90
10003ade:	05db      	lsls	r3, r3, #23
10003ae0:	1c18      	adds	r0, r3, #0
10003ae2:	2104      	movs	r1, #4
10003ae4:	2200      	movs	r2, #0
10003ae6:	f7ff ff8d 	bl	10003a04 <XMC_SPI_CH_SetInputSource>
  XMC_SPI_CH_SetInputSource(XMC_SPI0_CH0, XMC_SPI_CH_INPUT_DIN3, (uint8_t)SPI_MASTER_INPUT_E);
10003aea:	2390      	movs	r3, #144	; 0x90
10003aec:	05db      	lsls	r3, r3, #23
10003aee:	1c18      	adds	r0, r3, #0
10003af0:	2105      	movs	r1, #5
10003af2:	2204      	movs	r2, #4
10003af4:	f7ff ff86 	bl	10003a04 <XMC_SPI_CH_SetInputSource>
  /* Start the SPI_Channel */
  XMC_SPI_CH_Start(XMC_SPI0_CH0);
10003af8:	2390      	movs	r3, #144	; 0x90
10003afa:	05db      	lsls	r3, r3, #23
10003afc:	1c18      	adds	r0, r3, #0
10003afe:	f7ff ff19 	bl	10003934 <XMC_SPI_CH_Start>

  /* Configure the output pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, (uint8_t)5, &SPI_MASTER_0_MOSI_Config.port_config);
10003b02:	4a35      	ldr	r2, [pc, #212]	; (10003bd8 <SPI_MASTER_0_lInit+0x17c>)
10003b04:	4b36      	ldr	r3, [pc, #216]	; (10003be0 <SPI_MASTER_0_lInit+0x184>)
10003b06:	1c10      	adds	r0, r2, #0
10003b08:	2105      	movs	r1, #5
10003b0a:	1c1a      	adds	r2, r3, #0
10003b0c:	f7fd fb3c 	bl	10001188 <XMC_GPIO_Init>
    
  /* Initialize SPI SCLK out pin */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT1_BASE, (uint8_t)6, &SPI_MASTER_0_SCLKOUT_Config.port_config);
10003b10:	4a31      	ldr	r2, [pc, #196]	; (10003bd8 <SPI_MASTER_0_lInit+0x17c>)
10003b12:	4b34      	ldr	r3, [pc, #208]	; (10003be4 <SPI_MASTER_0_lInit+0x188>)
10003b14:	1c10      	adds	r0, r2, #0
10003b16:	2106      	movs	r1, #6
10003b18:	1c1a      	adds	r2, r3, #0
10003b1a:	f7fd fb35 	bl	10001188 <XMC_GPIO_Init>

  /* Configure the pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT0_BASE, (uint8_t)12, &SPI_MASTER_0_SS_0_Config.port_config);
10003b1e:	4a32      	ldr	r2, [pc, #200]	; (10003be8 <SPI_MASTER_0_lInit+0x18c>)
10003b20:	4b32      	ldr	r3, [pc, #200]	; (10003bec <SPI_MASTER_0_lInit+0x190>)
10003b22:	1c10      	adds	r0, r2, #0
10003b24:	210c      	movs	r1, #12
10003b26:	1c1a      	adds	r2, r3, #0
10003b28:	f7fd fb2e 	bl	10001188 <XMC_GPIO_Init>
  XMC_SPI_CH_EnableSlaveSelect(XMC_SPI0_CH0, XMC_SPI_CH_SLAVE_SELECT_3);
10003b2c:	2390      	movs	r3, #144	; 0x90
10003b2e:	05da      	lsls	r2, r3, #23
10003b30:	2380      	movs	r3, #128	; 0x80
10003b32:	031b      	lsls	r3, r3, #12
10003b34:	1c10      	adds	r0, r2, #0
10003b36:	1c19      	adds	r1, r3, #0
10003b38:	f7fe fa0e 	bl	10001f58 <XMC_SPI_CH_EnableSlaveSelect>

  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI0_CH0,
10003b3c:	2390      	movs	r3, #144	; 0x90
10003b3e:	05db      	lsls	r3, r3, #23
10003b40:	1c18      	adds	r0, r3, #0
10003b42:	2110      	movs	r1, #16
10003b44:	2204      	movs	r2, #4
10003b46:	f7fe fce7 	bl	10002518 <XMC_USIC_CH_SetInterruptNodePointer>
                                      XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL,
                                      (uint32_t)SPI_MASTER_SR_ID_4);
            
  /* Configure transmit FIFO settings */
  XMC_USIC_CH_TXFIFO_Configure(XMC_SPI0_CH0,
10003b4a:	2390      	movs	r3, #144	; 0x90
10003b4c:	05db      	lsls	r3, r3, #23
10003b4e:	1c18      	adds	r0, r3, #0
10003b50:	2110      	movs	r1, #16
10003b52:	2204      	movs	r2, #4
10003b54:	2301      	movs	r3, #1
10003b56:	f7fe fc63 	bl	10002420 <XMC_USIC_CH_TXFIFO_Configure>
                               (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
                               1U);

  /* Configure the service interrupt nodes for standard transmit FIFO events */
               
  XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_SPI0_CH0,
10003b5a:	2390      	movs	r3, #144	; 0x90
10003b5c:	05db      	lsls	r3, r3, #23
10003b5e:	1c18      	adds	r0, r3, #0
10003b60:	2110      	movs	r1, #16
10003b62:	2203      	movs	r2, #3
10003b64:	f7fe fcf8 	bl	10002558 <XMC_USIC_CH_TXFIFO_SetInterruptNodePointer>
                                             XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
                                             (uint32_t)SPI_MASTER_SR_ID_3);
  /* Configure receive FIFO settings */
  XMC_USIC_CH_RXFIFO_Configure(XMC_SPI0_CH0,
10003b68:	2390      	movs	r3, #144	; 0x90
10003b6a:	05db      	lsls	r3, r3, #23
10003b6c:	1c18      	adds	r0, r3, #0
10003b6e:	2100      	movs	r1, #0
10003b70:	2204      	movs	r2, #4
10003b72:	2300      	movs	r3, #0
10003b74:	f7fe fc82 	bl	1000247c <XMC_USIC_CH_RXFIFO_Configure>
                               0U,
                               (XMC_USIC_CH_FIFO_SIZE_t)XMC_USIC_CH_FIFO_SIZE_16WORDS,
                               0U);
             
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_SPI0_CH0,
10003b78:	2390      	movs	r3, #144	; 0x90
10003b7a:	05db      	lsls	r3, r3, #23
10003b7c:	1c18      	adds	r0, r3, #0
10003b7e:	2110      	movs	r1, #16
10003b80:	2201      	movs	r2, #1
10003b82:	f7fe fd0d 	bl	100025a0 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
                                             XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
                                             (uint32_t)SPI_MASTER_SR_ID_1);
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_SPI0_CH0,
10003b86:	2390      	movs	r3, #144	; 0x90
10003b88:	05db      	lsls	r3, r3, #23
10003b8a:	1c18      	adds	r0, r3, #0
10003b8c:	2113      	movs	r1, #19
10003b8e:	2201      	movs	r2, #1
10003b90:	f7fe fd06 	bl	100025a0 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
                                             XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE,
                                             (uint32_t)SPI_MASTER_SR_ID_1);
  /* Set priority of the Transmit interrupt */
  NVIC_SetPriority((IRQn_Type)12, 3U);
10003b94:	200c      	movs	r0, #12
10003b96:	2103      	movs	r1, #3
10003b98:	f7ff fdd4 	bl	10003744 <__NVIC_SetPriority>
    
  XMC_SCU_SetInterruptControl(12,   XMC_SCU_IRQCTRL_USIC0_SR3_IRQ12);
10003b9c:	23c0      	movs	r3, #192	; 0xc0
10003b9e:	011b      	lsls	r3, r3, #4
10003ba0:	200c      	movs	r0, #12
10003ba2:	1c19      	adds	r1, r3, #0
10003ba4:	f7fd fd68 	bl	10001678 <XMC_SCU_SetInterruptControl>
  /* Enable Transmit interrupt */
  NVIC_EnableIRQ((IRQn_Type)12);
10003ba8:	200c      	movs	r0, #12
10003baa:	f7ff fdb1 	bl	10003710 <__NVIC_EnableIRQ>
             
  /* Set priority of the Receive interrupt */
  NVIC_SetPriority((IRQn_Type)10, 2U);
10003bae:	200a      	movs	r0, #10
10003bb0:	2102      	movs	r1, #2
10003bb2:	f7ff fdc7 	bl	10003744 <__NVIC_SetPriority>
    
  XMC_SCU_SetInterruptControl(10,   XMC_SCU_IRQCTRL_USIC0_SR1_IRQ10);
10003bb6:	23a0      	movs	r3, #160	; 0xa0
10003bb8:	011b      	lsls	r3, r3, #4
10003bba:	200a      	movs	r0, #10
10003bbc:	1c19      	adds	r1, r3, #0
10003bbe:	f7fd fd5b 	bl	10001678 <XMC_SCU_SetInterruptControl>
  /* Enable Receive interrupt */
  NVIC_EnableIRQ((IRQn_Type)10);
10003bc2:	200a      	movs	r0, #10
10003bc4:	f7ff fda4 	bl	10003710 <__NVIC_EnableIRQ>
    
  return status;
10003bc8:	1dfb      	adds	r3, r7, #7
10003bca:	781b      	ldrb	r3, [r3, #0]
}
10003bcc:	1c18      	adds	r0, r3, #0
10003bce:	46bd      	mov	sp, r7
10003bd0:	b002      	add	sp, #8
10003bd2:	bd80      	pop	{r7, pc}
10003bd4:	2000056c 	.word	0x2000056c
10003bd8:	40040100 	.word	0x40040100
10003bdc:	2000066c 	.word	0x2000066c
10003be0:	2000055c 	.word	0x2000055c
10003be4:	1000671c 	.word	0x1000671c
10003be8:	40040000 	.word	0x40040000
10003bec:	10006734 	.word	0x10006734

10003bf0 <IRQ12_Handler>:
/*Transmit ISR*/
void SPI_MASTER_0_tx_handler()
{
10003bf0:	b580      	push	{r7, lr}
10003bf2:	af00      	add	r7, sp, #0
  SPI_MASTER_lTransmitHandler(&SPI_MASTER_0);
10003bf4:	4b02      	ldr	r3, [pc, #8]	; (10003c00 <IRQ12_Handler+0x10>)
10003bf6:	1c18      	adds	r0, r3, #0
10003bf8:	f7ff fb0a 	bl	10003210 <SPI_MASTER_lTransmitHandler>
}
10003bfc:	46bd      	mov	sp, r7
10003bfe:	bd80      	pop	{r7, pc}
10003c00:	2000059c 	.word	0x2000059c

10003c04 <IRQ10_Handler>:

/*Receive ISR*/
void SPI_MASTER_0_rx_handler()
{
10003c04:	b580      	push	{r7, lr}
10003c06:	af00      	add	r7, sp, #0
  SPI_MASTER_lReceiveHandler(&SPI_MASTER_0);
10003c08:	4b02      	ldr	r3, [pc, #8]	; (10003c14 <IRQ10_Handler+0x10>)
10003c0a:	1c18      	adds	r0, r3, #0
10003c0c:	f7ff fbf8 	bl	10003400 <SPI_MASTER_lReceiveHandler>
}
10003c10:	46bd      	mov	sp, r7
10003c12:	bd80      	pop	{r7, pc}
10003c14:	2000059c 	.word	0x2000059c

10003c18 <GLOBAL_CAN_Init>:
  return (version);
}

/*  Function to initialize the CAN Peripheral module clock.  */
GLOBAL_CAN_STATUS_t GLOBAL_CAN_Init(GLOBAL_CAN_t *handle)
{
10003c18:	b580      	push	{r7, lr}
10003c1a:	b084      	sub	sp, #16
10003c1c:	af00      	add	r7, sp, #0
10003c1e:	6078      	str	r0, [r7, #4]
  GLOBAL_CAN_STATUS_t status = GLOBAL_CAN_STATUS_SUCCESS;
10003c20:	230f      	movs	r3, #15
10003c22:	18fb      	adds	r3, r7, r3
10003c24:	2200      	movs	r2, #0
10003c26:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("GLOBAL_CAN_Init: handle null", handle != NULL);

  if (handle->init_status != true)
10003c28:	687b      	ldr	r3, [r7, #4]
10003c2a:	7a5b      	ldrb	r3, [r3, #9]
10003c2c:	2201      	movs	r2, #1
10003c2e:	4053      	eors	r3, r2
10003c30:	b2db      	uxtb	r3, r3
10003c32:	2b00      	cmp	r3, #0
10003c34:	d011      	beq.n	10003c5a <GLOBAL_CAN_Init+0x42>
  {
#if defined(MULTICAN_PLUS)
    XMC_CAN_InitEx(handle->canglobal_ptr, (XMC_CAN_CANCLKSRC_t)handle->can_clock_src, handle->can_frequency);
10003c36:	687b      	ldr	r3, [r7, #4]
10003c38:	6859      	ldr	r1, [r3, #4]
10003c3a:	687b      	ldr	r3, [r7, #4]
10003c3c:	7a1a      	ldrb	r2, [r3, #8]
10003c3e:	687b      	ldr	r3, [r7, #4]
10003c40:	681b      	ldr	r3, [r3, #0]
10003c42:	1c08      	adds	r0, r1, #0
10003c44:	1c11      	adds	r1, r2, #0
10003c46:	1c1a      	adds	r2, r3, #0
10003c48:	f7fd ff06 	bl	10001a58 <XMC_CAN_InitEx>
#else
    XMC_CAN_InitEx(handle->canglobal_ptr, XMC_CAN_CANCLKSRC_FPERI, handle->can_frequency);
#endif
    handle->init_status = true;
10003c4c:	687b      	ldr	r3, [r7, #4]
10003c4e:	2201      	movs	r2, #1
10003c50:	725a      	strb	r2, [r3, #9]
    status = GLOBAL_CAN_STATUS_SUCCESS;
10003c52:	230f      	movs	r3, #15
10003c54:	18fb      	adds	r3, r7, r3
10003c56:	2200      	movs	r2, #0
10003c58:	701a      	strb	r2, [r3, #0]
  }
  return (status);
10003c5a:	230f      	movs	r3, #15
10003c5c:	18fb      	adds	r3, r7, r3
10003c5e:	781b      	ldrb	r3, [r3, #0]

}
10003c60:	1c18      	adds	r0, r3, #0
10003c62:	46bd      	mov	sp, r7
10003c64:	b004      	add	sp, #16
10003c66:	bd80      	pop	{r7, pc}

10003c68 <pxPortInitialiseStack>:
 * See header file for description.
 */
StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
                                     TaskFunction_t pxCode,
                                     void * pvParameters )
{
10003c68:	b580      	push	{r7, lr}
10003c6a:	b084      	sub	sp, #16
10003c6c:	af00      	add	r7, sp, #0
10003c6e:	60f8      	str	r0, [r7, #12]
10003c70:	60b9      	str	r1, [r7, #8]
10003c72:	607a      	str	r2, [r7, #4]
    /* Simulate the stack frame as it would be created by a context switch
     * interrupt. */
    pxTopOfStack--;                                          /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
10003c74:	68fb      	ldr	r3, [r7, #12]
10003c76:	3b04      	subs	r3, #4
10003c78:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR */
10003c7a:	68fb      	ldr	r3, [r7, #12]
10003c7c:	2280      	movs	r2, #128	; 0x80
10003c7e:	0452      	lsls	r2, r2, #17
10003c80:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
10003c82:	68fb      	ldr	r3, [r7, #12]
10003c84:	3b04      	subs	r3, #4
10003c86:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC */
10003c88:	68ba      	ldr	r2, [r7, #8]
10003c8a:	68fb      	ldr	r3, [r7, #12]
10003c8c:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
10003c8e:	68fb      	ldr	r3, [r7, #12]
10003c90:	3b04      	subs	r3, #4
10003c92:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR */
10003c94:	4a08      	ldr	r2, [pc, #32]	; (10003cb8 <pxPortInitialiseStack+0x50>)
10003c96:	68fb      	ldr	r3, [r7, #12]
10003c98:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 5;                                       /* R12, R3, R2 and R1. */
10003c9a:	68fb      	ldr	r3, [r7, #12]
10003c9c:	3b14      	subs	r3, #20
10003c9e:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
10003ca0:	687a      	ldr	r2, [r7, #4]
10003ca2:	68fb      	ldr	r3, [r7, #12]
10003ca4:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 8;                                       /* R11..R4. */
10003ca6:	68fb      	ldr	r3, [r7, #12]
10003ca8:	3b20      	subs	r3, #32
10003caa:	60fb      	str	r3, [r7, #12]

    return pxTopOfStack;
10003cac:	68fb      	ldr	r3, [r7, #12]
}
10003cae:	1c18      	adds	r0, r3, #0
10003cb0:	46bd      	mov	sp, r7
10003cb2:	b004      	add	sp, #16
10003cb4:	bd80      	pop	{r7, pc}
10003cb6:	46c0      	nop			; (mov r8, r8)
10003cb8:	10003cbd 	.word	0x10003cbd

10003cbc <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
10003cbc:	b580      	push	{r7, lr}
10003cbe:	b082      	sub	sp, #8
10003cc0:	af00      	add	r7, sp, #0
    volatile uint32_t ulDummy = 0UL;
10003cc2:	2300      	movs	r3, #0
10003cc4:	607b      	str	r3, [r7, #4]
     * its caller as there is nothing to return to.  If a task wants to exit it
     * should instead call vTaskDelete( NULL ).
     *
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
10003cc6:	4b07      	ldr	r3, [pc, #28]	; (10003ce4 <prvTaskExitError+0x28>)
10003cc8:	681b      	ldr	r3, [r3, #0]
10003cca:	3301      	adds	r3, #1
10003ccc:	d001      	beq.n	10003cd2 <prvTaskExitError+0x16>
10003cce:	b672      	cpsid	i
10003cd0:	e7fe      	b.n	10003cd0 <prvTaskExitError+0x14>
    portDISABLE_INTERRUPTS();
10003cd2:	b672      	cpsid	i

    while( ulDummy == 0 )
10003cd4:	46c0      	nop			; (mov r8, r8)
10003cd6:	687b      	ldr	r3, [r7, #4]
10003cd8:	2b00      	cmp	r3, #0
10003cda:	d0fc      	beq.n	10003cd6 <prvTaskExitError+0x1a>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
10003cdc:	46bd      	mov	sp, r7
10003cde:	b002      	add	sp, #8
10003ce0:	bd80      	pop	{r7, pc}
10003ce2:	46c0      	nop			; (mov r8, r8)
10003ce4:	200005b4 	.word	0x200005b4

10003ce8 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
10003ce8:	b580      	push	{r7, lr}
10003cea:	af00      	add	r7, sp, #0
    /* This function is no longer used, but retained for backward
     * compatibility. */
}
10003cec:	46bd      	mov	sp, r7
10003cee:	bd80      	pop	{r7, pc}

10003cf0 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
    /* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
     * table offset register that can be used to locate the initial stack value.
     * Not all M0 parts have the application vector table at address 0. */
    __asm volatile (
10003cf0:	4a0b      	ldr	r2, [pc, #44]	; (10003d20 <pxCurrentTCBConst2>)
10003cf2:	6813      	ldr	r3, [r2, #0]
10003cf4:	6818      	ldr	r0, [r3, #0]
10003cf6:	3020      	adds	r0, #32
10003cf8:	f380 8809 	msr	PSP, r0
10003cfc:	2002      	movs	r0, #2
10003cfe:	f380 8814 	msr	CONTROL, r0
10003d02:	f3bf 8f6f 	isb	sy
10003d06:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
10003d08:	46ae      	mov	lr, r5
10003d0a:	bc08      	pop	{r3}
10003d0c:	bc04      	pop	{r2}
10003d0e:	b662      	cpsie	i
10003d10:	4718      	bx	r3
10003d12:	46c0      	nop			; (mov r8, r8)
10003d14:	46c0      	nop			; (mov r8, r8)
10003d16:	46c0      	nop			; (mov r8, r8)
10003d18:	46c0      	nop			; (mov r8, r8)
10003d1a:	46c0      	nop			; (mov r8, r8)
10003d1c:	46c0      	nop			; (mov r8, r8)
10003d1e:	46c0      	nop			; (mov r8, r8)

10003d20 <pxCurrentTCBConst2>:
10003d20:	2000067c 	.word	0x2000067c
10003d24:	46c0      	nop			; (mov r8, r8)
10003d26:	46c0      	nop			; (mov r8, r8)
10003d28:	46c0      	nop			; (mov r8, r8)
10003d2a:	46c0      	nop			; (mov r8, r8)
10003d2c:	46c0      	nop			; (mov r8, r8)
10003d2e:	46c0      	nop			; (mov r8, r8)

10003d30 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
10003d30:	b580      	push	{r7, lr}
10003d32:	af00      	add	r7, sp, #0
    /* Make PendSV, CallSV and SysTick the same priority as the kernel. */
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
10003d34:	4b0e      	ldr	r3, [pc, #56]	; (10003d70 <xPortStartScheduler+0x40>)
10003d36:	4a0e      	ldr	r2, [pc, #56]	; (10003d70 <xPortStartScheduler+0x40>)
10003d38:	6812      	ldr	r2, [r2, #0]
10003d3a:	21ff      	movs	r1, #255	; 0xff
10003d3c:	0409      	lsls	r1, r1, #16
10003d3e:	430a      	orrs	r2, r1
10003d40:	601a      	str	r2, [r3, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
10003d42:	4b0b      	ldr	r3, [pc, #44]	; (10003d70 <xPortStartScheduler+0x40>)
10003d44:	4a0a      	ldr	r2, [pc, #40]	; (10003d70 <xPortStartScheduler+0x40>)
10003d46:	6812      	ldr	r2, [r2, #0]
10003d48:	21ff      	movs	r1, #255	; 0xff
10003d4a:	0609      	lsls	r1, r1, #24
10003d4c:	430a      	orrs	r2, r1
10003d4e:	601a      	str	r2, [r3, #0]

    /* Start the timer that generates the tick ISR.  Interrupts are disabled
     * here already. */
    vPortSetupTimerInterrupt();
10003d50:	f000 f896 	bl	10003e80 <vPortSetupTimerInterrupt>

    /* Initialise the critical nesting count ready for the first task. */
    uxCriticalNesting = 0;
10003d54:	4b07      	ldr	r3, [pc, #28]	; (10003d74 <xPortStartScheduler+0x44>)
10003d56:	2200      	movs	r2, #0
10003d58:	601a      	str	r2, [r3, #0]

    /* Start the first task. */
    vPortStartFirstTask();
10003d5a:	f7ff ffc9 	bl	10003cf0 <vPortStartFirstTask>
     * exit error function to prevent compiler warnings about a static function
     * not being called in the case that the application writer overrides this
     * functionality by defining configTASK_RETURN_ADDRESS.  Call
     * vTaskSwitchContext() so link time optimisation does not remove the
     * symbol. */
    vTaskSwitchContext();
10003d5e:	f001 f967 	bl	10005030 <vTaskSwitchContext>
    prvTaskExitError();
10003d62:	f7ff ffab 	bl	10003cbc <prvTaskExitError>

    /* Should not get here! */
    return 0;
10003d66:	2300      	movs	r3, #0
}
10003d68:	1c18      	adds	r0, r3, #0
10003d6a:	46bd      	mov	sp, r7
10003d6c:	bd80      	pop	{r7, pc}
10003d6e:	46c0      	nop			; (mov r8, r8)
10003d70:	e000ed20 	.word	0xe000ed20
10003d74:	200005b4 	.word	0x200005b4

10003d78 <vPortYield>:
    configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
10003d78:	b580      	push	{r7, lr}
10003d7a:	af00      	add	r7, sp, #0
    /* Set a PendSV to request a context switch. */
    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
10003d7c:	4b04      	ldr	r3, [pc, #16]	; (10003d90 <vPortYield+0x18>)
10003d7e:	2280      	movs	r2, #128	; 0x80
10003d80:	0552      	lsls	r2, r2, #21
10003d82:	601a      	str	r2, [r3, #0]

    /* Barriers are normally not required but do ensure the code is completely
     * within the specified behaviour for the architecture. */
    __asm volatile ( "dsb" ::: "memory" );
10003d84:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
10003d88:	f3bf 8f6f 	isb	sy
}
10003d8c:	46bd      	mov	sp, r7
10003d8e:	bd80      	pop	{r7, pc}
10003d90:	e000ed04 	.word	0xe000ed04

10003d94 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
10003d94:	b580      	push	{r7, lr}
10003d96:	af00      	add	r7, sp, #0
    portDISABLE_INTERRUPTS();
10003d98:	b672      	cpsid	i
    uxCriticalNesting++;
10003d9a:	4b05      	ldr	r3, [pc, #20]	; (10003db0 <vPortEnterCritical+0x1c>)
10003d9c:	681b      	ldr	r3, [r3, #0]
10003d9e:	1c5a      	adds	r2, r3, #1
10003da0:	4b03      	ldr	r3, [pc, #12]	; (10003db0 <vPortEnterCritical+0x1c>)
10003da2:	601a      	str	r2, [r3, #0]
    __asm volatile ( "dsb" ::: "memory" );
10003da4:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
10003da8:	f3bf 8f6f 	isb	sy
}
10003dac:	46bd      	mov	sp, r7
10003dae:	bd80      	pop	{r7, pc}
10003db0:	200005b4 	.word	0x200005b4

10003db4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
10003db4:	b580      	push	{r7, lr}
10003db6:	af00      	add	r7, sp, #0
    configASSERT( uxCriticalNesting );
10003db8:	4b08      	ldr	r3, [pc, #32]	; (10003ddc <vPortExitCritical+0x28>)
10003dba:	681b      	ldr	r3, [r3, #0]
10003dbc:	2b00      	cmp	r3, #0
10003dbe:	d101      	bne.n	10003dc4 <vPortExitCritical+0x10>
10003dc0:	b672      	cpsid	i
10003dc2:	e7fe      	b.n	10003dc2 <vPortExitCritical+0xe>
    uxCriticalNesting--;
10003dc4:	4b05      	ldr	r3, [pc, #20]	; (10003ddc <vPortExitCritical+0x28>)
10003dc6:	681b      	ldr	r3, [r3, #0]
10003dc8:	1e5a      	subs	r2, r3, #1
10003dca:	4b04      	ldr	r3, [pc, #16]	; (10003ddc <vPortExitCritical+0x28>)
10003dcc:	601a      	str	r2, [r3, #0]

    if( uxCriticalNesting == 0 )
10003dce:	4b03      	ldr	r3, [pc, #12]	; (10003ddc <vPortExitCritical+0x28>)
10003dd0:	681b      	ldr	r3, [r3, #0]
10003dd2:	2b00      	cmp	r3, #0
10003dd4:	d100      	bne.n	10003dd8 <vPortExitCritical+0x24>
    {
        portENABLE_INTERRUPTS();
10003dd6:	b662      	cpsie	i
    }
}
10003dd8:	46bd      	mov	sp, r7
10003dda:	bd80      	pop	{r7, pc}
10003ddc:	200005b4 	.word	0x200005b4

10003de0 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
    __asm volatile (
10003de0:	f3ef 8010 	mrs	r0, PRIMASK
10003de4:	b672      	cpsid	i
10003de6:	4770      	bx	lr
        " mrs r0, PRIMASK	\n"
        " cpsid i			\n"
        " bx lr				  "
        ::: "memory"
        );
}
10003de8:	1c18      	adds	r0, r3, #0
10003dea:	46c0      	nop			; (mov r8, r8)

10003dec <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
    __asm volatile (
10003dec:	f380 8810 	msr	PRIMASK, r0
10003df0:	4770      	bx	lr
10003df2:	46c0      	nop			; (mov r8, r8)
	...

10003e00 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
10003e00:	f3ef 8009 	mrs	r0, PSP
10003e04:	4b0e      	ldr	r3, [pc, #56]	; (10003e40 <pxCurrentTCBConst>)
10003e06:	681a      	ldr	r2, [r3, #0]
10003e08:	3820      	subs	r0, #32
10003e0a:	6010      	str	r0, [r2, #0]
10003e0c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
10003e0e:	4644      	mov	r4, r8
10003e10:	464d      	mov	r5, r9
10003e12:	4656      	mov	r6, sl
10003e14:	465f      	mov	r7, fp
10003e16:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
10003e18:	b508      	push	{r3, lr}
10003e1a:	b672      	cpsid	i
10003e1c:	f001 f908 	bl	10005030 <vTaskSwitchContext>
10003e20:	b662      	cpsie	i
10003e22:	bc0c      	pop	{r2, r3}
10003e24:	6811      	ldr	r1, [r2, #0]
10003e26:	6808      	ldr	r0, [r1, #0]
10003e28:	3010      	adds	r0, #16
10003e2a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
10003e2c:	46a0      	mov	r8, r4
10003e2e:	46a9      	mov	r9, r5
10003e30:	46b2      	mov	sl, r6
10003e32:	46bb      	mov	fp, r7
10003e34:	f380 8809 	msr	PSP, r0
10003e38:	3820      	subs	r0, #32
10003e3a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
10003e3c:	4718      	bx	r3
10003e3e:	46c0      	nop			; (mov r8, r8)

10003e40 <pxCurrentTCBConst>:
10003e40:	2000067c 	.word	0x2000067c
10003e44:	46c0      	nop			; (mov r8, r8)
10003e46:	46c0      	nop			; (mov r8, r8)
10003e48:	46c0      	nop			; (mov r8, r8)
10003e4a:	46c0      	nop			; (mov r8, r8)
10003e4c:	46c0      	nop			; (mov r8, r8)
10003e4e:	46c0      	nop			; (mov r8, r8)

10003e50 <SysTick_Handler>:
    );
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
10003e50:	b580      	push	{r7, lr}
10003e52:	b082      	sub	sp, #8
10003e54:	af00      	add	r7, sp, #0
    uint32_t ulPreviousMask;

    ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
10003e56:	f7ff ffc3 	bl	10003de0 <ulSetInterruptMaskFromISR>
10003e5a:	1c03      	adds	r3, r0, #0
10003e5c:	607b      	str	r3, [r7, #4]
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
10003e5e:	f001 f837 	bl	10004ed0 <xTaskIncrementTick>
10003e62:	1e03      	subs	r3, r0, #0
10003e64:	d003      	beq.n	10003e6e <SysTick_Handler+0x1e>
        {
            /* Pend a context switch. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
10003e66:	4b05      	ldr	r3, [pc, #20]	; (10003e7c <SysTick_Handler+0x2c>)
10003e68:	2280      	movs	r2, #128	; 0x80
10003e6a:	0552      	lsls	r2, r2, #21
10003e6c:	601a      	str	r2, [r3, #0]
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
10003e6e:	687b      	ldr	r3, [r7, #4]
10003e70:	1c18      	adds	r0, r3, #0
10003e72:	f7ff ffbb 	bl	10003dec <vClearInterruptMaskFromISR>
}
10003e76:	46bd      	mov	sp, r7
10003e78:	b002      	add	sp, #8
10003e7a:	bd80      	pop	{r7, pc}
10003e7c:	e000ed04 	.word	0xe000ed04

10003e80 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__( ( weak ) ) void vPortSetupTimerInterrupt( void )
{
10003e80:	b598      	push	{r3, r4, r7, lr}
10003e82:	af00      	add	r7, sp, #0
            ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR;
        }
    #endif /* configUSE_TICKLESS_IDLE */

    /* Stop and reset the SysTick. */
    portNVIC_SYSTICK_CTRL_REG = 0UL;
10003e84:	4b0a      	ldr	r3, [pc, #40]	; (10003eb0 <vPortSetupTimerInterrupt+0x30>)
10003e86:	2200      	movs	r2, #0
10003e88:	601a      	str	r2, [r3, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
10003e8a:	4b0a      	ldr	r3, [pc, #40]	; (10003eb4 <vPortSetupTimerInterrupt+0x34>)
10003e8c:	2200      	movs	r2, #0
10003e8e:	601a      	str	r2, [r3, #0]

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
10003e90:	4c09      	ldr	r4, [pc, #36]	; (10003eb8 <vPortSetupTimerInterrupt+0x38>)
10003e92:	4b0a      	ldr	r3, [pc, #40]	; (10003ebc <vPortSetupTimerInterrupt+0x3c>)
10003e94:	681b      	ldr	r3, [r3, #0]
10003e96:	1c18      	adds	r0, r3, #0
10003e98:	23fa      	movs	r3, #250	; 0xfa
10003e9a:	0099      	lsls	r1, r3, #2
10003e9c:	f7fd ff88 	bl	10001db0 <__aeabi_uidiv>
10003ea0:	1c03      	adds	r3, r0, #0
10003ea2:	3b01      	subs	r3, #1
10003ea4:	6023      	str	r3, [r4, #0]
    portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
10003ea6:	4b02      	ldr	r3, [pc, #8]	; (10003eb0 <vPortSetupTimerInterrupt+0x30>)
10003ea8:	2207      	movs	r2, #7
10003eaa:	601a      	str	r2, [r3, #0]
}
10003eac:	46bd      	mov	sp, r7
10003eae:	bd98      	pop	{r3, r4, r7, pc}
10003eb0:	e000e010 	.word	0xe000e010
10003eb4:	e000e018 	.word	0xe000e018
10003eb8:	e000e014 	.word	0xe000e014
10003ebc:	20003ffc 	.word	0x20003ffc

10003ec0 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
10003ec0:	b580      	push	{r7, lr}
10003ec2:	b084      	sub	sp, #16
10003ec4:	af00      	add	r7, sp, #0
10003ec6:	6078      	str	r0, [r7, #4]
    void * pvReturn;

    vTaskSuspendAll();
10003ec8:	f000 ff5c 	bl	10004d84 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
10003ecc:	687b      	ldr	r3, [r7, #4]
10003ece:	1c18      	adds	r0, r3, #0
10003ed0:	f002 fb16 	bl	10006500 <malloc>
10003ed4:	1c03      	adds	r3, r0, #0
10003ed6:	60fb      	str	r3, [r7, #12]
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
10003ed8:	f000 ff60 	bl	10004d9c <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
10003edc:	68fb      	ldr	r3, [r7, #12]
}
10003ede:	1c18      	adds	r0, r3, #0
10003ee0:	46bd      	mov	sp, r7
10003ee2:	b004      	add	sp, #16
10003ee4:	bd80      	pop	{r7, pc}
10003ee6:	46c0      	nop			; (mov r8, r8)

10003ee8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
10003ee8:	b580      	push	{r7, lr}
10003eea:	b082      	sub	sp, #8
10003eec:	af00      	add	r7, sp, #0
10003eee:	6078      	str	r0, [r7, #4]
    if( pv )
10003ef0:	687b      	ldr	r3, [r7, #4]
10003ef2:	2b00      	cmp	r3, #0
10003ef4:	d007      	beq.n	10003f06 <vPortFree+0x1e>
    {
        vTaskSuspendAll();
10003ef6:	f000 ff45 	bl	10004d84 <vTaskSuspendAll>
        {
            free( pv );
10003efa:	687b      	ldr	r3, [r7, #4]
10003efc:	1c18      	adds	r0, r3, #0
10003efe:	f002 fb09 	bl	10006514 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
10003f02:	f000 ff4b 	bl	10004d9c <xTaskResumeAll>
    }
}
10003f06:	46bd      	mov	sp, r7
10003f08:	b002      	add	sp, #8
10003f0a:	bd80      	pop	{r7, pc}

10003f0c <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
10003f0c:	b580      	push	{r7, lr}
10003f0e:	b082      	sub	sp, #8
10003f10:	af00      	add	r7, sp, #0
10003f12:	6078      	str	r0, [r7, #4]
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10003f14:	687b      	ldr	r3, [r7, #4]
10003f16:	3308      	adds	r3, #8
10003f18:	1c1a      	adds	r2, r3, #0
10003f1a:	687b      	ldr	r3, [r7, #4]
10003f1c:	605a      	str	r2, [r3, #4]

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
10003f1e:	687b      	ldr	r3, [r7, #4]
10003f20:	2201      	movs	r2, #1
10003f22:	4252      	negs	r2, r2
10003f24:	609a      	str	r2, [r3, #8]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10003f26:	687b      	ldr	r3, [r7, #4]
10003f28:	3308      	adds	r3, #8
10003f2a:	1c1a      	adds	r2, r3, #0
10003f2c:	687b      	ldr	r3, [r7, #4]
10003f2e:	60da      	str	r2, [r3, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10003f30:	687b      	ldr	r3, [r7, #4]
10003f32:	3308      	adds	r3, #8
10003f34:	1c1a      	adds	r2, r3, #0
10003f36:	687b      	ldr	r3, [r7, #4]
10003f38:	611a      	str	r2, [r3, #16]

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
10003f3a:	687b      	ldr	r3, [r7, #4]
10003f3c:	2200      	movs	r2, #0
10003f3e:	601a      	str	r2, [r3, #0]

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
10003f40:	46bd      	mov	sp, r7
10003f42:	b002      	add	sp, #8
10003f44:	bd80      	pop	{r7, pc}
10003f46:	46c0      	nop			; (mov r8, r8)

10003f48 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
10003f48:	b580      	push	{r7, lr}
10003f4a:	b082      	sub	sp, #8
10003f4c:	af00      	add	r7, sp, #0
10003f4e:	6078      	str	r0, [r7, #4]
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
10003f50:	687b      	ldr	r3, [r7, #4]
10003f52:	2200      	movs	r2, #0
10003f54:	611a      	str	r2, [r3, #16]

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
10003f56:	46bd      	mov	sp, r7
10003f58:	b002      	add	sp, #8
10003f5a:	bd80      	pop	{r7, pc}

10003f5c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
10003f5c:	b580      	push	{r7, lr}
10003f5e:	b084      	sub	sp, #16
10003f60:	af00      	add	r7, sp, #0
10003f62:	6078      	str	r0, [r7, #4]
10003f64:	6039      	str	r1, [r7, #0]
    ListItem_t * const pxIndex = pxList->pxIndex;
10003f66:	687b      	ldr	r3, [r7, #4]
10003f68:	685b      	ldr	r3, [r3, #4]
10003f6a:	60fb      	str	r3, [r7, #12]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
10003f6c:	683b      	ldr	r3, [r7, #0]
10003f6e:	68fa      	ldr	r2, [r7, #12]
10003f70:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
10003f72:	68fb      	ldr	r3, [r7, #12]
10003f74:	689a      	ldr	r2, [r3, #8]
10003f76:	683b      	ldr	r3, [r7, #0]
10003f78:	609a      	str	r2, [r3, #8]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
10003f7a:	68fb      	ldr	r3, [r7, #12]
10003f7c:	689b      	ldr	r3, [r3, #8]
10003f7e:	683a      	ldr	r2, [r7, #0]
10003f80:	605a      	str	r2, [r3, #4]
    pxIndex->pxPrevious = pxNewListItem;
10003f82:	68fb      	ldr	r3, [r7, #12]
10003f84:	683a      	ldr	r2, [r7, #0]
10003f86:	609a      	str	r2, [r3, #8]

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
10003f88:	683b      	ldr	r3, [r7, #0]
10003f8a:	687a      	ldr	r2, [r7, #4]
10003f8c:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems )++;
10003f8e:	687b      	ldr	r3, [r7, #4]
10003f90:	681b      	ldr	r3, [r3, #0]
10003f92:	1c5a      	adds	r2, r3, #1
10003f94:	687b      	ldr	r3, [r7, #4]
10003f96:	601a      	str	r2, [r3, #0]
}
10003f98:	46bd      	mov	sp, r7
10003f9a:	b004      	add	sp, #16
10003f9c:	bd80      	pop	{r7, pc}
10003f9e:	46c0      	nop			; (mov r8, r8)

10003fa0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
10003fa0:	b580      	push	{r7, lr}
10003fa2:	b084      	sub	sp, #16
10003fa4:	af00      	add	r7, sp, #0
10003fa6:	6078      	str	r0, [r7, #4]
10003fa8:	6039      	str	r1, [r7, #0]
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
10003faa:	683b      	ldr	r3, [r7, #0]
10003fac:	681b      	ldr	r3, [r3, #0]
10003fae:	60bb      	str	r3, [r7, #8]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
10003fb0:	68bb      	ldr	r3, [r7, #8]
10003fb2:	3301      	adds	r3, #1
10003fb4:	d103      	bne.n	10003fbe <vListInsert+0x1e>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
10003fb6:	687b      	ldr	r3, [r7, #4]
10003fb8:	691b      	ldr	r3, [r3, #16]
10003fba:	60fb      	str	r3, [r7, #12]
10003fbc:	e00c      	b.n	10003fd8 <vListInsert+0x38>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
10003fbe:	687b      	ldr	r3, [r7, #4]
10003fc0:	3308      	adds	r3, #8
10003fc2:	60fb      	str	r3, [r7, #12]
10003fc4:	e002      	b.n	10003fcc <vListInsert+0x2c>
10003fc6:	68fb      	ldr	r3, [r7, #12]
10003fc8:	685b      	ldr	r3, [r3, #4]
10003fca:	60fb      	str	r3, [r7, #12]
10003fcc:	68fb      	ldr	r3, [r7, #12]
10003fce:	685b      	ldr	r3, [r3, #4]
10003fd0:	681a      	ldr	r2, [r3, #0]
10003fd2:	68bb      	ldr	r3, [r7, #8]
10003fd4:	429a      	cmp	r2, r3
10003fd6:	d9f6      	bls.n	10003fc6 <vListInsert+0x26>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
10003fd8:	68fb      	ldr	r3, [r7, #12]
10003fda:	685a      	ldr	r2, [r3, #4]
10003fdc:	683b      	ldr	r3, [r7, #0]
10003fde:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
10003fe0:	683b      	ldr	r3, [r7, #0]
10003fe2:	685b      	ldr	r3, [r3, #4]
10003fe4:	683a      	ldr	r2, [r7, #0]
10003fe6:	609a      	str	r2, [r3, #8]
    pxNewListItem->pxPrevious = pxIterator;
10003fe8:	683b      	ldr	r3, [r7, #0]
10003fea:	68fa      	ldr	r2, [r7, #12]
10003fec:	609a      	str	r2, [r3, #8]
    pxIterator->pxNext = pxNewListItem;
10003fee:	68fb      	ldr	r3, [r7, #12]
10003ff0:	683a      	ldr	r2, [r7, #0]
10003ff2:	605a      	str	r2, [r3, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
10003ff4:	683b      	ldr	r3, [r7, #0]
10003ff6:	687a      	ldr	r2, [r7, #4]
10003ff8:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems )++;
10003ffa:	687b      	ldr	r3, [r7, #4]
10003ffc:	681b      	ldr	r3, [r3, #0]
10003ffe:	1c5a      	adds	r2, r3, #1
10004000:	687b      	ldr	r3, [r7, #4]
10004002:	601a      	str	r2, [r3, #0]
}
10004004:	46bd      	mov	sp, r7
10004006:	b004      	add	sp, #16
10004008:	bd80      	pop	{r7, pc}
1000400a:	46c0      	nop			; (mov r8, r8)

1000400c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
1000400c:	b580      	push	{r7, lr}
1000400e:	b084      	sub	sp, #16
10004010:	af00      	add	r7, sp, #0
10004012:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
10004014:	687b      	ldr	r3, [r7, #4]
10004016:	691b      	ldr	r3, [r3, #16]
10004018:	60fb      	str	r3, [r7, #12]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
1000401a:	687b      	ldr	r3, [r7, #4]
1000401c:	685b      	ldr	r3, [r3, #4]
1000401e:	687a      	ldr	r2, [r7, #4]
10004020:	6892      	ldr	r2, [r2, #8]
10004022:	609a      	str	r2, [r3, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
10004024:	687b      	ldr	r3, [r7, #4]
10004026:	689b      	ldr	r3, [r3, #8]
10004028:	687a      	ldr	r2, [r7, #4]
1000402a:	6852      	ldr	r2, [r2, #4]
1000402c:	605a      	str	r2, [r3, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
1000402e:	68fb      	ldr	r3, [r7, #12]
10004030:	685a      	ldr	r2, [r3, #4]
10004032:	687b      	ldr	r3, [r7, #4]
10004034:	429a      	cmp	r2, r3
10004036:	d103      	bne.n	10004040 <uxListRemove+0x34>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
10004038:	687b      	ldr	r3, [r7, #4]
1000403a:	689a      	ldr	r2, [r3, #8]
1000403c:	68fb      	ldr	r3, [r7, #12]
1000403e:	605a      	str	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
10004040:	687b      	ldr	r3, [r7, #4]
10004042:	2200      	movs	r2, #0
10004044:	611a      	str	r2, [r3, #16]
    ( pxList->uxNumberOfItems )--;
10004046:	68fb      	ldr	r3, [r7, #12]
10004048:	681b      	ldr	r3, [r3, #0]
1000404a:	1e5a      	subs	r2, r3, #1
1000404c:	68fb      	ldr	r3, [r7, #12]
1000404e:	601a      	str	r2, [r3, #0]

    return pxList->uxNumberOfItems;
10004050:	68fb      	ldr	r3, [r7, #12]
10004052:	681b      	ldr	r3, [r3, #0]
}
10004054:	1c18      	adds	r0, r3, #0
10004056:	46bd      	mov	sp, r7
10004058:	b004      	add	sp, #16
1000405a:	bd80      	pop	{r7, pc}

1000405c <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
1000405c:	b580      	push	{r7, lr}
1000405e:	b084      	sub	sp, #16
10004060:	af00      	add	r7, sp, #0
10004062:	6078      	str	r0, [r7, #4]
10004064:	6039      	str	r1, [r7, #0]
    Queue_t * const pxQueue = xQueue;
10004066:	687b      	ldr	r3, [r7, #4]
10004068:	60fb      	str	r3, [r7, #12]

    configASSERT( pxQueue );
1000406a:	68fb      	ldr	r3, [r7, #12]
1000406c:	2b00      	cmp	r3, #0
1000406e:	d101      	bne.n	10004074 <xQueueGenericReset+0x18>
10004070:	b672      	cpsid	i
10004072:	e7fe      	b.n	10004072 <xQueueGenericReset+0x16>

    taskENTER_CRITICAL();
10004074:	f7ff fe8e 	bl	10003d94 <vPortEnterCritical>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
10004078:	68fb      	ldr	r3, [r7, #12]
1000407a:	681a      	ldr	r2, [r3, #0]
1000407c:	68fb      	ldr	r3, [r7, #12]
1000407e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
10004080:	68fb      	ldr	r3, [r7, #12]
10004082:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10004084:	434b      	muls	r3, r1
10004086:	18d2      	adds	r2, r2, r3
10004088:	68fb      	ldr	r3, [r7, #12]
1000408a:	609a      	str	r2, [r3, #8]
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
1000408c:	68fb      	ldr	r3, [r7, #12]
1000408e:	2200      	movs	r2, #0
10004090:	639a      	str	r2, [r3, #56]	; 0x38
        pxQueue->pcWriteTo = pxQueue->pcHead;
10004092:	68fb      	ldr	r3, [r7, #12]
10004094:	681a      	ldr	r2, [r3, #0]
10004096:	68fb      	ldr	r3, [r7, #12]
10004098:	605a      	str	r2, [r3, #4]
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
1000409a:	68fb      	ldr	r3, [r7, #12]
1000409c:	681a      	ldr	r2, [r3, #0]
1000409e:	68fb      	ldr	r3, [r7, #12]
100040a0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100040a2:	1e59      	subs	r1, r3, #1
100040a4:	68fb      	ldr	r3, [r7, #12]
100040a6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100040a8:	434b      	muls	r3, r1
100040aa:	18d2      	adds	r2, r2, r3
100040ac:	68fb      	ldr	r3, [r7, #12]
100040ae:	60da      	str	r2, [r3, #12]
        pxQueue->cRxLock = queueUNLOCKED;
100040b0:	68fb      	ldr	r3, [r7, #12]
100040b2:	2244      	movs	r2, #68	; 0x44
100040b4:	21ff      	movs	r1, #255	; 0xff
100040b6:	5499      	strb	r1, [r3, r2]
        pxQueue->cTxLock = queueUNLOCKED;
100040b8:	68fb      	ldr	r3, [r7, #12]
100040ba:	2245      	movs	r2, #69	; 0x45
100040bc:	21ff      	movs	r1, #255	; 0xff
100040be:	5499      	strb	r1, [r3, r2]

        if( xNewQueue == pdFALSE )
100040c0:	683b      	ldr	r3, [r7, #0]
100040c2:	2b00      	cmp	r3, #0
100040c4:	d10d      	bne.n	100040e2 <xQueueGenericReset+0x86>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
100040c6:	68fb      	ldr	r3, [r7, #12]
100040c8:	691b      	ldr	r3, [r3, #16]
100040ca:	2b00      	cmp	r3, #0
100040cc:	d013      	beq.n	100040f6 <xQueueGenericReset+0x9a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
100040ce:	68fb      	ldr	r3, [r7, #12]
100040d0:	3310      	adds	r3, #16
100040d2:	1c18      	adds	r0, r3, #0
100040d4:	f001 f83c 	bl	10005150 <xTaskRemoveFromEventList>
100040d8:	1e03      	subs	r3, r0, #0
100040da:	d00c      	beq.n	100040f6 <xQueueGenericReset+0x9a>
                {
                    queueYIELD_IF_USING_PREEMPTION();
100040dc:	f7ff fe4c 	bl	10003d78 <vPortYield>
100040e0:	e009      	b.n	100040f6 <xQueueGenericReset+0x9a>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
100040e2:	68fb      	ldr	r3, [r7, #12]
100040e4:	3310      	adds	r3, #16
100040e6:	1c18      	adds	r0, r3, #0
100040e8:	f7ff ff10 	bl	10003f0c <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
100040ec:	68fb      	ldr	r3, [r7, #12]
100040ee:	3324      	adds	r3, #36	; 0x24
100040f0:	1c18      	adds	r0, r3, #0
100040f2:	f7ff ff0b 	bl	10003f0c <vListInitialise>
        }
    }
    taskEXIT_CRITICAL();
100040f6:	f7ff fe5d 	bl	10003db4 <vPortExitCritical>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
100040fa:	2301      	movs	r3, #1
}
100040fc:	1c18      	adds	r0, r3, #0
100040fe:	46bd      	mov	sp, r7
10004100:	b004      	add	sp, #16
10004102:	bd80      	pop	{r7, pc}

10004104 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
10004104:	b590      	push	{r4, r7, lr}
10004106:	b08b      	sub	sp, #44	; 0x2c
10004108:	af02      	add	r7, sp, #8
1000410a:	60f8      	str	r0, [r7, #12]
1000410c:	60b9      	str	r1, [r7, #8]
1000410e:	1dfb      	adds	r3, r7, #7
10004110:	701a      	strb	r2, [r3, #0]
        Queue_t * pxNewQueue;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
10004112:	68fb      	ldr	r3, [r7, #12]
10004114:	2b00      	cmp	r3, #0
10004116:	d101      	bne.n	1000411c <xQueueGenericCreate+0x18>
10004118:	b672      	cpsid	i
1000411a:	e7fe      	b.n	1000411a <xQueueGenericCreate+0x16>

        /* Allocate enough space to hold the maximum number of items that
         * can be in the queue at any time.  It is valid for uxItemSize to be
         * zero in the case the queue is used as a semaphore. */
        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1000411c:	68fb      	ldr	r3, [r7, #12]
1000411e:	68ba      	ldr	r2, [r7, #8]
10004120:	4353      	muls	r3, r2
10004122:	61fb      	str	r3, [r7, #28]

        /* Check for multiplication overflow. */
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
10004124:	68bb      	ldr	r3, [r7, #8]
10004126:	2b00      	cmp	r3, #0
10004128:	d008      	beq.n	1000413c <xQueueGenericCreate+0x38>
1000412a:	69f8      	ldr	r0, [r7, #28]
1000412c:	68b9      	ldr	r1, [r7, #8]
1000412e:	f7fd fe3f 	bl	10001db0 <__aeabi_uidiv>
10004132:	1c03      	adds	r3, r0, #0
10004134:	1e1a      	subs	r2, r3, #0
10004136:	68fb      	ldr	r3, [r7, #12]
10004138:	429a      	cmp	r2, r3
1000413a:	d101      	bne.n	10004140 <xQueueGenericCreate+0x3c>
1000413c:	2301      	movs	r3, #1
1000413e:	e000      	b.n	10004142 <xQueueGenericCreate+0x3e>
10004140:	2300      	movs	r3, #0
10004142:	2b00      	cmp	r3, #0
10004144:	d101      	bne.n	1000414a <xQueueGenericCreate+0x46>
10004146:	b672      	cpsid	i
10004148:	e7fe      	b.n	10004148 <xQueueGenericCreate+0x44>

        /* Check for addition overflow. */
        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );
1000414a:	69fb      	ldr	r3, [r7, #28]
1000414c:	3354      	adds	r3, #84	; 0x54
1000414e:	1e1a      	subs	r2, r3, #0
10004150:	69fb      	ldr	r3, [r7, #28]
10004152:	429a      	cmp	r2, r3
10004154:	d801      	bhi.n	1000415a <xQueueGenericCreate+0x56>
10004156:	b672      	cpsid	i
10004158:	e7fe      	b.n	10004158 <xQueueGenericCreate+0x54>
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
1000415a:	69fb      	ldr	r3, [r7, #28]
1000415c:	3354      	adds	r3, #84	; 0x54
1000415e:	1c18      	adds	r0, r3, #0
10004160:	f7ff feae 	bl	10003ec0 <pvPortMalloc>
10004164:	1c03      	adds	r3, r0, #0
10004166:	61bb      	str	r3, [r7, #24]

        if( pxNewQueue != NULL )
10004168:	69bb      	ldr	r3, [r7, #24]
1000416a:	2b00      	cmp	r3, #0
1000416c:	d00e      	beq.n	1000418c <xQueueGenericCreate+0x88>
        {
            /* Jump past the queue structure to find the location of the queue
             * storage area. */
            pucQueueStorage = ( uint8_t * ) pxNewQueue;
1000416e:	69bb      	ldr	r3, [r7, #24]
10004170:	617b      	str	r3, [r7, #20]
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
10004172:	697b      	ldr	r3, [r7, #20]
10004174:	3354      	adds	r3, #84	; 0x54
10004176:	617b      	str	r3, [r7, #20]
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
            #endif /* configSUPPORT_STATIC_ALLOCATION */

            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
10004178:	68f8      	ldr	r0, [r7, #12]
1000417a:	68b9      	ldr	r1, [r7, #8]
1000417c:	697a      	ldr	r2, [r7, #20]
1000417e:	1dfb      	adds	r3, r7, #7
10004180:	781c      	ldrb	r4, [r3, #0]
10004182:	69bb      	ldr	r3, [r7, #24]
10004184:	9300      	str	r3, [sp, #0]
10004186:	1c23      	adds	r3, r4, #0
10004188:	f000 f806 	bl	10004198 <prvInitialiseNewQueue>
        {
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
1000418c:	69bb      	ldr	r3, [r7, #24]
    }
1000418e:	1c18      	adds	r0, r3, #0
10004190:	46bd      	mov	sp, r7
10004192:	b009      	add	sp, #36	; 0x24
10004194:	bd90      	pop	{r4, r7, pc}
10004196:	46c0      	nop			; (mov r8, r8)

10004198 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
10004198:	b580      	push	{r7, lr}
1000419a:	b084      	sub	sp, #16
1000419c:	af00      	add	r7, sp, #0
1000419e:	60f8      	str	r0, [r7, #12]
100041a0:	60b9      	str	r1, [r7, #8]
100041a2:	607a      	str	r2, [r7, #4]
100041a4:	1c1a      	adds	r2, r3, #0
100041a6:	1cfb      	adds	r3, r7, #3
100041a8:	701a      	strb	r2, [r3, #0]
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
100041aa:	68bb      	ldr	r3, [r7, #8]
100041ac:	2b00      	cmp	r3, #0
100041ae:	d103      	bne.n	100041b8 <prvInitialiseNewQueue+0x20>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
100041b0:	69bb      	ldr	r3, [r7, #24]
100041b2:	69ba      	ldr	r2, [r7, #24]
100041b4:	601a      	str	r2, [r3, #0]
100041b6:	e002      	b.n	100041be <prvInitialiseNewQueue+0x26>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
100041b8:	69bb      	ldr	r3, [r7, #24]
100041ba:	687a      	ldr	r2, [r7, #4]
100041bc:	601a      	str	r2, [r3, #0]
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
100041be:	69bb      	ldr	r3, [r7, #24]
100041c0:	68fa      	ldr	r2, [r7, #12]
100041c2:	63da      	str	r2, [r3, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
100041c4:	69bb      	ldr	r3, [r7, #24]
100041c6:	68ba      	ldr	r2, [r7, #8]
100041c8:	641a      	str	r2, [r3, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
100041ca:	69bb      	ldr	r3, [r7, #24]
100041cc:	1c18      	adds	r0, r3, #0
100041ce:	2101      	movs	r1, #1
100041d0:	f7ff ff44 	bl	1000405c <xQueueGenericReset>

    #if ( configUSE_TRACE_FACILITY == 1 )
        {
            pxNewQueue->ucQueueType = ucQueueType;
100041d4:	69bb      	ldr	r3, [r7, #24]
100041d6:	1cfa      	adds	r2, r7, #3
100041d8:	2150      	movs	r1, #80	; 0x50
100041da:	7812      	ldrb	r2, [r2, #0]
100041dc:	545a      	strb	r2, [r3, r1]
        }
    #endif /* configUSE_TRACE_FACILITY */

    #if ( configUSE_QUEUE_SETS == 1 )
        {
            pxNewQueue->pxQueueSetContainer = NULL;
100041de:	69bb      	ldr	r3, [r7, #24]
100041e0:	2200      	movs	r2, #0
100041e2:	649a      	str	r2, [r3, #72]	; 0x48
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
100041e4:	46bd      	mov	sp, r7
100041e6:	b004      	add	sp, #16
100041e8:	bd80      	pop	{r7, pc}
100041ea:	46c0      	nop			; (mov r8, r8)

100041ec <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
100041ec:	b580      	push	{r7, lr}
100041ee:	b08a      	sub	sp, #40	; 0x28
100041f0:	af00      	add	r7, sp, #0
100041f2:	60f8      	str	r0, [r7, #12]
100041f4:	60b9      	str	r1, [r7, #8]
100041f6:	607a      	str	r2, [r7, #4]
100041f8:	603b      	str	r3, [r7, #0]
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
100041fa:	2300      	movs	r3, #0
100041fc:	627b      	str	r3, [r7, #36]	; 0x24
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
100041fe:	68fb      	ldr	r3, [r7, #12]
10004200:	623b      	str	r3, [r7, #32]

    configASSERT( pxQueue );
10004202:	6a3b      	ldr	r3, [r7, #32]
10004204:	2b00      	cmp	r3, #0
10004206:	d101      	bne.n	1000420c <xQueueGenericSend+0x20>
10004208:	b672      	cpsid	i
1000420a:	e7fe      	b.n	1000420a <xQueueGenericSend+0x1e>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1000420c:	68bb      	ldr	r3, [r7, #8]
1000420e:	2b00      	cmp	r3, #0
10004210:	d103      	bne.n	1000421a <xQueueGenericSend+0x2e>
10004212:	6a3b      	ldr	r3, [r7, #32]
10004214:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10004216:	2b00      	cmp	r3, #0
10004218:	d101      	bne.n	1000421e <xQueueGenericSend+0x32>
1000421a:	2301      	movs	r3, #1
1000421c:	e000      	b.n	10004220 <xQueueGenericSend+0x34>
1000421e:	2300      	movs	r3, #0
10004220:	2b00      	cmp	r3, #0
10004222:	d101      	bne.n	10004228 <xQueueGenericSend+0x3c>
10004224:	b672      	cpsid	i
10004226:	e7fe      	b.n	10004226 <xQueueGenericSend+0x3a>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
10004228:	683b      	ldr	r3, [r7, #0]
1000422a:	2b02      	cmp	r3, #2
1000422c:	d103      	bne.n	10004236 <xQueueGenericSend+0x4a>
1000422e:	6a3b      	ldr	r3, [r7, #32]
10004230:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10004232:	2b01      	cmp	r3, #1
10004234:	d101      	bne.n	1000423a <xQueueGenericSend+0x4e>
10004236:	2301      	movs	r3, #1
10004238:	e000      	b.n	1000423c <xQueueGenericSend+0x50>
1000423a:	2300      	movs	r3, #0
1000423c:	2b00      	cmp	r3, #0
1000423e:	d101      	bne.n	10004244 <xQueueGenericSend+0x58>
10004240:	b672      	cpsid	i
10004242:	e7fe      	b.n	10004242 <xQueueGenericSend+0x56>
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
10004244:	f001 f90a 	bl	1000545c <xTaskGetSchedulerState>
10004248:	1e03      	subs	r3, r0, #0
1000424a:	d102      	bne.n	10004252 <xQueueGenericSend+0x66>
1000424c:	687b      	ldr	r3, [r7, #4]
1000424e:	2b00      	cmp	r3, #0
10004250:	d101      	bne.n	10004256 <xQueueGenericSend+0x6a>
10004252:	2301      	movs	r3, #1
10004254:	e000      	b.n	10004258 <xQueueGenericSend+0x6c>
10004256:	2300      	movs	r3, #0
10004258:	2b00      	cmp	r3, #0
1000425a:	d101      	bne.n	10004260 <xQueueGenericSend+0x74>
1000425c:	b672      	cpsid	i
1000425e:	e7fe      	b.n	1000425e <xQueueGenericSend+0x72>
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
10004260:	f7ff fd98 	bl	10003d94 <vPortEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
10004264:	6a3b      	ldr	r3, [r7, #32]
10004266:	6b9a      	ldr	r2, [r3, #56]	; 0x38
10004268:	6a3b      	ldr	r3, [r7, #32]
1000426a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
1000426c:	429a      	cmp	r2, r3
1000426e:	d302      	bcc.n	10004276 <xQueueGenericSend+0x8a>
10004270:	683b      	ldr	r3, [r7, #0]
10004272:	2b02      	cmp	r3, #2
10004274:	d138      	bne.n	100042e8 <xQueueGenericSend+0xfc>
            {
                traceQUEUE_SEND( pxQueue );

                #if ( configUSE_QUEUE_SETS == 1 )
                    {
                        const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
10004276:	6a3b      	ldr	r3, [r7, #32]
10004278:	6b9b      	ldr	r3, [r3, #56]	; 0x38
1000427a:	61fb      	str	r3, [r7, #28]

                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1000427c:	6a39      	ldr	r1, [r7, #32]
1000427e:	68ba      	ldr	r2, [r7, #8]
10004280:	683b      	ldr	r3, [r7, #0]
10004282:	1c08      	adds	r0, r1, #0
10004284:	1c11      	adds	r1, r2, #0
10004286:	1c1a      	adds	r2, r3, #0
10004288:	f000 f9e6 	bl	10004658 <prvCopyDataToQueue>
1000428c:	1c03      	adds	r3, r0, #0
1000428e:	61bb      	str	r3, [r7, #24]

                        if( pxQueue->pxQueueSetContainer != NULL )
10004290:	6a3b      	ldr	r3, [r7, #32]
10004292:	6c9b      	ldr	r3, [r3, #72]	; 0x48
10004294:	2b00      	cmp	r3, #0
10004296:	d010      	beq.n	100042ba <xQueueGenericSend+0xce>
                        {
                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
10004298:	683b      	ldr	r3, [r7, #0]
1000429a:	2b02      	cmp	r3, #2
1000429c:	d104      	bne.n	100042a8 <xQueueGenericSend+0xbc>
1000429e:	69fb      	ldr	r3, [r7, #28]
100042a0:	2b00      	cmp	r3, #0
100042a2:	d001      	beq.n	100042a8 <xQueueGenericSend+0xbc>
100042a4:	46c0      	nop			; (mov r8, r8)
100042a6:	e01b      	b.n	100042e0 <xQueueGenericSend+0xf4>
                                /* Do not notify the queue set as an existing item
                                 * was overwritten in the queue so the number of items
                                 * in the queue has not changed. */
                                mtCOVERAGE_TEST_MARKER();
                            }
                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
100042a8:	6a3b      	ldr	r3, [r7, #32]
100042aa:	1c18      	adds	r0, r3, #0
100042ac:	f000 fb64 	bl	10004978 <prvNotifyQueueSetContainer>
100042b0:	1e03      	subs	r3, r0, #0
100042b2:	d015      	beq.n	100042e0 <xQueueGenericSend+0xf4>
                            {
                                /* The queue is a member of a queue set, and posting
                                 * to the queue set caused a higher priority task to
                                 * unblock. A context switch is required. */
                                queueYIELD_IF_USING_PREEMPTION();
100042b4:	f7ff fd60 	bl	10003d78 <vPortYield>
100042b8:	e012      	b.n	100042e0 <xQueueGenericSend+0xf4>
                        }
                        else
                        {
                            /* If there was a task waiting for data to arrive on the
                             * queue then unblock it now. */
                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
100042ba:	6a3b      	ldr	r3, [r7, #32]
100042bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100042be:	2b00      	cmp	r3, #0
100042c0:	d009      	beq.n	100042d6 <xQueueGenericSend+0xea>
                            {
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
100042c2:	6a3b      	ldr	r3, [r7, #32]
100042c4:	3324      	adds	r3, #36	; 0x24
100042c6:	1c18      	adds	r0, r3, #0
100042c8:	f000 ff42 	bl	10005150 <xTaskRemoveFromEventList>
100042cc:	1e03      	subs	r3, r0, #0
100042ce:	d007      	beq.n	100042e0 <xQueueGenericSend+0xf4>
                                {
                                    /* The unblocked task has a priority higher than
                                     * our own so yield immediately.  Yes it is ok to
                                     * do this from within the critical section - the
                                     * kernel takes care of that. */
                                    queueYIELD_IF_USING_PREEMPTION();
100042d0:	f7ff fd52 	bl	10003d78 <vPortYield>
100042d4:	e004      	b.n	100042e0 <xQueueGenericSend+0xf4>
                                else
                                {
                                    mtCOVERAGE_TEST_MARKER();
                                }
                            }
                            else if( xYieldRequired != pdFALSE )
100042d6:	69bb      	ldr	r3, [r7, #24]
100042d8:	2b00      	cmp	r3, #0
100042da:	d001      	beq.n	100042e0 <xQueueGenericSend+0xf4>
                            {
                                /* This path is a special case that will only get
                                 * executed if the task was holding multiple mutexes
                                 * and the mutexes were given back in an order that is
                                 * different to that in which they were taken. */
                                queueYIELD_IF_USING_PREEMPTION();
100042dc:	f7ff fd4c 	bl	10003d78 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
100042e0:	f7ff fd68 	bl	10003db4 <vPortExitCritical>
                return pdPASS;
100042e4:	2301      	movs	r3, #1
100042e6:	e060      	b.n	100043aa <xQueueGenericSend+0x1be>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
100042e8:	687b      	ldr	r3, [r7, #4]
100042ea:	2b00      	cmp	r3, #0
100042ec:	d103      	bne.n	100042f6 <xQueueGenericSend+0x10a>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
100042ee:	f7ff fd61 	bl	10003db4 <vPortExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
100042f2:	2300      	movs	r3, #0
100042f4:	e059      	b.n	100043aa <xQueueGenericSend+0x1be>
                }
                else if( xEntryTimeSet == pdFALSE )
100042f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
100042f8:	2b00      	cmp	r3, #0
100042fa:	d106      	bne.n	1000430a <xQueueGenericSend+0x11e>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
100042fc:	2310      	movs	r3, #16
100042fe:	18fb      	adds	r3, r7, r3
10004300:	1c18      	adds	r0, r3, #0
10004302:	f000 ff81 	bl	10005208 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
10004306:	2301      	movs	r3, #1
10004308:	627b      	str	r3, [r7, #36]	; 0x24
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
1000430a:	f7ff fd53 	bl	10003db4 <vPortExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
1000430e:	f000 fd39 	bl	10004d84 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
10004312:	f7ff fd3f 	bl	10003d94 <vPortEnterCritical>
10004316:	6a3b      	ldr	r3, [r7, #32]
10004318:	2244      	movs	r2, #68	; 0x44
1000431a:	5c9b      	ldrb	r3, [r3, r2]
1000431c:	b2db      	uxtb	r3, r3
1000431e:	b25b      	sxtb	r3, r3
10004320:	3301      	adds	r3, #1
10004322:	d103      	bne.n	1000432c <xQueueGenericSend+0x140>
10004324:	6a3b      	ldr	r3, [r7, #32]
10004326:	2244      	movs	r2, #68	; 0x44
10004328:	2100      	movs	r1, #0
1000432a:	5499      	strb	r1, [r3, r2]
1000432c:	6a3b      	ldr	r3, [r7, #32]
1000432e:	2245      	movs	r2, #69	; 0x45
10004330:	5c9b      	ldrb	r3, [r3, r2]
10004332:	b2db      	uxtb	r3, r3
10004334:	b25b      	sxtb	r3, r3
10004336:	3301      	adds	r3, #1
10004338:	d103      	bne.n	10004342 <xQueueGenericSend+0x156>
1000433a:	6a3b      	ldr	r3, [r7, #32]
1000433c:	2245      	movs	r2, #69	; 0x45
1000433e:	2100      	movs	r1, #0
10004340:	5499      	strb	r1, [r3, r2]
10004342:	f7ff fd37 	bl	10003db4 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
10004346:	2310      	movs	r3, #16
10004348:	18fa      	adds	r2, r7, r3
1000434a:	1d3b      	adds	r3, r7, #4
1000434c:	1c10      	adds	r0, r2, #0
1000434e:	1c19      	adds	r1, r3, #0
10004350:	f000 ff6e 	bl	10005230 <xTaskCheckForTimeOut>
10004354:	1e03      	subs	r3, r0, #0
10004356:	d11f      	bne.n	10004398 <xQueueGenericSend+0x1ac>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
10004358:	6a3b      	ldr	r3, [r7, #32]
1000435a:	1c18      	adds	r0, r3, #0
1000435c:	f000 fa96 	bl	1000488c <prvIsQueueFull>
10004360:	1e03      	subs	r3, r0, #0
10004362:	d012      	beq.n	1000438a <xQueueGenericSend+0x19e>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
10004364:	6a3b      	ldr	r3, [r7, #32]
10004366:	3310      	adds	r3, #16
10004368:	1c1a      	adds	r2, r3, #0
1000436a:	687b      	ldr	r3, [r7, #4]
1000436c:	1c10      	adds	r0, r2, #0
1000436e:	1c19      	adds	r1, r3, #0
10004370:	f000 feae 	bl	100050d0 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
10004374:	6a3b      	ldr	r3, [r7, #32]
10004376:	1c18      	adds	r0, r3, #0
10004378:	f000 fa06 	bl	10004788 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
1000437c:	f000 fd0e 	bl	10004d9c <xTaskResumeAll>
10004380:	1e03      	subs	r3, r0, #0
10004382:	d111      	bne.n	100043a8 <xQueueGenericSend+0x1bc>
                {
                    portYIELD_WITHIN_API();
10004384:	f7ff fcf8 	bl	10003d78 <vPortYield>
10004388:	e00e      	b.n	100043a8 <xQueueGenericSend+0x1bc>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
1000438a:	6a3b      	ldr	r3, [r7, #32]
1000438c:	1c18      	adds	r0, r3, #0
1000438e:	f000 f9fb 	bl	10004788 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
10004392:	f000 fd03 	bl	10004d9c <xTaskResumeAll>
10004396:	e763      	b.n	10004260 <xQueueGenericSend+0x74>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
10004398:	6a3b      	ldr	r3, [r7, #32]
1000439a:	1c18      	adds	r0, r3, #0
1000439c:	f000 f9f4 	bl	10004788 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
100043a0:	f000 fcfc 	bl	10004d9c <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
100043a4:	2300      	movs	r3, #0
100043a6:	e000      	b.n	100043aa <xQueueGenericSend+0x1be>
        }
    } /*lint -restore */
100043a8:	e75a      	b.n	10004260 <xQueueGenericSend+0x74>
}
100043aa:	1c18      	adds	r0, r3, #0
100043ac:	46bd      	mov	sp, r7
100043ae:	b00a      	add	sp, #40	; 0x28
100043b0:	bd80      	pop	{r7, pc}
100043b2:	46c0      	nop			; (mov r8, r8)

100043b4 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
100043b4:	b580      	push	{r7, lr}
100043b6:	b08a      	sub	sp, #40	; 0x28
100043b8:	af00      	add	r7, sp, #0
100043ba:	60f8      	str	r0, [r7, #12]
100043bc:	60b9      	str	r1, [r7, #8]
100043be:	607a      	str	r2, [r7, #4]
100043c0:	603b      	str	r3, [r7, #0]
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
100043c2:	68fb      	ldr	r3, [r7, #12]
100043c4:	623b      	str	r3, [r7, #32]

    configASSERT( pxQueue );
100043c6:	6a3b      	ldr	r3, [r7, #32]
100043c8:	2b00      	cmp	r3, #0
100043ca:	d101      	bne.n	100043d0 <xQueueGenericSendFromISR+0x1c>
100043cc:	b672      	cpsid	i
100043ce:	e7fe      	b.n	100043ce <xQueueGenericSendFromISR+0x1a>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
100043d0:	68bb      	ldr	r3, [r7, #8]
100043d2:	2b00      	cmp	r3, #0
100043d4:	d103      	bne.n	100043de <xQueueGenericSendFromISR+0x2a>
100043d6:	6a3b      	ldr	r3, [r7, #32]
100043d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100043da:	2b00      	cmp	r3, #0
100043dc:	d101      	bne.n	100043e2 <xQueueGenericSendFromISR+0x2e>
100043de:	2301      	movs	r3, #1
100043e0:	e000      	b.n	100043e4 <xQueueGenericSendFromISR+0x30>
100043e2:	2300      	movs	r3, #0
100043e4:	2b00      	cmp	r3, #0
100043e6:	d101      	bne.n	100043ec <xQueueGenericSendFromISR+0x38>
100043e8:	b672      	cpsid	i
100043ea:	e7fe      	b.n	100043ea <xQueueGenericSendFromISR+0x36>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
100043ec:	683b      	ldr	r3, [r7, #0]
100043ee:	2b02      	cmp	r3, #2
100043f0:	d103      	bne.n	100043fa <xQueueGenericSendFromISR+0x46>
100043f2:	6a3b      	ldr	r3, [r7, #32]
100043f4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100043f6:	2b01      	cmp	r3, #1
100043f8:	d101      	bne.n	100043fe <xQueueGenericSendFromISR+0x4a>
100043fa:	2301      	movs	r3, #1
100043fc:	e000      	b.n	10004400 <xQueueGenericSendFromISR+0x4c>
100043fe:	2300      	movs	r3, #0
10004400:	2b00      	cmp	r3, #0
10004402:	d101      	bne.n	10004408 <xQueueGenericSendFromISR+0x54>
10004404:	b672      	cpsid	i
10004406:	e7fe      	b.n	10004406 <xQueueGenericSendFromISR+0x52>
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
10004408:	f7ff fcea 	bl	10003de0 <ulSetInterruptMaskFromISR>
1000440c:	1c03      	adds	r3, r0, #0
1000440e:	61fb      	str	r3, [r7, #28]
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
10004410:	6a3b      	ldr	r3, [r7, #32]
10004412:	6b9a      	ldr	r2, [r3, #56]	; 0x38
10004414:	6a3b      	ldr	r3, [r7, #32]
10004416:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10004418:	429a      	cmp	r2, r3
1000441a:	d302      	bcc.n	10004422 <xQueueGenericSendFromISR+0x6e>
1000441c:	683b      	ldr	r3, [r7, #0]
1000441e:	2b02      	cmp	r3, #2
10004420:	d155      	bne.n	100044ce <xQueueGenericSendFromISR+0x11a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
10004422:	231b      	movs	r3, #27
10004424:	18fb      	adds	r3, r7, r3
10004426:	6a3a      	ldr	r2, [r7, #32]
10004428:	2145      	movs	r1, #69	; 0x45
1000442a:	5c52      	ldrb	r2, [r2, r1]
1000442c:	701a      	strb	r2, [r3, #0]
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
1000442e:	6a3b      	ldr	r3, [r7, #32]
10004430:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10004432:	617b      	str	r3, [r7, #20]
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
10004434:	6a39      	ldr	r1, [r7, #32]
10004436:	68ba      	ldr	r2, [r7, #8]
10004438:	683b      	ldr	r3, [r7, #0]
1000443a:	1c08      	adds	r0, r1, #0
1000443c:	1c11      	adds	r1, r2, #0
1000443e:	1c1a      	adds	r2, r3, #0
10004440:	f000 f90a 	bl	10004658 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
10004444:	231b      	movs	r3, #27
10004446:	18fb      	adds	r3, r7, r3
10004448:	781b      	ldrb	r3, [r3, #0]
1000444a:	b25b      	sxtb	r3, r3
1000444c:	3301      	adds	r3, #1
1000444e:	d12a      	bne.n	100044a6 <xQueueGenericSendFromISR+0xf2>
            {
                #if ( configUSE_QUEUE_SETS == 1 )
                    {
                        if( pxQueue->pxQueueSetContainer != NULL )
10004450:	6a3b      	ldr	r3, [r7, #32]
10004452:	6c9b      	ldr	r3, [r3, #72]	; 0x48
10004454:	2b00      	cmp	r3, #0
10004456:	d014      	beq.n	10004482 <xQueueGenericSendFromISR+0xce>
                        {
                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
10004458:	683b      	ldr	r3, [r7, #0]
1000445a:	2b02      	cmp	r3, #2
1000445c:	d104      	bne.n	10004468 <xQueueGenericSendFromISR+0xb4>
1000445e:	697b      	ldr	r3, [r7, #20]
10004460:	2b00      	cmp	r3, #0
10004462:	d001      	beq.n	10004468 <xQueueGenericSendFromISR+0xb4>
10004464:	46c0      	nop			; (mov r8, r8)
10004466:	e02f      	b.n	100044c8 <xQueueGenericSendFromISR+0x114>
                                /* Do not notify the queue set as an existing item
                                 * was overwritten in the queue so the number of items
                                 * in the queue has not changed. */
                                mtCOVERAGE_TEST_MARKER();
                            }
                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
10004468:	6a3b      	ldr	r3, [r7, #32]
1000446a:	1c18      	adds	r0, r3, #0
1000446c:	f000 fa84 	bl	10004978 <prvNotifyQueueSetContainer>
10004470:	1e03      	subs	r3, r0, #0
10004472:	d029      	beq.n	100044c8 <xQueueGenericSendFromISR+0x114>
                            {
                                /* The queue is a member of a queue set, and posting
                                 * to the queue set caused a higher priority task to
                                 * unblock.  A context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
10004474:	687b      	ldr	r3, [r7, #4]
10004476:	2b00      	cmp	r3, #0
10004478:	d026      	beq.n	100044c8 <xQueueGenericSendFromISR+0x114>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
1000447a:	687b      	ldr	r3, [r7, #4]
1000447c:	2201      	movs	r2, #1
1000447e:	601a      	str	r2, [r3, #0]
10004480:	e022      	b.n	100044c8 <xQueueGenericSendFromISR+0x114>
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else
                        {
                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
10004482:	6a3b      	ldr	r3, [r7, #32]
10004484:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10004486:	2b00      	cmp	r3, #0
10004488:	d01e      	beq.n	100044c8 <xQueueGenericSendFromISR+0x114>
                            {
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1000448a:	6a3b      	ldr	r3, [r7, #32]
1000448c:	3324      	adds	r3, #36	; 0x24
1000448e:	1c18      	adds	r0, r3, #0
10004490:	f000 fe5e 	bl	10005150 <xTaskRemoveFromEventList>
10004494:	1e03      	subs	r3, r0, #0
10004496:	d017      	beq.n	100044c8 <xQueueGenericSendFromISR+0x114>
                                {
                                    /* The task waiting has a higher priority so
                                     *  record that a context switch is required. */
                                    if( pxHigherPriorityTaskWoken != NULL )
10004498:	687b      	ldr	r3, [r7, #4]
1000449a:	2b00      	cmp	r3, #0
1000449c:	d014      	beq.n	100044c8 <xQueueGenericSendFromISR+0x114>
                                    {
                                        *pxHigherPriorityTaskWoken = pdTRUE;
1000449e:	687b      	ldr	r3, [r7, #4]
100044a0:	2201      	movs	r2, #1
100044a2:	601a      	str	r2, [r3, #0]
100044a4:	e010      	b.n	100044c8 <xQueueGenericSendFromISR+0x114>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );
100044a6:	231b      	movs	r3, #27
100044a8:	18fb      	adds	r3, r7, r3
100044aa:	781b      	ldrb	r3, [r3, #0]
100044ac:	b25b      	sxtb	r3, r3
100044ae:	2b7f      	cmp	r3, #127	; 0x7f
100044b0:	d101      	bne.n	100044b6 <xQueueGenericSendFromISR+0x102>
100044b2:	b672      	cpsid	i
100044b4:	e7fe      	b.n	100044b4 <xQueueGenericSendFromISR+0x100>

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
100044b6:	231b      	movs	r3, #27
100044b8:	18fb      	adds	r3, r7, r3
100044ba:	781b      	ldrb	r3, [r3, #0]
100044bc:	3301      	adds	r3, #1
100044be:	b2db      	uxtb	r3, r3
100044c0:	b2d9      	uxtb	r1, r3
100044c2:	6a3b      	ldr	r3, [r7, #32]
100044c4:	2245      	movs	r2, #69	; 0x45
100044c6:	5499      	strb	r1, [r3, r2]
            }

            xReturn = pdPASS;
100044c8:	2301      	movs	r3, #1
100044ca:	627b      	str	r3, [r7, #36]	; 0x24
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
        {
100044cc:	e001      	b.n	100044d2 <xQueueGenericSendFromISR+0x11e>
            xReturn = pdPASS;
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
100044ce:	2300      	movs	r3, #0
100044d0:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
100044d2:	69fb      	ldr	r3, [r7, #28]
100044d4:	1c18      	adds	r0, r3, #0
100044d6:	f7ff fc89 	bl	10003dec <vClearInterruptMaskFromISR>

    return xReturn;
100044da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
100044dc:	1c18      	adds	r0, r3, #0
100044de:	46bd      	mov	sp, r7
100044e0:	b00a      	add	sp, #40	; 0x28
100044e2:	bd80      	pop	{r7, pc}

100044e4 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
100044e4:	b580      	push	{r7, lr}
100044e6:	b08a      	sub	sp, #40	; 0x28
100044e8:	af00      	add	r7, sp, #0
100044ea:	60f8      	str	r0, [r7, #12]
100044ec:	60b9      	str	r1, [r7, #8]
100044ee:	607a      	str	r2, [r7, #4]
    BaseType_t xEntryTimeSet = pdFALSE;
100044f0:	2300      	movs	r3, #0
100044f2:	627b      	str	r3, [r7, #36]	; 0x24
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
100044f4:	68fb      	ldr	r3, [r7, #12]
100044f6:	623b      	str	r3, [r7, #32]

    /* Check the pointer is not NULL. */
    configASSERT( ( pxQueue ) );
100044f8:	6a3b      	ldr	r3, [r7, #32]
100044fa:	2b00      	cmp	r3, #0
100044fc:	d101      	bne.n	10004502 <xQueueReceive+0x1e>
100044fe:	b672      	cpsid	i
10004500:	e7fe      	b.n	10004500 <xQueueReceive+0x1c>

    /* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer). */
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
10004502:	68bb      	ldr	r3, [r7, #8]
10004504:	2b00      	cmp	r3, #0
10004506:	d103      	bne.n	10004510 <xQueueReceive+0x2c>
10004508:	6a3b      	ldr	r3, [r7, #32]
1000450a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000450c:	2b00      	cmp	r3, #0
1000450e:	d101      	bne.n	10004514 <xQueueReceive+0x30>
10004510:	2301      	movs	r3, #1
10004512:	e000      	b.n	10004516 <xQueueReceive+0x32>
10004514:	2300      	movs	r3, #0
10004516:	2b00      	cmp	r3, #0
10004518:	d101      	bne.n	1000451e <xQueueReceive+0x3a>
1000451a:	b672      	cpsid	i
1000451c:	e7fe      	b.n	1000451c <xQueueReceive+0x38>

    /* Cannot block if the scheduler is suspended. */
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
1000451e:	f000 ff9d 	bl	1000545c <xTaskGetSchedulerState>
10004522:	1e03      	subs	r3, r0, #0
10004524:	d102      	bne.n	1000452c <xQueueReceive+0x48>
10004526:	687b      	ldr	r3, [r7, #4]
10004528:	2b00      	cmp	r3, #0
1000452a:	d101      	bne.n	10004530 <xQueueReceive+0x4c>
1000452c:	2301      	movs	r3, #1
1000452e:	e000      	b.n	10004532 <xQueueReceive+0x4e>
10004530:	2300      	movs	r3, #0
10004532:	2b00      	cmp	r3, #0
10004534:	d101      	bne.n	1000453a <xQueueReceive+0x56>
10004536:	b672      	cpsid	i
10004538:	e7fe      	b.n	10004538 <xQueueReceive+0x54>
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
1000453a:	f7ff fc2b 	bl	10003d94 <vPortEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1000453e:	6a3b      	ldr	r3, [r7, #32]
10004540:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10004542:	61fb      	str	r3, [r7, #28]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
10004544:	69fb      	ldr	r3, [r7, #28]
10004546:	2b00      	cmp	r3, #0
10004548:	d01a      	beq.n	10004580 <xQueueReceive+0x9c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
1000454a:	6a3a      	ldr	r2, [r7, #32]
1000454c:	68bb      	ldr	r3, [r7, #8]
1000454e:	1c10      	adds	r0, r2, #0
10004550:	1c19      	adds	r1, r3, #0
10004552:	f000 f8f1 	bl	10004738 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
10004556:	69fb      	ldr	r3, [r7, #28]
10004558:	1e5a      	subs	r2, r3, #1
1000455a:	6a3b      	ldr	r3, [r7, #32]
1000455c:	639a      	str	r2, [r3, #56]	; 0x38

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1000455e:	6a3b      	ldr	r3, [r7, #32]
10004560:	691b      	ldr	r3, [r3, #16]
10004562:	2b00      	cmp	r3, #0
10004564:	d008      	beq.n	10004578 <xQueueReceive+0x94>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
10004566:	6a3b      	ldr	r3, [r7, #32]
10004568:	3310      	adds	r3, #16
1000456a:	1c18      	adds	r0, r3, #0
1000456c:	f000 fdf0 	bl	10005150 <xTaskRemoveFromEventList>
10004570:	1e03      	subs	r3, r0, #0
10004572:	d001      	beq.n	10004578 <xQueueReceive+0x94>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
10004574:	f7ff fc00 	bl	10003d78 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
10004578:	f7ff fc1c 	bl	10003db4 <vPortExitCritical>
                return pdPASS;
1000457c:	2301      	movs	r3, #1
1000457e:	e066      	b.n	1000464e <xQueueReceive+0x16a>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
10004580:	687b      	ldr	r3, [r7, #4]
10004582:	2b00      	cmp	r3, #0
10004584:	d103      	bne.n	1000458e <xQueueReceive+0xaa>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
10004586:	f7ff fc15 	bl	10003db4 <vPortExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
1000458a:	2300      	movs	r3, #0
1000458c:	e05f      	b.n	1000464e <xQueueReceive+0x16a>
                }
                else if( xEntryTimeSet == pdFALSE )
1000458e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10004590:	2b00      	cmp	r3, #0
10004592:	d106      	bne.n	100045a2 <xQueueReceive+0xbe>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
10004594:	2314      	movs	r3, #20
10004596:	18fb      	adds	r3, r7, r3
10004598:	1c18      	adds	r0, r3, #0
1000459a:	f000 fe35 	bl	10005208 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
1000459e:	2301      	movs	r3, #1
100045a0:	627b      	str	r3, [r7, #36]	; 0x24
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
100045a2:	f7ff fc07 	bl	10003db4 <vPortExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
100045a6:	f000 fbed 	bl	10004d84 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
100045aa:	f7ff fbf3 	bl	10003d94 <vPortEnterCritical>
100045ae:	6a3b      	ldr	r3, [r7, #32]
100045b0:	2244      	movs	r2, #68	; 0x44
100045b2:	5c9b      	ldrb	r3, [r3, r2]
100045b4:	b2db      	uxtb	r3, r3
100045b6:	b25b      	sxtb	r3, r3
100045b8:	3301      	adds	r3, #1
100045ba:	d103      	bne.n	100045c4 <xQueueReceive+0xe0>
100045bc:	6a3b      	ldr	r3, [r7, #32]
100045be:	2244      	movs	r2, #68	; 0x44
100045c0:	2100      	movs	r1, #0
100045c2:	5499      	strb	r1, [r3, r2]
100045c4:	6a3b      	ldr	r3, [r7, #32]
100045c6:	2245      	movs	r2, #69	; 0x45
100045c8:	5c9b      	ldrb	r3, [r3, r2]
100045ca:	b2db      	uxtb	r3, r3
100045cc:	b25b      	sxtb	r3, r3
100045ce:	3301      	adds	r3, #1
100045d0:	d103      	bne.n	100045da <xQueueReceive+0xf6>
100045d2:	6a3b      	ldr	r3, [r7, #32]
100045d4:	2245      	movs	r2, #69	; 0x45
100045d6:	2100      	movs	r1, #0
100045d8:	5499      	strb	r1, [r3, r2]
100045da:	f7ff fbeb 	bl	10003db4 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
100045de:	2314      	movs	r3, #20
100045e0:	18fa      	adds	r2, r7, r3
100045e2:	1d3b      	adds	r3, r7, #4
100045e4:	1c10      	adds	r0, r2, #0
100045e6:	1c19      	adds	r1, r3, #0
100045e8:	f000 fe22 	bl	10005230 <xTaskCheckForTimeOut>
100045ec:	1e03      	subs	r3, r0, #0
100045ee:	d11f      	bne.n	10004630 <xQueueReceive+0x14c>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
100045f0:	6a3b      	ldr	r3, [r7, #32]
100045f2:	1c18      	adds	r0, r3, #0
100045f4:	f000 f934 	bl	10004860 <prvIsQueueEmpty>
100045f8:	1e03      	subs	r3, r0, #0
100045fa:	d012      	beq.n	10004622 <xQueueReceive+0x13e>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
100045fc:	6a3b      	ldr	r3, [r7, #32]
100045fe:	3324      	adds	r3, #36	; 0x24
10004600:	1c1a      	adds	r2, r3, #0
10004602:	687b      	ldr	r3, [r7, #4]
10004604:	1c10      	adds	r0, r2, #0
10004606:	1c19      	adds	r1, r3, #0
10004608:	f000 fd62 	bl	100050d0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
1000460c:	6a3b      	ldr	r3, [r7, #32]
1000460e:	1c18      	adds	r0, r3, #0
10004610:	f000 f8ba 	bl	10004788 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
10004614:	f000 fbc2 	bl	10004d9c <xTaskResumeAll>
10004618:	1e03      	subs	r3, r0, #0
1000461a:	d117      	bne.n	1000464c <xQueueReceive+0x168>
                {
                    portYIELD_WITHIN_API();
1000461c:	f7ff fbac 	bl	10003d78 <vPortYield>
10004620:	e014      	b.n	1000464c <xQueueReceive+0x168>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
10004622:	6a3b      	ldr	r3, [r7, #32]
10004624:	1c18      	adds	r0, r3, #0
10004626:	f000 f8af 	bl	10004788 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
1000462a:	f000 fbb7 	bl	10004d9c <xTaskResumeAll>
1000462e:	e784      	b.n	1000453a <xQueueReceive+0x56>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
10004630:	6a3b      	ldr	r3, [r7, #32]
10004632:	1c18      	adds	r0, r3, #0
10004634:	f000 f8a8 	bl	10004788 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
10004638:	f000 fbb0 	bl	10004d9c <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1000463c:	6a3b      	ldr	r3, [r7, #32]
1000463e:	1c18      	adds	r0, r3, #0
10004640:	f000 f90e 	bl	10004860 <prvIsQueueEmpty>
10004644:	1e03      	subs	r3, r0, #0
10004646:	d001      	beq.n	1000464c <xQueueReceive+0x168>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
10004648:	2300      	movs	r3, #0
1000464a:	e000      	b.n	1000464e <xQueueReceive+0x16a>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
1000464c:	e775      	b.n	1000453a <xQueueReceive+0x56>
}
1000464e:	1c18      	adds	r0, r3, #0
10004650:	46bd      	mov	sp, r7
10004652:	b00a      	add	sp, #40	; 0x28
10004654:	bd80      	pop	{r7, pc}
10004656:	46c0      	nop			; (mov r8, r8)

10004658 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
10004658:	b580      	push	{r7, lr}
1000465a:	b086      	sub	sp, #24
1000465c:	af00      	add	r7, sp, #0
1000465e:	60f8      	str	r0, [r7, #12]
10004660:	60b9      	str	r1, [r7, #8]
10004662:	607a      	str	r2, [r7, #4]
    BaseType_t xReturn = pdFALSE;
10004664:	2300      	movs	r3, #0
10004666:	617b      	str	r3, [r7, #20]
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
10004668:	68fb      	ldr	r3, [r7, #12]
1000466a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
1000466c:	613b      	str	r3, [r7, #16]

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
1000466e:	68fb      	ldr	r3, [r7, #12]
10004670:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10004672:	2b00      	cmp	r3, #0
10004674:	d10e      	bne.n	10004694 <prvCopyDataToQueue+0x3c>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
10004676:	68fb      	ldr	r3, [r7, #12]
10004678:	681b      	ldr	r3, [r3, #0]
1000467a:	2b00      	cmp	r3, #0
1000467c:	d152      	bne.n	10004724 <prvCopyDataToQueue+0xcc>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
1000467e:	68fb      	ldr	r3, [r7, #12]
10004680:	689b      	ldr	r3, [r3, #8]
10004682:	1c18      	adds	r0, r3, #0
10004684:	f000 ff06 	bl	10005494 <xTaskPriorityDisinherit>
10004688:	1c03      	adds	r3, r0, #0
1000468a:	617b      	str	r3, [r7, #20]
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
1000468c:	68fb      	ldr	r3, [r7, #12]
1000468e:	2200      	movs	r2, #0
10004690:	609a      	str	r2, [r3, #8]
10004692:	e047      	b.n	10004724 <prvCopyDataToQueue+0xcc>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
10004694:	687b      	ldr	r3, [r7, #4]
10004696:	2b00      	cmp	r3, #0
10004698:	d11b      	bne.n	100046d2 <prvCopyDataToQueue+0x7a>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
1000469a:	68fb      	ldr	r3, [r7, #12]
1000469c:	6859      	ldr	r1, [r3, #4]
1000469e:	68fb      	ldr	r3, [r7, #12]
100046a0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100046a2:	68ba      	ldr	r2, [r7, #8]
100046a4:	1c08      	adds	r0, r1, #0
100046a6:	1c11      	adds	r1, r2, #0
100046a8:	1c1a      	adds	r2, r3, #0
100046aa:	f001 ff3d 	bl	10006528 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
100046ae:	68fb      	ldr	r3, [r7, #12]
100046b0:	685a      	ldr	r2, [r3, #4]
100046b2:	68fb      	ldr	r3, [r7, #12]
100046b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100046b6:	18d2      	adds	r2, r2, r3
100046b8:	68fb      	ldr	r3, [r7, #12]
100046ba:	605a      	str	r2, [r3, #4]

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
100046bc:	68fb      	ldr	r3, [r7, #12]
100046be:	685a      	ldr	r2, [r3, #4]
100046c0:	68fb      	ldr	r3, [r7, #12]
100046c2:	689b      	ldr	r3, [r3, #8]
100046c4:	429a      	cmp	r2, r3
100046c6:	d32d      	bcc.n	10004724 <prvCopyDataToQueue+0xcc>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
100046c8:	68fb      	ldr	r3, [r7, #12]
100046ca:	681a      	ldr	r2, [r3, #0]
100046cc:	68fb      	ldr	r3, [r7, #12]
100046ce:	605a      	str	r2, [r3, #4]
100046d0:	e028      	b.n	10004724 <prvCopyDataToQueue+0xcc>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
100046d2:	68fb      	ldr	r3, [r7, #12]
100046d4:	68d9      	ldr	r1, [r3, #12]
100046d6:	68fb      	ldr	r3, [r7, #12]
100046d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100046da:	68ba      	ldr	r2, [r7, #8]
100046dc:	1c08      	adds	r0, r1, #0
100046de:	1c11      	adds	r1, r2, #0
100046e0:	1c1a      	adds	r2, r3, #0
100046e2:	f001 ff21 	bl	10006528 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
100046e6:	68fb      	ldr	r3, [r7, #12]
100046e8:	68da      	ldr	r2, [r3, #12]
100046ea:	68fb      	ldr	r3, [r7, #12]
100046ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100046ee:	425b      	negs	r3, r3
100046f0:	18d2      	adds	r2, r2, r3
100046f2:	68fb      	ldr	r3, [r7, #12]
100046f4:	60da      	str	r2, [r3, #12]

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
100046f6:	68fb      	ldr	r3, [r7, #12]
100046f8:	68da      	ldr	r2, [r3, #12]
100046fa:	68fb      	ldr	r3, [r7, #12]
100046fc:	681b      	ldr	r3, [r3, #0]
100046fe:	429a      	cmp	r2, r3
10004700:	d207      	bcs.n	10004712 <prvCopyDataToQueue+0xba>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
10004702:	68fb      	ldr	r3, [r7, #12]
10004704:	689a      	ldr	r2, [r3, #8]
10004706:	68fb      	ldr	r3, [r7, #12]
10004708:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000470a:	425b      	negs	r3, r3
1000470c:	18d2      	adds	r2, r2, r3
1000470e:	68fb      	ldr	r3, [r7, #12]
10004710:	60da      	str	r2, [r3, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
10004712:	687b      	ldr	r3, [r7, #4]
10004714:	2b02      	cmp	r3, #2
10004716:	d105      	bne.n	10004724 <prvCopyDataToQueue+0xcc>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
10004718:	693b      	ldr	r3, [r7, #16]
1000471a:	2b00      	cmp	r3, #0
1000471c:	d002      	beq.n	10004724 <prvCopyDataToQueue+0xcc>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
1000471e:	693b      	ldr	r3, [r7, #16]
10004720:	3b01      	subs	r3, #1
10004722:	613b      	str	r3, [r7, #16]
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
10004724:	693b      	ldr	r3, [r7, #16]
10004726:	1c5a      	adds	r2, r3, #1
10004728:	68fb      	ldr	r3, [r7, #12]
1000472a:	639a      	str	r2, [r3, #56]	; 0x38

    return xReturn;
1000472c:	697b      	ldr	r3, [r7, #20]
}
1000472e:	1c18      	adds	r0, r3, #0
10004730:	46bd      	mov	sp, r7
10004732:	b006      	add	sp, #24
10004734:	bd80      	pop	{r7, pc}
10004736:	46c0      	nop			; (mov r8, r8)

10004738 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
10004738:	b580      	push	{r7, lr}
1000473a:	b082      	sub	sp, #8
1000473c:	af00      	add	r7, sp, #0
1000473e:	6078      	str	r0, [r7, #4]
10004740:	6039      	str	r1, [r7, #0]
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
10004742:	687b      	ldr	r3, [r7, #4]
10004744:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10004746:	2b00      	cmp	r3, #0
10004748:	d01a      	beq.n	10004780 <prvCopyDataFromQueue+0x48>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
1000474a:	687b      	ldr	r3, [r7, #4]
1000474c:	68da      	ldr	r2, [r3, #12]
1000474e:	687b      	ldr	r3, [r7, #4]
10004750:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10004752:	18d2      	adds	r2, r2, r3
10004754:	687b      	ldr	r3, [r7, #4]
10004756:	60da      	str	r2, [r3, #12]

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
10004758:	687b      	ldr	r3, [r7, #4]
1000475a:	68da      	ldr	r2, [r3, #12]
1000475c:	687b      	ldr	r3, [r7, #4]
1000475e:	689b      	ldr	r3, [r3, #8]
10004760:	429a      	cmp	r2, r3
10004762:	d303      	bcc.n	1000476c <prvCopyDataFromQueue+0x34>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
10004764:	687b      	ldr	r3, [r7, #4]
10004766:	681a      	ldr	r2, [r3, #0]
10004768:	687b      	ldr	r3, [r7, #4]
1000476a:	60da      	str	r2, [r3, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
1000476c:	687b      	ldr	r3, [r7, #4]
1000476e:	68da      	ldr	r2, [r3, #12]
10004770:	687b      	ldr	r3, [r7, #4]
10004772:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10004774:	6839      	ldr	r1, [r7, #0]
10004776:	1c08      	adds	r0, r1, #0
10004778:	1c11      	adds	r1, r2, #0
1000477a:	1c1a      	adds	r2, r3, #0
1000477c:	f001 fed4 	bl	10006528 <memcpy>
    }
}
10004780:	46bd      	mov	sp, r7
10004782:	b002      	add	sp, #8
10004784:	bd80      	pop	{r7, pc}
10004786:	46c0      	nop			; (mov r8, r8)

10004788 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
10004788:	b580      	push	{r7, lr}
1000478a:	b084      	sub	sp, #16
1000478c:	af00      	add	r7, sp, #0
1000478e:	6078      	str	r0, [r7, #4]

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
10004790:	f7ff fb00 	bl	10003d94 <vPortEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
10004794:	230f      	movs	r3, #15
10004796:	18fb      	adds	r3, r7, r3
10004798:	687a      	ldr	r2, [r7, #4]
1000479a:	2145      	movs	r1, #69	; 0x45
1000479c:	5c52      	ldrb	r2, [r2, r1]
1000479e:	701a      	strb	r2, [r3, #0]

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
100047a0:	e023      	b.n	100047ea <prvUnlockQueue+0x62>
        {
            /* Data was posted while the queue was locked.  Are any tasks
             * blocked waiting for data to become available? */
            #if ( configUSE_QUEUE_SETS == 1 )
                {
                    if( pxQueue->pxQueueSetContainer != NULL )
100047a2:	687b      	ldr	r3, [r7, #4]
100047a4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
100047a6:	2b00      	cmp	r3, #0
100047a8:	d008      	beq.n	100047bc <prvUnlockQueue+0x34>
                    {
                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
100047aa:	687b      	ldr	r3, [r7, #4]
100047ac:	1c18      	adds	r0, r3, #0
100047ae:	f000 f8e3 	bl	10004978 <prvNotifyQueueSetContainer>
100047b2:	1e03      	subs	r3, r0, #0
100047b4:	d011      	beq.n	100047da <prvUnlockQueue+0x52>
                        {
                            /* The queue is a member of a queue set, and posting to
                             * the queue set caused a higher priority task to unblock.
                             * A context switch is required. */
                            vTaskMissedYield();
100047b6:	f000 fd9f 	bl	100052f8 <vTaskMissedYield>
100047ba:	e00e      	b.n	100047da <prvUnlockQueue+0x52>
                    else
                    {
                        /* Tasks that are removed from the event list will get
                         * added to the pending ready list as the scheduler is still
                         * suspended. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
100047bc:	687b      	ldr	r3, [r7, #4]
100047be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100047c0:	2b00      	cmp	r3, #0
100047c2:	d009      	beq.n	100047d8 <prvUnlockQueue+0x50>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
100047c4:	687b      	ldr	r3, [r7, #4]
100047c6:	3324      	adds	r3, #36	; 0x24
100047c8:	1c18      	adds	r0, r3, #0
100047ca:	f000 fcc1 	bl	10005150 <xTaskRemoveFromEventList>
100047ce:	1e03      	subs	r3, r0, #0
100047d0:	d003      	beq.n	100047da <prvUnlockQueue+0x52>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                vTaskMissedYield();
100047d2:	f000 fd91 	bl	100052f8 <vTaskMissedYield>
100047d6:	e000      	b.n	100047da <prvUnlockQueue+0x52>
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else
                        {
                            break;
100047d8:	e00d      	b.n	100047f6 <prvUnlockQueue+0x6e>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
100047da:	230f      	movs	r3, #15
100047dc:	18fb      	adds	r3, r7, r3
100047de:	781b      	ldrb	r3, [r3, #0]
100047e0:	3b01      	subs	r3, #1
100047e2:	b2da      	uxtb	r2, r3
100047e4:	230f      	movs	r3, #15
100047e6:	18fb      	adds	r3, r7, r3
100047e8:	701a      	strb	r2, [r3, #0]
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
100047ea:	230f      	movs	r3, #15
100047ec:	18fb      	adds	r3, r7, r3
100047ee:	781b      	ldrb	r3, [r3, #0]
100047f0:	b25b      	sxtb	r3, r3
100047f2:	2b00      	cmp	r3, #0
100047f4:	dcd5      	bgt.n	100047a2 <prvUnlockQueue+0x1a>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
100047f6:	687b      	ldr	r3, [r7, #4]
100047f8:	2245      	movs	r2, #69	; 0x45
100047fa:	21ff      	movs	r1, #255	; 0xff
100047fc:	5499      	strb	r1, [r3, r2]
    }
    taskEXIT_CRITICAL();
100047fe:	f7ff fad9 	bl	10003db4 <vPortExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
10004802:	f7ff fac7 	bl	10003d94 <vPortEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
10004806:	230e      	movs	r3, #14
10004808:	18fb      	adds	r3, r7, r3
1000480a:	687a      	ldr	r2, [r7, #4]
1000480c:	2144      	movs	r1, #68	; 0x44
1000480e:	5c52      	ldrb	r2, [r2, r1]
10004810:	701a      	strb	r2, [r3, #0]

        while( cRxLock > queueLOCKED_UNMODIFIED )
10004812:	e016      	b.n	10004842 <prvUnlockQueue+0xba>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
10004814:	687b      	ldr	r3, [r7, #4]
10004816:	691b      	ldr	r3, [r3, #16]
10004818:	2b00      	cmp	r3, #0
1000481a:	d011      	beq.n	10004840 <prvUnlockQueue+0xb8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1000481c:	687b      	ldr	r3, [r7, #4]
1000481e:	3310      	adds	r3, #16
10004820:	1c18      	adds	r0, r3, #0
10004822:	f000 fc95 	bl	10005150 <xTaskRemoveFromEventList>
10004826:	1e03      	subs	r3, r0, #0
10004828:	d001      	beq.n	1000482e <prvUnlockQueue+0xa6>
                {
                    vTaskMissedYield();
1000482a:	f000 fd65 	bl	100052f8 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
1000482e:	230e      	movs	r3, #14
10004830:	18fb      	adds	r3, r7, r3
10004832:	781b      	ldrb	r3, [r3, #0]
10004834:	3b01      	subs	r3, #1
10004836:	b2da      	uxtb	r2, r3
10004838:	230e      	movs	r3, #14
1000483a:	18fb      	adds	r3, r7, r3
1000483c:	701a      	strb	r2, [r3, #0]
1000483e:	e000      	b.n	10004842 <prvUnlockQueue+0xba>
            }
            else
            {
                break;
10004840:	e005      	b.n	1000484e <prvUnlockQueue+0xc6>
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
10004842:	230e      	movs	r3, #14
10004844:	18fb      	adds	r3, r7, r3
10004846:	781b      	ldrb	r3, [r3, #0]
10004848:	b25b      	sxtb	r3, r3
1000484a:	2b00      	cmp	r3, #0
1000484c:	dce2      	bgt.n	10004814 <prvUnlockQueue+0x8c>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
1000484e:	687b      	ldr	r3, [r7, #4]
10004850:	2244      	movs	r2, #68	; 0x44
10004852:	21ff      	movs	r1, #255	; 0xff
10004854:	5499      	strb	r1, [r3, r2]
    }
    taskEXIT_CRITICAL();
10004856:	f7ff faad 	bl	10003db4 <vPortExitCritical>
}
1000485a:	46bd      	mov	sp, r7
1000485c:	b004      	add	sp, #16
1000485e:	bd80      	pop	{r7, pc}

10004860 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
10004860:	b580      	push	{r7, lr}
10004862:	b084      	sub	sp, #16
10004864:	af00      	add	r7, sp, #0
10004866:	6078      	str	r0, [r7, #4]
    BaseType_t xReturn;

    taskENTER_CRITICAL();
10004868:	f7ff fa94 	bl	10003d94 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
1000486c:	687b      	ldr	r3, [r7, #4]
1000486e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10004870:	2b00      	cmp	r3, #0
10004872:	d102      	bne.n	1000487a <prvIsQueueEmpty+0x1a>
        {
            xReturn = pdTRUE;
10004874:	2301      	movs	r3, #1
10004876:	60fb      	str	r3, [r7, #12]
10004878:	e001      	b.n	1000487e <prvIsQueueEmpty+0x1e>
        }
        else
        {
            xReturn = pdFALSE;
1000487a:	2300      	movs	r3, #0
1000487c:	60fb      	str	r3, [r7, #12]
        }
    }
    taskEXIT_CRITICAL();
1000487e:	f7ff fa99 	bl	10003db4 <vPortExitCritical>

    return xReturn;
10004882:	68fb      	ldr	r3, [r7, #12]
}
10004884:	1c18      	adds	r0, r3, #0
10004886:	46bd      	mov	sp, r7
10004888:	b004      	add	sp, #16
1000488a:	bd80      	pop	{r7, pc}

1000488c <prvIsQueueFull>:
    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
1000488c:	b580      	push	{r7, lr}
1000488e:	b084      	sub	sp, #16
10004890:	af00      	add	r7, sp, #0
10004892:	6078      	str	r0, [r7, #4]
    BaseType_t xReturn;

    taskENTER_CRITICAL();
10004894:	f7ff fa7e 	bl	10003d94 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
10004898:	687b      	ldr	r3, [r7, #4]
1000489a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
1000489c:	687b      	ldr	r3, [r7, #4]
1000489e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100048a0:	429a      	cmp	r2, r3
100048a2:	d102      	bne.n	100048aa <prvIsQueueFull+0x1e>
        {
            xReturn = pdTRUE;
100048a4:	2301      	movs	r3, #1
100048a6:	60fb      	str	r3, [r7, #12]
100048a8:	e001      	b.n	100048ae <prvIsQueueFull+0x22>
        }
        else
        {
            xReturn = pdFALSE;
100048aa:	2300      	movs	r3, #0
100048ac:	60fb      	str	r3, [r7, #12]
        }
    }
    taskEXIT_CRITICAL();
100048ae:	f7ff fa81 	bl	10003db4 <vPortExitCritical>

    return xReturn;
100048b2:	68fb      	ldr	r3, [r7, #12]
}
100048b4:	1c18      	adds	r0, r3, #0
100048b6:	46bd      	mov	sp, r7
100048b8:	b004      	add	sp, #16
100048ba:	bd80      	pop	{r7, pc}

100048bc <vQueueAddToRegistry>:

#if ( configQUEUE_REGISTRY_SIZE > 0 )

    void vQueueAddToRegistry( QueueHandle_t xQueue,
                              const char * pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
100048bc:	b580      	push	{r7, lr}
100048be:	b084      	sub	sp, #16
100048c0:	af00      	add	r7, sp, #0
100048c2:	6078      	str	r0, [r7, #4]
100048c4:	6039      	str	r1, [r7, #0]
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
100048c6:	2300      	movs	r3, #0
100048c8:	60fb      	str	r3, [r7, #12]
100048ca:	e014      	b.n	100048f6 <vQueueAddToRegistry+0x3a>
        {
            if( xQueueRegistry[ ux ].pcQueueName == NULL )
100048cc:	4b0d      	ldr	r3, [pc, #52]	; (10004904 <vQueueAddToRegistry+0x48>)
100048ce:	68fa      	ldr	r2, [r7, #12]
100048d0:	00d2      	lsls	r2, r2, #3
100048d2:	58d3      	ldr	r3, [r2, r3]
100048d4:	2b00      	cmp	r3, #0
100048d6:	d10b      	bne.n	100048f0 <vQueueAddToRegistry+0x34>
            {
                /* Store the information on this queue. */
                xQueueRegistry[ ux ].pcQueueName = pcQueueName;
100048d8:	4b0a      	ldr	r3, [pc, #40]	; (10004904 <vQueueAddToRegistry+0x48>)
100048da:	68fa      	ldr	r2, [r7, #12]
100048dc:	00d2      	lsls	r2, r2, #3
100048de:	6839      	ldr	r1, [r7, #0]
100048e0:	50d1      	str	r1, [r2, r3]
                xQueueRegistry[ ux ].xHandle = xQueue;
100048e2:	4a08      	ldr	r2, [pc, #32]	; (10004904 <vQueueAddToRegistry+0x48>)
100048e4:	68fb      	ldr	r3, [r7, #12]
100048e6:	00db      	lsls	r3, r3, #3
100048e8:	18d3      	adds	r3, r2, r3
100048ea:	687a      	ldr	r2, [r7, #4]
100048ec:	605a      	str	r2, [r3, #4]

                traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
                break;
100048ee:	e005      	b.n	100048fc <vQueueAddToRegistry+0x40>
    {
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
100048f0:	68fb      	ldr	r3, [r7, #12]
100048f2:	3301      	adds	r3, #1
100048f4:	60fb      	str	r3, [r7, #12]
100048f6:	68fb      	ldr	r3, [r7, #12]
100048f8:	2b07      	cmp	r3, #7
100048fa:	d9e7      	bls.n	100048cc <vQueueAddToRegistry+0x10>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
100048fc:	46bd      	mov	sp, r7
100048fe:	b004      	add	sp, #16
10004900:	bd80      	pop	{r7, pc}
10004902:	46c0      	nop			; (mov r8, r8)
10004904:	200007c8 	.word	0x200007c8

10004908 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
10004908:	b580      	push	{r7, lr}
1000490a:	b086      	sub	sp, #24
1000490c:	af00      	add	r7, sp, #0
1000490e:	60f8      	str	r0, [r7, #12]
10004910:	60b9      	str	r1, [r7, #8]
10004912:	607a      	str	r2, [r7, #4]
        Queue_t * const pxQueue = xQueue;
10004914:	68fb      	ldr	r3, [r7, #12]
10004916:	617b      	str	r3, [r7, #20]
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
10004918:	f7ff fa3c 	bl	10003d94 <vPortEnterCritical>
1000491c:	697b      	ldr	r3, [r7, #20]
1000491e:	2244      	movs	r2, #68	; 0x44
10004920:	5c9b      	ldrb	r3, [r3, r2]
10004922:	b2db      	uxtb	r3, r3
10004924:	b25b      	sxtb	r3, r3
10004926:	3301      	adds	r3, #1
10004928:	d103      	bne.n	10004932 <vQueueWaitForMessageRestricted+0x2a>
1000492a:	697b      	ldr	r3, [r7, #20]
1000492c:	2244      	movs	r2, #68	; 0x44
1000492e:	2100      	movs	r1, #0
10004930:	5499      	strb	r1, [r3, r2]
10004932:	697b      	ldr	r3, [r7, #20]
10004934:	2245      	movs	r2, #69	; 0x45
10004936:	5c9b      	ldrb	r3, [r3, r2]
10004938:	b2db      	uxtb	r3, r3
1000493a:	b25b      	sxtb	r3, r3
1000493c:	3301      	adds	r3, #1
1000493e:	d103      	bne.n	10004948 <vQueueWaitForMessageRestricted+0x40>
10004940:	697b      	ldr	r3, [r7, #20]
10004942:	2245      	movs	r2, #69	; 0x45
10004944:	2100      	movs	r1, #0
10004946:	5499      	strb	r1, [r3, r2]
10004948:	f7ff fa34 	bl	10003db4 <vPortExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
1000494c:	697b      	ldr	r3, [r7, #20]
1000494e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10004950:	2b00      	cmp	r3, #0
10004952:	d109      	bne.n	10004968 <vQueueWaitForMessageRestricted+0x60>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
10004954:	697b      	ldr	r3, [r7, #20]
10004956:	3324      	adds	r3, #36	; 0x24
10004958:	1c19      	adds	r1, r3, #0
1000495a:	68ba      	ldr	r2, [r7, #8]
1000495c:	687b      	ldr	r3, [r7, #4]
1000495e:	1c08      	adds	r0, r1, #0
10004960:	1c11      	adds	r1, r2, #0
10004962:	1c1a      	adds	r2, r3, #0
10004964:	f000 fbd0 	bl	10005108 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
10004968:	697b      	ldr	r3, [r7, #20]
1000496a:	1c18      	adds	r0, r3, #0
1000496c:	f7ff ff0c 	bl	10004788 <prvUnlockQueue>
    }
10004970:	46bd      	mov	sp, r7
10004972:	b006      	add	sp, #24
10004974:	bd80      	pop	{r7, pc}
10004976:	46c0      	nop			; (mov r8, r8)

10004978 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
10004978:	b580      	push	{r7, lr}
1000497a:	b086      	sub	sp, #24
1000497c:	af00      	add	r7, sp, #0
1000497e:	6078      	str	r0, [r7, #4]
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
10004980:	687b      	ldr	r3, [r7, #4]
10004982:	6c9b      	ldr	r3, [r3, #72]	; 0x48
10004984:	613b      	str	r3, [r7, #16]
        BaseType_t xReturn = pdFALSE;
10004986:	2300      	movs	r3, #0
10004988:	617b      	str	r3, [r7, #20]

        /* This function must be called form a critical section. */

        configASSERT( pxQueueSetContainer );
1000498a:	693b      	ldr	r3, [r7, #16]
1000498c:	2b00      	cmp	r3, #0
1000498e:	d101      	bne.n	10004994 <prvNotifyQueueSetContainer+0x1c>
10004990:	b672      	cpsid	i
10004992:	e7fe      	b.n	10004992 <prvNotifyQueueSetContainer+0x1a>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
10004994:	693b      	ldr	r3, [r7, #16]
10004996:	6b9a      	ldr	r2, [r3, #56]	; 0x38
10004998:	693b      	ldr	r3, [r7, #16]
1000499a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
1000499c:	429a      	cmp	r2, r3
1000499e:	d301      	bcc.n	100049a4 <prvNotifyQueueSetContainer+0x2c>
100049a0:	b672      	cpsid	i
100049a2:	e7fe      	b.n	100049a2 <prvNotifyQueueSetContainer+0x2a>

        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
100049a4:	693b      	ldr	r3, [r7, #16]
100049a6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
100049a8:	693b      	ldr	r3, [r7, #16]
100049aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100049ac:	429a      	cmp	r2, r3
100049ae:	d234      	bcs.n	10004a1a <prvNotifyQueueSetContainer+0xa2>
        {
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
100049b0:	230f      	movs	r3, #15
100049b2:	18fb      	adds	r3, r7, r3
100049b4:	693a      	ldr	r2, [r7, #16]
100049b6:	2145      	movs	r1, #69	; 0x45
100049b8:	5c52      	ldrb	r2, [r2, r1]
100049ba:	701a      	strb	r2, [r3, #0]

            traceQUEUE_SET_SEND( pxQueueSetContainer );

            /* The data copied is the handle of the queue that contains data. */
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
100049bc:	693a      	ldr	r2, [r7, #16]
100049be:	1d3b      	adds	r3, r7, #4
100049c0:	1c10      	adds	r0, r2, #0
100049c2:	1c19      	adds	r1, r3, #0
100049c4:	2200      	movs	r2, #0
100049c6:	f7ff fe47 	bl	10004658 <prvCopyDataToQueue>
100049ca:	1c03      	adds	r3, r0, #0
100049cc:	617b      	str	r3, [r7, #20]

            if( cTxLock == queueUNLOCKED )
100049ce:	230f      	movs	r3, #15
100049d0:	18fb      	adds	r3, r7, r3
100049d2:	781b      	ldrb	r3, [r3, #0]
100049d4:	b25b      	sxtb	r3, r3
100049d6:	3301      	adds	r3, #1
100049d8:	d10d      	bne.n	100049f6 <prvNotifyQueueSetContainer+0x7e>
            {
                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
100049da:	693b      	ldr	r3, [r7, #16]
100049dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100049de:	2b00      	cmp	r3, #0
100049e0:	d01b      	beq.n	10004a1a <prvNotifyQueueSetContainer+0xa2>
                {
                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
100049e2:	693b      	ldr	r3, [r7, #16]
100049e4:	3324      	adds	r3, #36	; 0x24
100049e6:	1c18      	adds	r0, r3, #0
100049e8:	f000 fbb2 	bl	10005150 <xTaskRemoveFromEventList>
100049ec:	1e03      	subs	r3, r0, #0
100049ee:	d014      	beq.n	10004a1a <prvNotifyQueueSetContainer+0xa2>
                    {
                        /* The task waiting has a higher priority. */
                        xReturn = pdTRUE;
100049f0:	2301      	movs	r3, #1
100049f2:	617b      	str	r3, [r7, #20]
100049f4:	e011      	b.n	10004a1a <prvNotifyQueueSetContainer+0xa2>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                configASSERT( cTxLock != queueINT8_MAX );
100049f6:	230f      	movs	r3, #15
100049f8:	18fb      	adds	r3, r7, r3
100049fa:	781b      	ldrb	r3, [r3, #0]
100049fc:	b25b      	sxtb	r3, r3
100049fe:	2b7f      	cmp	r3, #127	; 0x7f
10004a00:	d101      	bne.n	10004a06 <prvNotifyQueueSetContainer+0x8e>
10004a02:	b672      	cpsid	i
10004a04:	e7fe      	b.n	10004a04 <prvNotifyQueueSetContainer+0x8c>

                pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
10004a06:	230f      	movs	r3, #15
10004a08:	18fb      	adds	r3, r7, r3
10004a0a:	781b      	ldrb	r3, [r3, #0]
10004a0c:	3301      	adds	r3, #1
10004a0e:	b2db      	uxtb	r3, r3
10004a10:	b2d9      	uxtb	r1, r3
10004a12:	693b      	ldr	r3, [r7, #16]
10004a14:	2245      	movs	r2, #69	; 0x45
10004a16:	5499      	strb	r1, [r3, r2]
10004a18:	e7ff      	b.n	10004a1a <prvNotifyQueueSetContainer+0xa2>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
10004a1a:	697b      	ldr	r3, [r7, #20]
    }
10004a1c:	1c18      	adds	r0, r3, #0
10004a1e:	46bd      	mov	sp, r7
10004a20:	b006      	add	sp, #24
10004a22:	bd80      	pop	{r7, pc}

10004a24 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
10004a24:	b590      	push	{r4, r7, lr}
10004a26:	b08d      	sub	sp, #52	; 0x34
10004a28:	af04      	add	r7, sp, #16
10004a2a:	60f8      	str	r0, [r7, #12]
10004a2c:	60b9      	str	r1, [r7, #8]
10004a2e:	603b      	str	r3, [r7, #0]
10004a30:	1dbb      	adds	r3, r7, #6
10004a32:	801a      	strh	r2, [r3, #0]
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
10004a34:	1dbb      	adds	r3, r7, #6
10004a36:	881b      	ldrh	r3, [r3, #0]
10004a38:	009b      	lsls	r3, r3, #2
10004a3a:	1c18      	adds	r0, r3, #0
10004a3c:	f7ff fa40 	bl	10003ec0 <pvPortMalloc>
10004a40:	1c03      	adds	r3, r0, #0
10004a42:	617b      	str	r3, [r7, #20]

                if( pxStack != NULL )
10004a44:	697b      	ldr	r3, [r7, #20]
10004a46:	2b00      	cmp	r3, #0
10004a48:	d010      	beq.n	10004a6c <xTaskCreate+0x48>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
10004a4a:	2070      	movs	r0, #112	; 0x70
10004a4c:	f7ff fa38 	bl	10003ec0 <pvPortMalloc>
10004a50:	1c03      	adds	r3, r0, #0
10004a52:	61fb      	str	r3, [r7, #28]

                    if( pxNewTCB != NULL )
10004a54:	69fb      	ldr	r3, [r7, #28]
10004a56:	2b00      	cmp	r3, #0
10004a58:	d003      	beq.n	10004a62 <xTaskCreate+0x3e>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
10004a5a:	69fb      	ldr	r3, [r7, #28]
10004a5c:	697a      	ldr	r2, [r7, #20]
10004a5e:	631a      	str	r2, [r3, #48]	; 0x30
10004a60:	e006      	b.n	10004a70 <xTaskCreate+0x4c>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
10004a62:	697b      	ldr	r3, [r7, #20]
10004a64:	1c18      	adds	r0, r3, #0
10004a66:	f7ff fa3f 	bl	10003ee8 <vPortFree>
10004a6a:	e001      	b.n	10004a70 <xTaskCreate+0x4c>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
10004a6c:	2300      	movs	r3, #0
10004a6e:	61fb      	str	r3, [r7, #28]
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
10004a70:	69fb      	ldr	r3, [r7, #28]
10004a72:	2b00      	cmp	r3, #0
10004a74:	d016      	beq.n	10004aa4 <xTaskCreate+0x80>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
10004a76:	1dbb      	adds	r3, r7, #6
10004a78:	881a      	ldrh	r2, [r3, #0]
10004a7a:	68f8      	ldr	r0, [r7, #12]
10004a7c:	68b9      	ldr	r1, [r7, #8]
10004a7e:	683c      	ldr	r4, [r7, #0]
10004a80:	6b3b      	ldr	r3, [r7, #48]	; 0x30
10004a82:	9300      	str	r3, [sp, #0]
10004a84:	6b7b      	ldr	r3, [r7, #52]	; 0x34
10004a86:	9301      	str	r3, [sp, #4]
10004a88:	69fb      	ldr	r3, [r7, #28]
10004a8a:	9302      	str	r3, [sp, #8]
10004a8c:	2300      	movs	r3, #0
10004a8e:	9303      	str	r3, [sp, #12]
10004a90:	1c23      	adds	r3, r4, #0
10004a92:	f000 f80f 	bl	10004ab4 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
10004a96:	69fb      	ldr	r3, [r7, #28]
10004a98:	1c18      	adds	r0, r3, #0
10004a9a:	f000 f8a7 	bl	10004bec <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
10004a9e:	2301      	movs	r3, #1
10004aa0:	61bb      	str	r3, [r7, #24]
10004aa2:	e002      	b.n	10004aaa <xTaskCreate+0x86>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
10004aa4:	2301      	movs	r3, #1
10004aa6:	425b      	negs	r3, r3
10004aa8:	61bb      	str	r3, [r7, #24]
        }

        return xReturn;
10004aaa:	69bb      	ldr	r3, [r7, #24]
    }
10004aac:	1c18      	adds	r0, r3, #0
10004aae:	46bd      	mov	sp, r7
10004ab0:	b009      	add	sp, #36	; 0x24
10004ab2:	bd90      	pop	{r4, r7, pc}

10004ab4 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
10004ab4:	b580      	push	{r7, lr}
10004ab6:	b086      	sub	sp, #24
10004ab8:	af00      	add	r7, sp, #0
10004aba:	60f8      	str	r0, [r7, #12]
10004abc:	60b9      	str	r1, [r7, #8]
10004abe:	607a      	str	r2, [r7, #4]
10004ac0:	603b      	str	r3, [r7, #0]

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
10004ac2:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004ac4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
10004ac6:	687b      	ldr	r3, [r7, #4]
10004ac8:	009b      	lsls	r3, r3, #2
10004aca:	1c10      	adds	r0, r2, #0
10004acc:	21a5      	movs	r1, #165	; 0xa5
10004ace:	1c1a      	adds	r2, r3, #0
10004ad0:	f001 fd33 	bl	1000653a <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
10004ad4:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004ad6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
10004ad8:	687b      	ldr	r3, [r7, #4]
10004ada:	4943      	ldr	r1, [pc, #268]	; (10004be8 <prvInitialiseNewTask+0x134>)
10004adc:	468c      	mov	ip, r1
10004ade:	4463      	add	r3, ip
10004ae0:	009b      	lsls	r3, r3, #2
10004ae2:	18d3      	adds	r3, r2, r3
10004ae4:	613b      	str	r3, [r7, #16]
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
10004ae6:	693b      	ldr	r3, [r7, #16]
10004ae8:	2207      	movs	r2, #7
10004aea:	4393      	bics	r3, r2
10004aec:	613b      	str	r3, [r7, #16]

            /* Check the alignment of the calculated top of stack is correct. */
            configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
10004aee:	693b      	ldr	r3, [r7, #16]
10004af0:	2207      	movs	r2, #7
10004af2:	4013      	ands	r3, r2
10004af4:	d001      	beq.n	10004afa <prvInitialiseNewTask+0x46>
10004af6:	b672      	cpsid	i
10004af8:	e7fe      	b.n	10004af8 <prvInitialiseNewTask+0x44>
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
10004afa:	68bb      	ldr	r3, [r7, #8]
10004afc:	2b00      	cmp	r3, #0
10004afe:	d01f      	beq.n	10004b40 <prvInitialiseNewTask+0x8c>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
10004b00:	2300      	movs	r3, #0
10004b02:	617b      	str	r3, [r7, #20]
10004b04:	e014      	b.n	10004b30 <prvInitialiseNewTask+0x7c>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
10004b06:	68ba      	ldr	r2, [r7, #8]
10004b08:	697b      	ldr	r3, [r7, #20]
10004b0a:	18d3      	adds	r3, r2, r3
10004b0c:	7818      	ldrb	r0, [r3, #0]
10004b0e:	6aba      	ldr	r2, [r7, #40]	; 0x28
10004b10:	2130      	movs	r1, #48	; 0x30
10004b12:	697b      	ldr	r3, [r7, #20]
10004b14:	18d3      	adds	r3, r2, r3
10004b16:	185b      	adds	r3, r3, r1
10004b18:	1c02      	adds	r2, r0, #0
10004b1a:	711a      	strb	r2, [r3, #4]

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
10004b1c:	68ba      	ldr	r2, [r7, #8]
10004b1e:	697b      	ldr	r3, [r7, #20]
10004b20:	18d3      	adds	r3, r2, r3
10004b22:	781b      	ldrb	r3, [r3, #0]
10004b24:	2b00      	cmp	r3, #0
10004b26:	d100      	bne.n	10004b2a <prvInitialiseNewTask+0x76>
            {
                break;
10004b28:	e005      	b.n	10004b36 <prvInitialiseNewTask+0x82>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
10004b2a:	697b      	ldr	r3, [r7, #20]
10004b2c:	3301      	adds	r3, #1
10004b2e:	617b      	str	r3, [r7, #20]
10004b30:	697b      	ldr	r3, [r7, #20]
10004b32:	2b0f      	cmp	r3, #15
10004b34:	d9e7      	bls.n	10004b06 <prvInitialiseNewTask+0x52>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
10004b36:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b38:	2243      	movs	r2, #67	; 0x43
10004b3a:	2100      	movs	r1, #0
10004b3c:	5499      	strb	r1, [r3, r2]
10004b3e:	e003      	b.n	10004b48 <prvInitialiseNewTask+0x94>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
10004b40:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b42:	2234      	movs	r2, #52	; 0x34
10004b44:	2100      	movs	r1, #0
10004b46:	5499      	strb	r1, [r3, r2]
    }

    /* This is used as an array index so must ensure it's not too large.  First
     * remove the privilege bit if one is present. */
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
10004b48:	6a3b      	ldr	r3, [r7, #32]
10004b4a:	2b04      	cmp	r3, #4
10004b4c:	d901      	bls.n	10004b52 <prvInitialiseNewTask+0x9e>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
10004b4e:	2304      	movs	r3, #4
10004b50:	623b      	str	r3, [r7, #32]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
10004b52:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b54:	6a3a      	ldr	r2, [r7, #32]
10004b56:	62da      	str	r2, [r3, #44]	; 0x2c
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
10004b58:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b5a:	6a3a      	ldr	r2, [r7, #32]
10004b5c:	64da      	str	r2, [r3, #76]	; 0x4c
            pxNewTCB->uxMutexesHeld = 0;
10004b5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b60:	2200      	movs	r2, #0
10004b62:	651a      	str	r2, [r3, #80]	; 0x50
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
10004b64:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b66:	3304      	adds	r3, #4
10004b68:	1c18      	adds	r0, r3, #0
10004b6a:	f7ff f9ed 	bl	10003f48 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
10004b6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b70:	3318      	adds	r3, #24
10004b72:	1c18      	adds	r0, r3, #0
10004b74:	f7ff f9e8 	bl	10003f48 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
10004b78:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b7a:	6aba      	ldr	r2, [r7, #40]	; 0x28
10004b7c:	611a      	str	r2, [r3, #16]

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10004b7e:	6a3b      	ldr	r3, [r7, #32]
10004b80:	2205      	movs	r2, #5
10004b82:	1ad2      	subs	r2, r2, r3
10004b84:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b86:	619a      	str	r2, [r3, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
10004b88:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b8a:	6aba      	ldr	r2, [r7, #40]	; 0x28
10004b8c:	625a      	str	r2, [r3, #36]	; 0x24
        }
    #endif

    #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
        {
            memset( ( void * ) &( pxNewTCB->pvThreadLocalStoragePointers[ 0 ] ), 0x00, sizeof( pxNewTCB->pvThreadLocalStoragePointers ) );
10004b8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b90:	3354      	adds	r3, #84	; 0x54
10004b92:	1c18      	adds	r0, r3, #0
10004b94:	2100      	movs	r1, #0
10004b96:	2214      	movs	r2, #20
10004b98:	f001 fccf 	bl	1000653a <memset>
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
10004b9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004b9e:	3368      	adds	r3, #104	; 0x68
10004ba0:	1c18      	adds	r0, r3, #0
10004ba2:	2100      	movs	r1, #0
10004ba4:	2204      	movs	r2, #4
10004ba6:	f001 fcc8 	bl	1000653a <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
10004baa:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004bac:	336c      	adds	r3, #108	; 0x6c
10004bae:	1c18      	adds	r0, r3, #0
10004bb0:	2100      	movs	r1, #0
10004bb2:	2201      	movs	r2, #1
10004bb4:	f001 fcc1 	bl	1000653a <memset>
        }
    #endif

    #if ( INCLUDE_xTaskAbortDelay == 1 )
        {
            pxNewTCB->ucDelayAborted = pdFALSE;
10004bb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004bba:	226d      	movs	r2, #109	; 0x6d
10004bbc:	2100      	movs	r1, #0
10004bbe:	5499      	strb	r1, [r3, r2]
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
10004bc0:	6939      	ldr	r1, [r7, #16]
10004bc2:	68fa      	ldr	r2, [r7, #12]
10004bc4:	683b      	ldr	r3, [r7, #0]
10004bc6:	1c08      	adds	r0, r1, #0
10004bc8:	1c11      	adds	r1, r2, #0
10004bca:	1c1a      	adds	r2, r3, #0
10004bcc:	f7ff f84c 	bl	10003c68 <pxPortInitialiseStack>
10004bd0:	1c02      	adds	r2, r0, #0
10004bd2:	6abb      	ldr	r3, [r7, #40]	; 0x28
10004bd4:	601a      	str	r2, [r3, #0]
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
10004bd6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10004bd8:	2b00      	cmp	r3, #0
10004bda:	d002      	beq.n	10004be2 <prvInitialiseNewTask+0x12e>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
10004bdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10004bde:	6aba      	ldr	r2, [r7, #40]	; 0x28
10004be0:	601a      	str	r2, [r3, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
10004be2:	46bd      	mov	sp, r7
10004be4:	b006      	add	sp, #24
10004be6:	bd80      	pop	{r7, pc}
10004be8:	3fffffff 	.word	0x3fffffff

10004bec <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
10004bec:	b580      	push	{r7, lr}
10004bee:	b082      	sub	sp, #8
10004bf0:	af00      	add	r7, sp, #0
10004bf2:	6078      	str	r0, [r7, #4]
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
10004bf4:	f7ff f8ce 	bl	10003d94 <vPortEnterCritical>
    {
        uxCurrentNumberOfTasks++;
10004bf8:	4b29      	ldr	r3, [pc, #164]	; (10004ca0 <prvAddNewTaskToReadyList+0xb4>)
10004bfa:	681b      	ldr	r3, [r3, #0]
10004bfc:	1c5a      	adds	r2, r3, #1
10004bfe:	4b28      	ldr	r3, [pc, #160]	; (10004ca0 <prvAddNewTaskToReadyList+0xb4>)
10004c00:	601a      	str	r2, [r3, #0]

        if( pxCurrentTCB == NULL )
10004c02:	4b28      	ldr	r3, [pc, #160]	; (10004ca4 <prvAddNewTaskToReadyList+0xb8>)
10004c04:	681b      	ldr	r3, [r3, #0]
10004c06:	2b00      	cmp	r3, #0
10004c08:	d109      	bne.n	10004c1e <prvAddNewTaskToReadyList+0x32>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
10004c0a:	4b26      	ldr	r3, [pc, #152]	; (10004ca4 <prvAddNewTaskToReadyList+0xb8>)
10004c0c:	687a      	ldr	r2, [r7, #4]
10004c0e:	601a      	str	r2, [r3, #0]

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
10004c10:	4b23      	ldr	r3, [pc, #140]	; (10004ca0 <prvAddNewTaskToReadyList+0xb4>)
10004c12:	681b      	ldr	r3, [r3, #0]
10004c14:	2b01      	cmp	r3, #1
10004c16:	d110      	bne.n	10004c3a <prvAddNewTaskToReadyList+0x4e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
10004c18:	f000 fb88 	bl	1000532c <prvInitialiseTaskLists>
10004c1c:	e00d      	b.n	10004c3a <prvAddNewTaskToReadyList+0x4e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
10004c1e:	4b22      	ldr	r3, [pc, #136]	; (10004ca8 <prvAddNewTaskToReadyList+0xbc>)
10004c20:	681b      	ldr	r3, [r3, #0]
10004c22:	2b00      	cmp	r3, #0
10004c24:	d109      	bne.n	10004c3a <prvAddNewTaskToReadyList+0x4e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
10004c26:	4b1f      	ldr	r3, [pc, #124]	; (10004ca4 <prvAddNewTaskToReadyList+0xb8>)
10004c28:	681b      	ldr	r3, [r3, #0]
10004c2a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004c2c:	687b      	ldr	r3, [r7, #4]
10004c2e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10004c30:	429a      	cmp	r2, r3
10004c32:	d802      	bhi.n	10004c3a <prvAddNewTaskToReadyList+0x4e>
                {
                    pxCurrentTCB = pxNewTCB;
10004c34:	4b1b      	ldr	r3, [pc, #108]	; (10004ca4 <prvAddNewTaskToReadyList+0xb8>)
10004c36:	687a      	ldr	r2, [r7, #4]
10004c38:	601a      	str	r2, [r3, #0]
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
10004c3a:	4b1c      	ldr	r3, [pc, #112]	; (10004cac <prvAddNewTaskToReadyList+0xc0>)
10004c3c:	681b      	ldr	r3, [r3, #0]
10004c3e:	1c5a      	adds	r2, r3, #1
10004c40:	4b1a      	ldr	r3, [pc, #104]	; (10004cac <prvAddNewTaskToReadyList+0xc0>)
10004c42:	601a      	str	r2, [r3, #0]

        #if ( configUSE_TRACE_FACILITY == 1 )
            {
                /* Add a counter into the TCB for tracing only. */
                pxNewTCB->uxTCBNumber = uxTaskNumber;
10004c44:	4b19      	ldr	r3, [pc, #100]	; (10004cac <prvAddNewTaskToReadyList+0xc0>)
10004c46:	681a      	ldr	r2, [r3, #0]
10004c48:	687b      	ldr	r3, [r7, #4]
10004c4a:	645a      	str	r2, [r3, #68]	; 0x44
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
10004c4c:	687b      	ldr	r3, [r7, #4]
10004c4e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004c50:	4b17      	ldr	r3, [pc, #92]	; (10004cb0 <prvAddNewTaskToReadyList+0xc4>)
10004c52:	681b      	ldr	r3, [r3, #0]
10004c54:	429a      	cmp	r2, r3
10004c56:	d903      	bls.n	10004c60 <prvAddNewTaskToReadyList+0x74>
10004c58:	687b      	ldr	r3, [r7, #4]
10004c5a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004c5c:	4b14      	ldr	r3, [pc, #80]	; (10004cb0 <prvAddNewTaskToReadyList+0xc4>)
10004c5e:	601a      	str	r2, [r3, #0]
10004c60:	687b      	ldr	r3, [r7, #4]
10004c62:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004c64:	1c13      	adds	r3, r2, #0
10004c66:	009b      	lsls	r3, r3, #2
10004c68:	189b      	adds	r3, r3, r2
10004c6a:	009b      	lsls	r3, r3, #2
10004c6c:	4a11      	ldr	r2, [pc, #68]	; (10004cb4 <prvAddNewTaskToReadyList+0xc8>)
10004c6e:	189a      	adds	r2, r3, r2
10004c70:	687b      	ldr	r3, [r7, #4]
10004c72:	3304      	adds	r3, #4
10004c74:	1c10      	adds	r0, r2, #0
10004c76:	1c19      	adds	r1, r3, #0
10004c78:	f7ff f970 	bl	10003f5c <vListInsertEnd>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
10004c7c:	f7ff f89a 	bl	10003db4 <vPortExitCritical>

    if( xSchedulerRunning != pdFALSE )
10004c80:	4b09      	ldr	r3, [pc, #36]	; (10004ca8 <prvAddNewTaskToReadyList+0xbc>)
10004c82:	681b      	ldr	r3, [r3, #0]
10004c84:	2b00      	cmp	r3, #0
10004c86:	d008      	beq.n	10004c9a <prvAddNewTaskToReadyList+0xae>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
10004c88:	4b06      	ldr	r3, [pc, #24]	; (10004ca4 <prvAddNewTaskToReadyList+0xb8>)
10004c8a:	681b      	ldr	r3, [r3, #0]
10004c8c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004c8e:	687b      	ldr	r3, [r7, #4]
10004c90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10004c92:	429a      	cmp	r2, r3
10004c94:	d201      	bcs.n	10004c9a <prvAddNewTaskToReadyList+0xae>
        {
            taskYIELD_IF_USING_PREEMPTION();
10004c96:	f7ff f86f 	bl	10003d78 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
10004c9a:	46bd      	mov	sp, r7
10004c9c:	b002      	add	sp, #8
10004c9e:	bd80      	pop	{r7, pc}
10004ca0:	20000754 	.word	0x20000754
10004ca4:	2000067c 	.word	0x2000067c
10004ca8:	20000760 	.word	0x20000760
10004cac:	20000770 	.word	0x20000770
10004cb0:	2000075c 	.word	0x2000075c
10004cb4:	20000680 	.word	0x20000680

10004cb8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
10004cb8:	b580      	push	{r7, lr}
10004cba:	b084      	sub	sp, #16
10004cbc:	af00      	add	r7, sp, #0
10004cbe:	6078      	str	r0, [r7, #4]
        BaseType_t xAlreadyYielded = pdFALSE;
10004cc0:	2300      	movs	r3, #0
10004cc2:	60fb      	str	r3, [r7, #12]

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
10004cc4:	687b      	ldr	r3, [r7, #4]
10004cc6:	2b00      	cmp	r3, #0
10004cc8:	d010      	beq.n	10004cec <vTaskDelay+0x34>
        {
            configASSERT( uxSchedulerSuspended == 0 );
10004cca:	4b0c      	ldr	r3, [pc, #48]	; (10004cfc <vTaskDelay+0x44>)
10004ccc:	681b      	ldr	r3, [r3, #0]
10004cce:	2b00      	cmp	r3, #0
10004cd0:	d001      	beq.n	10004cd6 <vTaskDelay+0x1e>
10004cd2:	b672      	cpsid	i
10004cd4:	e7fe      	b.n	10004cd4 <vTaskDelay+0x1c>
            vTaskSuspendAll();
10004cd6:	f000 f855 	bl	10004d84 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
10004cda:	687b      	ldr	r3, [r7, #4]
10004cdc:	1c18      	adds	r0, r3, #0
10004cde:	2100      	movs	r1, #0
10004ce0:	f000 fc34 	bl	1000554c <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
10004ce4:	f000 f85a 	bl	10004d9c <xTaskResumeAll>
10004ce8:	1c03      	adds	r3, r0, #0
10004cea:	60fb      	str	r3, [r7, #12]
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
10004cec:	68fb      	ldr	r3, [r7, #12]
10004cee:	2b00      	cmp	r3, #0
10004cf0:	d101      	bne.n	10004cf6 <vTaskDelay+0x3e>
        {
            portYIELD_WITHIN_API();
10004cf2:	f7ff f841 	bl	10003d78 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
10004cf6:	46bd      	mov	sp, r7
10004cf8:	b004      	add	sp, #16
10004cfa:	bd80      	pop	{r7, pc}
10004cfc:	2000077c 	.word	0x2000077c

10004d00 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
10004d00:	b580      	push	{r7, lr}
10004d02:	b084      	sub	sp, #16
10004d04:	af02      	add	r7, sp, #8
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
10004d06:	4918      	ldr	r1, [pc, #96]	; (10004d68 <vTaskStartScheduler+0x68>)
10004d08:	4a18      	ldr	r2, [pc, #96]	; (10004d6c <vTaskStartScheduler+0x6c>)
10004d0a:	2300      	movs	r3, #0
10004d0c:	9300      	str	r3, [sp, #0]
10004d0e:	4b18      	ldr	r3, [pc, #96]	; (10004d70 <vTaskStartScheduler+0x70>)
10004d10:	9301      	str	r3, [sp, #4]
10004d12:	1c08      	adds	r0, r1, #0
10004d14:	1c11      	adds	r1, r2, #0
10004d16:	223c      	movs	r2, #60	; 0x3c
10004d18:	2300      	movs	r3, #0
10004d1a:	f7ff fe83 	bl	10004a24 <xTaskCreate>
10004d1e:	1c03      	adds	r3, r0, #0
10004d20:	607b      	str	r3, [r7, #4]
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
10004d22:	687b      	ldr	r3, [r7, #4]
10004d24:	2b01      	cmp	r3, #1
10004d26:	d103      	bne.n	10004d30 <vTaskStartScheduler+0x30>
            {
                xReturn = xTimerCreateTimerTask();
10004d28:	f000 fc68 	bl	100055fc <xTimerCreateTimerTask>
10004d2c:	1c03      	adds	r3, r0, #0
10004d2e:	607b      	str	r3, [r7, #4]
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
10004d30:	687b      	ldr	r3, [r7, #4]
10004d32:	2b01      	cmp	r3, #1
10004d34:	d10d      	bne.n	10004d52 <vTaskStartScheduler+0x52>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
10004d36:	b672      	cpsid	i
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
10004d38:	4b0e      	ldr	r3, [pc, #56]	; (10004d74 <vTaskStartScheduler+0x74>)
10004d3a:	2201      	movs	r2, #1
10004d3c:	4252      	negs	r2, r2
10004d3e:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
10004d40:	4b0d      	ldr	r3, [pc, #52]	; (10004d78 <vTaskStartScheduler+0x78>)
10004d42:	2201      	movs	r2, #1
10004d44:	601a      	str	r2, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
10004d46:	4b0d      	ldr	r3, [pc, #52]	; (10004d7c <vTaskStartScheduler+0x7c>)
10004d48:	2200      	movs	r2, #0
10004d4a:	601a      	str	r2, [r3, #0]

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
10004d4c:	f7fe fff0 	bl	10003d30 <xPortStartScheduler>
10004d50:	e004      	b.n	10004d5c <vTaskStartScheduler+0x5c>
    else
    {
        /* This line will only be reached if the kernel could not be started,
         * because there was not enough FreeRTOS heap to create the idle task
         * or the timer task. */
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
10004d52:	687b      	ldr	r3, [r7, #4]
10004d54:	3301      	adds	r3, #1
10004d56:	d101      	bne.n	10004d5c <vTaskStartScheduler+0x5c>
10004d58:	b672      	cpsid	i
10004d5a:	e7fe      	b.n	10004d5a <vTaskStartScheduler+0x5a>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
10004d5c:	4b08      	ldr	r3, [pc, #32]	; (10004d80 <vTaskStartScheduler+0x80>)
10004d5e:	681b      	ldr	r3, [r3, #0]
}
10004d60:	46bd      	mov	sp, r7
10004d62:	b002      	add	sp, #8
10004d64:	bd80      	pop	{r7, pc}
10004d66:	46c0      	nop			; (mov r8, r8)
10004d68:	1000530d 	.word	0x1000530d
10004d6c:	100067d0 	.word	0x100067d0
10004d70:	20000778 	.word	0x20000778
10004d74:	20000774 	.word	0x20000774
10004d78:	20000760 	.word	0x20000760
10004d7c:	20000758 	.word	0x20000758
10004d80:	200005b8 	.word	0x200005b8

10004d84 <vTaskSuspendAll>:
    vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
10004d84:	b580      	push	{r7, lr}
10004d86:	af00      	add	r7, sp, #0
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
10004d88:	4b03      	ldr	r3, [pc, #12]	; (10004d98 <vTaskSuspendAll+0x14>)
10004d8a:	681b      	ldr	r3, [r3, #0]
10004d8c:	1c5a      	adds	r2, r3, #1
10004d8e:	4b02      	ldr	r3, [pc, #8]	; (10004d98 <vTaskSuspendAll+0x14>)
10004d90:	601a      	str	r2, [r3, #0]

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
10004d92:	46bd      	mov	sp, r7
10004d94:	bd80      	pop	{r7, pc}
10004d96:	46c0      	nop			; (mov r8, r8)
10004d98:	2000077c 	.word	0x2000077c

10004d9c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
10004d9c:	b580      	push	{r7, lr}
10004d9e:	b084      	sub	sp, #16
10004da0:	af00      	add	r7, sp, #0
    TCB_t * pxTCB = NULL;
10004da2:	2300      	movs	r3, #0
10004da4:	60fb      	str	r3, [r7, #12]
    BaseType_t xAlreadyYielded = pdFALSE;
10004da6:	2300      	movs	r3, #0
10004da8:	60bb      	str	r3, [r7, #8]

    /* If uxSchedulerSuspended is zero then this function does not match a
     * previous call to vTaskSuspendAll(). */
    configASSERT( uxSchedulerSuspended );
10004daa:	4b3a      	ldr	r3, [pc, #232]	; (10004e94 <xTaskResumeAll+0xf8>)
10004dac:	681b      	ldr	r3, [r3, #0]
10004dae:	2b00      	cmp	r3, #0
10004db0:	d101      	bne.n	10004db6 <xTaskResumeAll+0x1a>
10004db2:	b672      	cpsid	i
10004db4:	e7fe      	b.n	10004db4 <xTaskResumeAll+0x18>
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
10004db6:	f7fe ffed 	bl	10003d94 <vPortEnterCritical>
    {
        --uxSchedulerSuspended;
10004dba:	4b36      	ldr	r3, [pc, #216]	; (10004e94 <xTaskResumeAll+0xf8>)
10004dbc:	681b      	ldr	r3, [r3, #0]
10004dbe:	1e5a      	subs	r2, r3, #1
10004dc0:	4b34      	ldr	r3, [pc, #208]	; (10004e94 <xTaskResumeAll+0xf8>)
10004dc2:	601a      	str	r2, [r3, #0]

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10004dc4:	4b33      	ldr	r3, [pc, #204]	; (10004e94 <xTaskResumeAll+0xf8>)
10004dc6:	681b      	ldr	r3, [r3, #0]
10004dc8:	2b00      	cmp	r3, #0
10004dca:	d15b      	bne.n	10004e84 <xTaskResumeAll+0xe8>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
10004dcc:	4b32      	ldr	r3, [pc, #200]	; (10004e98 <xTaskResumeAll+0xfc>)
10004dce:	681b      	ldr	r3, [r3, #0]
10004dd0:	2b00      	cmp	r3, #0
10004dd2:	d057      	beq.n	10004e84 <xTaskResumeAll+0xe8>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
10004dd4:	e02f      	b.n	10004e36 <xTaskResumeAll+0x9a>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10004dd6:	4b31      	ldr	r3, [pc, #196]	; (10004e9c <xTaskResumeAll+0x100>)
10004dd8:	68db      	ldr	r3, [r3, #12]
10004dda:	68db      	ldr	r3, [r3, #12]
10004ddc:	60fb      	str	r3, [r7, #12]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
10004dde:	68fb      	ldr	r3, [r7, #12]
10004de0:	3318      	adds	r3, #24
10004de2:	1c18      	adds	r0, r3, #0
10004de4:	f7ff f912 	bl	1000400c <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
10004de8:	68fb      	ldr	r3, [r7, #12]
10004dea:	3304      	adds	r3, #4
10004dec:	1c18      	adds	r0, r3, #0
10004dee:	f7ff f90d 	bl	1000400c <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
10004df2:	68fb      	ldr	r3, [r7, #12]
10004df4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004df6:	4b2a      	ldr	r3, [pc, #168]	; (10004ea0 <xTaskResumeAll+0x104>)
10004df8:	681b      	ldr	r3, [r3, #0]
10004dfa:	429a      	cmp	r2, r3
10004dfc:	d903      	bls.n	10004e06 <xTaskResumeAll+0x6a>
10004dfe:	68fb      	ldr	r3, [r7, #12]
10004e00:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004e02:	4b27      	ldr	r3, [pc, #156]	; (10004ea0 <xTaskResumeAll+0x104>)
10004e04:	601a      	str	r2, [r3, #0]
10004e06:	68fb      	ldr	r3, [r7, #12]
10004e08:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004e0a:	1c13      	adds	r3, r2, #0
10004e0c:	009b      	lsls	r3, r3, #2
10004e0e:	189b      	adds	r3, r3, r2
10004e10:	009b      	lsls	r3, r3, #2
10004e12:	4a24      	ldr	r2, [pc, #144]	; (10004ea4 <xTaskResumeAll+0x108>)
10004e14:	189a      	adds	r2, r3, r2
10004e16:	68fb      	ldr	r3, [r7, #12]
10004e18:	3304      	adds	r3, #4
10004e1a:	1c10      	adds	r0, r2, #0
10004e1c:	1c19      	adds	r1, r3, #0
10004e1e:	f7ff f89d 	bl	10003f5c <vListInsertEnd>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
10004e22:	68fb      	ldr	r3, [r7, #12]
10004e24:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004e26:	4b20      	ldr	r3, [pc, #128]	; (10004ea8 <xTaskResumeAll+0x10c>)
10004e28:	681b      	ldr	r3, [r3, #0]
10004e2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10004e2c:	429a      	cmp	r2, r3
10004e2e:	d302      	bcc.n	10004e36 <xTaskResumeAll+0x9a>
                    {
                        xYieldPending = pdTRUE;
10004e30:	4b1e      	ldr	r3, [pc, #120]	; (10004eac <xTaskResumeAll+0x110>)
10004e32:	2201      	movs	r2, #1
10004e34:	601a      	str	r2, [r3, #0]
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
10004e36:	4b19      	ldr	r3, [pc, #100]	; (10004e9c <xTaskResumeAll+0x100>)
10004e38:	681b      	ldr	r3, [r3, #0]
10004e3a:	2b00      	cmp	r3, #0
10004e3c:	d1cb      	bne.n	10004dd6 <xTaskResumeAll+0x3a>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
10004e3e:	68fb      	ldr	r3, [r7, #12]
10004e40:	2b00      	cmp	r3, #0
10004e42:	d001      	beq.n	10004e48 <xTaskResumeAll+0xac>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
10004e44:	f000 faf2 	bl	1000542c <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
10004e48:	4b19      	ldr	r3, [pc, #100]	; (10004eb0 <xTaskResumeAll+0x114>)
10004e4a:	681b      	ldr	r3, [r3, #0]
10004e4c:	607b      	str	r3, [r7, #4]

                    if( xPendedCounts > ( TickType_t ) 0U )
10004e4e:	687b      	ldr	r3, [r7, #4]
10004e50:	2b00      	cmp	r3, #0
10004e52:	d00f      	beq.n	10004e74 <xTaskResumeAll+0xd8>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
10004e54:	f000 f83c 	bl	10004ed0 <xTaskIncrementTick>
10004e58:	1e03      	subs	r3, r0, #0
10004e5a:	d002      	beq.n	10004e62 <xTaskResumeAll+0xc6>
                            {
                                xYieldPending = pdTRUE;
10004e5c:	4b13      	ldr	r3, [pc, #76]	; (10004eac <xTaskResumeAll+0x110>)
10004e5e:	2201      	movs	r2, #1
10004e60:	601a      	str	r2, [r3, #0]
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
10004e62:	687b      	ldr	r3, [r7, #4]
10004e64:	3b01      	subs	r3, #1
10004e66:	607b      	str	r3, [r7, #4]
                        } while( xPendedCounts > ( TickType_t ) 0U );
10004e68:	687b      	ldr	r3, [r7, #4]
10004e6a:	2b00      	cmp	r3, #0
10004e6c:	d1f2      	bne.n	10004e54 <xTaskResumeAll+0xb8>

                        xPendedTicks = 0;
10004e6e:	4b10      	ldr	r3, [pc, #64]	; (10004eb0 <xTaskResumeAll+0x114>)
10004e70:	2200      	movs	r2, #0
10004e72:	601a      	str	r2, [r3, #0]
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
10004e74:	4b0d      	ldr	r3, [pc, #52]	; (10004eac <xTaskResumeAll+0x110>)
10004e76:	681b      	ldr	r3, [r3, #0]
10004e78:	2b00      	cmp	r3, #0
10004e7a:	d003      	beq.n	10004e84 <xTaskResumeAll+0xe8>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
10004e7c:	2301      	movs	r3, #1
10004e7e:	60bb      	str	r3, [r7, #8]
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
10004e80:	f7fe ff7a 	bl	10003d78 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
10004e84:	f7fe ff96 	bl	10003db4 <vPortExitCritical>

    return xAlreadyYielded;
10004e88:	68bb      	ldr	r3, [r7, #8]
}
10004e8a:	1c18      	adds	r0, r3, #0
10004e8c:	46bd      	mov	sp, r7
10004e8e:	b004      	add	sp, #16
10004e90:	bd80      	pop	{r7, pc}
10004e92:	46c0      	nop			; (mov r8, r8)
10004e94:	2000077c 	.word	0x2000077c
10004e98:	20000754 	.word	0x20000754
10004e9c:	20000714 	.word	0x20000714
10004ea0:	2000075c 	.word	0x2000075c
10004ea4:	20000680 	.word	0x20000680
10004ea8:	2000067c 	.word	0x2000067c
10004eac:	20000768 	.word	0x20000768
10004eb0:	20000764 	.word	0x20000764

10004eb4 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
10004eb4:	b580      	push	{r7, lr}
10004eb6:	b082      	sub	sp, #8
10004eb8:	af00      	add	r7, sp, #0
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
10004eba:	4b04      	ldr	r3, [pc, #16]	; (10004ecc <xTaskGetTickCount+0x18>)
10004ebc:	681b      	ldr	r3, [r3, #0]
10004ebe:	607b      	str	r3, [r7, #4]
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
10004ec0:	687b      	ldr	r3, [r7, #4]
}
10004ec2:	1c18      	adds	r0, r3, #0
10004ec4:	46bd      	mov	sp, r7
10004ec6:	b002      	add	sp, #8
10004ec8:	bd80      	pop	{r7, pc}
10004eca:	46c0      	nop			; (mov r8, r8)
10004ecc:	20000758 	.word	0x20000758

10004ed0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
10004ed0:	b580      	push	{r7, lr}
10004ed2:	b086      	sub	sp, #24
10004ed4:	af00      	add	r7, sp, #0
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
10004ed6:	2300      	movs	r3, #0
10004ed8:	617b      	str	r3, [r7, #20]
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10004eda:	4b4a      	ldr	r3, [pc, #296]	; (10005004 <xTaskIncrementTick+0x134>)
10004edc:	681b      	ldr	r3, [r3, #0]
10004ede:	2b00      	cmp	r3, #0
10004ee0:	d000      	beq.n	10004ee4 <xTaskIncrementTick+0x14>
10004ee2:	e084      	b.n	10004fee <xTaskIncrementTick+0x11e>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
10004ee4:	4b48      	ldr	r3, [pc, #288]	; (10005008 <xTaskIncrementTick+0x138>)
10004ee6:	681b      	ldr	r3, [r3, #0]
10004ee8:	3301      	adds	r3, #1
10004eea:	613b      	str	r3, [r7, #16]

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
10004eec:	4b46      	ldr	r3, [pc, #280]	; (10005008 <xTaskIncrementTick+0x138>)
10004eee:	693a      	ldr	r2, [r7, #16]
10004ef0:	601a      	str	r2, [r3, #0]

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
10004ef2:	693b      	ldr	r3, [r7, #16]
10004ef4:	2b00      	cmp	r3, #0
10004ef6:	d117      	bne.n	10004f28 <xTaskIncrementTick+0x58>
        {
            taskSWITCH_DELAYED_LISTS();
10004ef8:	4b44      	ldr	r3, [pc, #272]	; (1000500c <xTaskIncrementTick+0x13c>)
10004efa:	681b      	ldr	r3, [r3, #0]
10004efc:	681b      	ldr	r3, [r3, #0]
10004efe:	2b00      	cmp	r3, #0
10004f00:	d001      	beq.n	10004f06 <xTaskIncrementTick+0x36>
10004f02:	b672      	cpsid	i
10004f04:	e7fe      	b.n	10004f04 <xTaskIncrementTick+0x34>
10004f06:	4b41      	ldr	r3, [pc, #260]	; (1000500c <xTaskIncrementTick+0x13c>)
10004f08:	681b      	ldr	r3, [r3, #0]
10004f0a:	60fb      	str	r3, [r7, #12]
10004f0c:	4b40      	ldr	r3, [pc, #256]	; (10005010 <xTaskIncrementTick+0x140>)
10004f0e:	681a      	ldr	r2, [r3, #0]
10004f10:	4b3e      	ldr	r3, [pc, #248]	; (1000500c <xTaskIncrementTick+0x13c>)
10004f12:	601a      	str	r2, [r3, #0]
10004f14:	4b3e      	ldr	r3, [pc, #248]	; (10005010 <xTaskIncrementTick+0x140>)
10004f16:	68fa      	ldr	r2, [r7, #12]
10004f18:	601a      	str	r2, [r3, #0]
10004f1a:	4b3e      	ldr	r3, [pc, #248]	; (10005014 <xTaskIncrementTick+0x144>)
10004f1c:	681b      	ldr	r3, [r3, #0]
10004f1e:	1c5a      	adds	r2, r3, #1
10004f20:	4b3c      	ldr	r3, [pc, #240]	; (10005014 <xTaskIncrementTick+0x144>)
10004f22:	601a      	str	r2, [r3, #0]
10004f24:	f000 fa82 	bl	1000542c <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
10004f28:	4b3b      	ldr	r3, [pc, #236]	; (10005018 <xTaskIncrementTick+0x148>)
10004f2a:	681b      	ldr	r3, [r3, #0]
10004f2c:	693a      	ldr	r2, [r7, #16]
10004f2e:	429a      	cmp	r2, r3
10004f30:	d349      	bcc.n	10004fc6 <xTaskIncrementTick+0xf6>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
10004f32:	4b36      	ldr	r3, [pc, #216]	; (1000500c <xTaskIncrementTick+0x13c>)
10004f34:	681b      	ldr	r3, [r3, #0]
10004f36:	681b      	ldr	r3, [r3, #0]
10004f38:	2b00      	cmp	r3, #0
10004f3a:	d104      	bne.n	10004f46 <xTaskIncrementTick+0x76>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10004f3c:	4b36      	ldr	r3, [pc, #216]	; (10005018 <xTaskIncrementTick+0x148>)
10004f3e:	2201      	movs	r2, #1
10004f40:	4252      	negs	r2, r2
10004f42:	601a      	str	r2, [r3, #0]
                    break;
10004f44:	e03f      	b.n	10004fc6 <xTaskIncrementTick+0xf6>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10004f46:	4b31      	ldr	r3, [pc, #196]	; (1000500c <xTaskIncrementTick+0x13c>)
10004f48:	681b      	ldr	r3, [r3, #0]
10004f4a:	68db      	ldr	r3, [r3, #12]
10004f4c:	68db      	ldr	r3, [r3, #12]
10004f4e:	60bb      	str	r3, [r7, #8]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
10004f50:	68bb      	ldr	r3, [r7, #8]
10004f52:	685b      	ldr	r3, [r3, #4]
10004f54:	607b      	str	r3, [r7, #4]

                    if( xConstTickCount < xItemValue )
10004f56:	693a      	ldr	r2, [r7, #16]
10004f58:	687b      	ldr	r3, [r7, #4]
10004f5a:	429a      	cmp	r2, r3
10004f5c:	d203      	bcs.n	10004f66 <xTaskIncrementTick+0x96>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
10004f5e:	4b2e      	ldr	r3, [pc, #184]	; (10005018 <xTaskIncrementTick+0x148>)
10004f60:	687a      	ldr	r2, [r7, #4]
10004f62:	601a      	str	r2, [r3, #0]
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
10004f64:	e02f      	b.n	10004fc6 <xTaskIncrementTick+0xf6>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
10004f66:	68bb      	ldr	r3, [r7, #8]
10004f68:	3304      	adds	r3, #4
10004f6a:	1c18      	adds	r0, r3, #0
10004f6c:	f7ff f84e 	bl	1000400c <uxListRemove>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
10004f70:	68bb      	ldr	r3, [r7, #8]
10004f72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
10004f74:	2b00      	cmp	r3, #0
10004f76:	d004      	beq.n	10004f82 <xTaskIncrementTick+0xb2>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
10004f78:	68bb      	ldr	r3, [r7, #8]
10004f7a:	3318      	adds	r3, #24
10004f7c:	1c18      	adds	r0, r3, #0
10004f7e:	f7ff f845 	bl	1000400c <uxListRemove>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
10004f82:	68bb      	ldr	r3, [r7, #8]
10004f84:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004f86:	4b25      	ldr	r3, [pc, #148]	; (1000501c <xTaskIncrementTick+0x14c>)
10004f88:	681b      	ldr	r3, [r3, #0]
10004f8a:	429a      	cmp	r2, r3
10004f8c:	d903      	bls.n	10004f96 <xTaskIncrementTick+0xc6>
10004f8e:	68bb      	ldr	r3, [r7, #8]
10004f90:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004f92:	4b22      	ldr	r3, [pc, #136]	; (1000501c <xTaskIncrementTick+0x14c>)
10004f94:	601a      	str	r2, [r3, #0]
10004f96:	68bb      	ldr	r3, [r7, #8]
10004f98:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004f9a:	1c13      	adds	r3, r2, #0
10004f9c:	009b      	lsls	r3, r3, #2
10004f9e:	189b      	adds	r3, r3, r2
10004fa0:	009b      	lsls	r3, r3, #2
10004fa2:	4a1f      	ldr	r2, [pc, #124]	; (10005020 <xTaskIncrementTick+0x150>)
10004fa4:	189a      	adds	r2, r3, r2
10004fa6:	68bb      	ldr	r3, [r7, #8]
10004fa8:	3304      	adds	r3, #4
10004faa:	1c10      	adds	r0, r2, #0
10004fac:	1c19      	adds	r1, r3, #0
10004fae:	f7fe ffd5 	bl	10003f5c <vListInsertEnd>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
10004fb2:	68bb      	ldr	r3, [r7, #8]
10004fb4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004fb6:	4b1b      	ldr	r3, [pc, #108]	; (10005024 <xTaskIncrementTick+0x154>)
10004fb8:	681b      	ldr	r3, [r3, #0]
10004fba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10004fbc:	429a      	cmp	r2, r3
10004fbe:	d301      	bcc.n	10004fc4 <xTaskIncrementTick+0xf4>
                            {
                                xSwitchRequired = pdTRUE;
10004fc0:	2301      	movs	r3, #1
10004fc2:	617b      	str	r3, [r7, #20]
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                    #endif /* configUSE_PREEMPTION */
                }
            }
10004fc4:	e7b5      	b.n	10004f32 <xTaskIncrementTick+0x62>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
10004fc6:	4b17      	ldr	r3, [pc, #92]	; (10005024 <xTaskIncrementTick+0x154>)
10004fc8:	681b      	ldr	r3, [r3, #0]
10004fca:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10004fcc:	4914      	ldr	r1, [pc, #80]	; (10005020 <xTaskIncrementTick+0x150>)
10004fce:	1c13      	adds	r3, r2, #0
10004fd0:	009b      	lsls	r3, r3, #2
10004fd2:	189b      	adds	r3, r3, r2
10004fd4:	009b      	lsls	r3, r3, #2
10004fd6:	585b      	ldr	r3, [r3, r1]
10004fd8:	2b01      	cmp	r3, #1
10004fda:	d901      	bls.n	10004fe0 <xTaskIncrementTick+0x110>
                {
                    xSwitchRequired = pdTRUE;
10004fdc:	2301      	movs	r3, #1
10004fde:	617b      	str	r3, [r7, #20]
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
10004fe0:	4b11      	ldr	r3, [pc, #68]	; (10005028 <xTaskIncrementTick+0x158>)
10004fe2:	681b      	ldr	r3, [r3, #0]
10004fe4:	2b00      	cmp	r3, #0
10004fe6:	d001      	beq.n	10004fec <xTaskIncrementTick+0x11c>
                {
                    xSwitchRequired = pdTRUE;
10004fe8:	2301      	movs	r3, #1
10004fea:	617b      	str	r3, [r7, #20]
10004fec:	e004      	b.n	10004ff8 <xTaskIncrementTick+0x128>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
10004fee:	4b0f      	ldr	r3, [pc, #60]	; (1000502c <xTaskIncrementTick+0x15c>)
10004ff0:	681b      	ldr	r3, [r3, #0]
10004ff2:	1c5a      	adds	r2, r3, #1
10004ff4:	4b0d      	ldr	r3, [pc, #52]	; (1000502c <xTaskIncrementTick+0x15c>)
10004ff6:	601a      	str	r2, [r3, #0]
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
10004ff8:	697b      	ldr	r3, [r7, #20]
}
10004ffa:	1c18      	adds	r0, r3, #0
10004ffc:	46bd      	mov	sp, r7
10004ffe:	b006      	add	sp, #24
10005000:	bd80      	pop	{r7, pc}
10005002:	46c0      	nop			; (mov r8, r8)
10005004:	2000077c 	.word	0x2000077c
10005008:	20000758 	.word	0x20000758
1000500c:	2000070c 	.word	0x2000070c
10005010:	20000710 	.word	0x20000710
10005014:	2000076c 	.word	0x2000076c
10005018:	20000774 	.word	0x20000774
1000501c:	2000075c 	.word	0x2000075c
10005020:	20000680 	.word	0x20000680
10005024:	2000067c 	.word	0x2000067c
10005028:	20000768 	.word	0x20000768
1000502c:	20000764 	.word	0x20000764

10005030 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
10005030:	b580      	push	{r7, lr}
10005032:	b082      	sub	sp, #8
10005034:	af00      	add	r7, sp, #0
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
10005036:	4b21      	ldr	r3, [pc, #132]	; (100050bc <vTaskSwitchContext+0x8c>)
10005038:	681b      	ldr	r3, [r3, #0]
1000503a:	2b00      	cmp	r3, #0
1000503c:	d003      	beq.n	10005046 <vTaskSwitchContext+0x16>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
1000503e:	4b20      	ldr	r3, [pc, #128]	; (100050c0 <vTaskSwitchContext+0x90>)
10005040:	2201      	movs	r2, #1
10005042:	601a      	str	r2, [r3, #0]
10005044:	e037      	b.n	100050b6 <vTaskSwitchContext+0x86>
    }
    else
    {
        xYieldPending = pdFALSE;
10005046:	4b1e      	ldr	r3, [pc, #120]	; (100050c0 <vTaskSwitchContext+0x90>)
10005048:	2200      	movs	r2, #0
1000504a:	601a      	str	r2, [r3, #0]
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
1000504c:	4b1d      	ldr	r3, [pc, #116]	; (100050c4 <vTaskSwitchContext+0x94>)
1000504e:	681b      	ldr	r3, [r3, #0]
10005050:	607b      	str	r3, [r7, #4]
10005052:	e007      	b.n	10005064 <vTaskSwitchContext+0x34>
10005054:	687b      	ldr	r3, [r7, #4]
10005056:	2b00      	cmp	r3, #0
10005058:	d101      	bne.n	1000505e <vTaskSwitchContext+0x2e>
1000505a:	b672      	cpsid	i
1000505c:	e7fe      	b.n	1000505c <vTaskSwitchContext+0x2c>
1000505e:	687b      	ldr	r3, [r7, #4]
10005060:	3b01      	subs	r3, #1
10005062:	607b      	str	r3, [r7, #4]
10005064:	4918      	ldr	r1, [pc, #96]	; (100050c8 <vTaskSwitchContext+0x98>)
10005066:	687a      	ldr	r2, [r7, #4]
10005068:	1c13      	adds	r3, r2, #0
1000506a:	009b      	lsls	r3, r3, #2
1000506c:	189b      	adds	r3, r3, r2
1000506e:	009b      	lsls	r3, r3, #2
10005070:	585b      	ldr	r3, [r3, r1]
10005072:	2b00      	cmp	r3, #0
10005074:	d0ee      	beq.n	10005054 <vTaskSwitchContext+0x24>
10005076:	687a      	ldr	r2, [r7, #4]
10005078:	1c13      	adds	r3, r2, #0
1000507a:	009b      	lsls	r3, r3, #2
1000507c:	189b      	adds	r3, r3, r2
1000507e:	009b      	lsls	r3, r3, #2
10005080:	4a11      	ldr	r2, [pc, #68]	; (100050c8 <vTaskSwitchContext+0x98>)
10005082:	189b      	adds	r3, r3, r2
10005084:	603b      	str	r3, [r7, #0]
10005086:	683b      	ldr	r3, [r7, #0]
10005088:	685b      	ldr	r3, [r3, #4]
1000508a:	685a      	ldr	r2, [r3, #4]
1000508c:	683b      	ldr	r3, [r7, #0]
1000508e:	605a      	str	r2, [r3, #4]
10005090:	683b      	ldr	r3, [r7, #0]
10005092:	685a      	ldr	r2, [r3, #4]
10005094:	683b      	ldr	r3, [r7, #0]
10005096:	3308      	adds	r3, #8
10005098:	429a      	cmp	r2, r3
1000509a:	d104      	bne.n	100050a6 <vTaskSwitchContext+0x76>
1000509c:	683b      	ldr	r3, [r7, #0]
1000509e:	685b      	ldr	r3, [r3, #4]
100050a0:	685a      	ldr	r2, [r3, #4]
100050a2:	683b      	ldr	r3, [r7, #0]
100050a4:	605a      	str	r2, [r3, #4]
100050a6:	683b      	ldr	r3, [r7, #0]
100050a8:	685b      	ldr	r3, [r3, #4]
100050aa:	68da      	ldr	r2, [r3, #12]
100050ac:	4b07      	ldr	r3, [pc, #28]	; (100050cc <vTaskSwitchContext+0x9c>)
100050ae:	601a      	str	r2, [r3, #0]
100050b0:	4b04      	ldr	r3, [pc, #16]	; (100050c4 <vTaskSwitchContext+0x94>)
100050b2:	687a      	ldr	r2, [r7, #4]
100050b4:	601a      	str	r2, [r3, #0]
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
100050b6:	46bd      	mov	sp, r7
100050b8:	b002      	add	sp, #8
100050ba:	bd80      	pop	{r7, pc}
100050bc:	2000077c 	.word	0x2000077c
100050c0:	20000768 	.word	0x20000768
100050c4:	2000075c 	.word	0x2000075c
100050c8:	20000680 	.word	0x20000680
100050cc:	2000067c 	.word	0x2000067c

100050d0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
100050d0:	b580      	push	{r7, lr}
100050d2:	b082      	sub	sp, #8
100050d4:	af00      	add	r7, sp, #0
100050d6:	6078      	str	r0, [r7, #4]
100050d8:	6039      	str	r1, [r7, #0]
    configASSERT( pxEventList );
100050da:	687b      	ldr	r3, [r7, #4]
100050dc:	2b00      	cmp	r3, #0
100050de:	d101      	bne.n	100050e4 <vTaskPlaceOnEventList+0x14>
100050e0:	b672      	cpsid	i
100050e2:	e7fe      	b.n	100050e2 <vTaskPlaceOnEventList+0x12>

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
100050e4:	4b07      	ldr	r3, [pc, #28]	; (10005104 <vTaskPlaceOnEventList+0x34>)
100050e6:	681b      	ldr	r3, [r3, #0]
100050e8:	3318      	adds	r3, #24
100050ea:	687a      	ldr	r2, [r7, #4]
100050ec:	1c10      	adds	r0, r2, #0
100050ee:	1c19      	adds	r1, r3, #0
100050f0:	f7fe ff56 	bl	10003fa0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
100050f4:	683b      	ldr	r3, [r7, #0]
100050f6:	1c18      	adds	r0, r3, #0
100050f8:	2101      	movs	r1, #1
100050fa:	f000 fa27 	bl	1000554c <prvAddCurrentTaskToDelayedList>
}
100050fe:	46bd      	mov	sp, r7
10005100:	b002      	add	sp, #8
10005102:	bd80      	pop	{r7, pc}
10005104:	2000067c 	.word	0x2000067c

10005108 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
10005108:	b580      	push	{r7, lr}
1000510a:	b084      	sub	sp, #16
1000510c:	af00      	add	r7, sp, #0
1000510e:	60f8      	str	r0, [r7, #12]
10005110:	60b9      	str	r1, [r7, #8]
10005112:	607a      	str	r2, [r7, #4]
        configASSERT( pxEventList );
10005114:	68fb      	ldr	r3, [r7, #12]
10005116:	2b00      	cmp	r3, #0
10005118:	d101      	bne.n	1000511e <vTaskPlaceOnEventListRestricted+0x16>
1000511a:	b672      	cpsid	i
1000511c:	e7fe      	b.n	1000511c <vTaskPlaceOnEventListRestricted+0x14>

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
1000511e:	4b0b      	ldr	r3, [pc, #44]	; (1000514c <vTaskPlaceOnEventListRestricted+0x44>)
10005120:	681b      	ldr	r3, [r3, #0]
10005122:	3318      	adds	r3, #24
10005124:	68fa      	ldr	r2, [r7, #12]
10005126:	1c10      	adds	r0, r2, #0
10005128:	1c19      	adds	r1, r3, #0
1000512a:	f7fe ff17 	bl	10003f5c <vListInsertEnd>

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
1000512e:	687b      	ldr	r3, [r7, #4]
10005130:	2b00      	cmp	r3, #0
10005132:	d002      	beq.n	1000513a <vTaskPlaceOnEventListRestricted+0x32>
        {
            xTicksToWait = portMAX_DELAY;
10005134:	2301      	movs	r3, #1
10005136:	425b      	negs	r3, r3
10005138:	60bb      	str	r3, [r7, #8]
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
1000513a:	68ba      	ldr	r2, [r7, #8]
1000513c:	687b      	ldr	r3, [r7, #4]
1000513e:	1c10      	adds	r0, r2, #0
10005140:	1c19      	adds	r1, r3, #0
10005142:	f000 fa03 	bl	1000554c <prvAddCurrentTaskToDelayedList>
    }
10005146:	46bd      	mov	sp, r7
10005148:	b004      	add	sp, #16
1000514a:	bd80      	pop	{r7, pc}
1000514c:	2000067c 	.word	0x2000067c

10005150 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
10005150:	b580      	push	{r7, lr}
10005152:	b084      	sub	sp, #16
10005154:	af00      	add	r7, sp, #0
10005156:	6078      	str	r0, [r7, #4]
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10005158:	687b      	ldr	r3, [r7, #4]
1000515a:	68db      	ldr	r3, [r3, #12]
1000515c:	68db      	ldr	r3, [r3, #12]
1000515e:	60bb      	str	r3, [r7, #8]
    configASSERT( pxUnblockedTCB );
10005160:	68bb      	ldr	r3, [r7, #8]
10005162:	2b00      	cmp	r3, #0
10005164:	d101      	bne.n	1000516a <xTaskRemoveFromEventList+0x1a>
10005166:	b672      	cpsid	i
10005168:	e7fe      	b.n	10005168 <xTaskRemoveFromEventList+0x18>
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
1000516a:	68bb      	ldr	r3, [r7, #8]
1000516c:	3318      	adds	r3, #24
1000516e:	1c18      	adds	r0, r3, #0
10005170:	f7fe ff4c 	bl	1000400c <uxListRemove>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10005174:	4b1e      	ldr	r3, [pc, #120]	; (100051f0 <xTaskRemoveFromEventList+0xa0>)
10005176:	681b      	ldr	r3, [r3, #0]
10005178:	2b00      	cmp	r3, #0
1000517a:	d11d      	bne.n	100051b8 <xTaskRemoveFromEventList+0x68>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
1000517c:	68bb      	ldr	r3, [r7, #8]
1000517e:	3304      	adds	r3, #4
10005180:	1c18      	adds	r0, r3, #0
10005182:	f7fe ff43 	bl	1000400c <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
10005186:	68bb      	ldr	r3, [r7, #8]
10005188:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000518a:	4b1a      	ldr	r3, [pc, #104]	; (100051f4 <xTaskRemoveFromEventList+0xa4>)
1000518c:	681b      	ldr	r3, [r3, #0]
1000518e:	429a      	cmp	r2, r3
10005190:	d903      	bls.n	1000519a <xTaskRemoveFromEventList+0x4a>
10005192:	68bb      	ldr	r3, [r7, #8]
10005194:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10005196:	4b17      	ldr	r3, [pc, #92]	; (100051f4 <xTaskRemoveFromEventList+0xa4>)
10005198:	601a      	str	r2, [r3, #0]
1000519a:	68bb      	ldr	r3, [r7, #8]
1000519c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000519e:	1c13      	adds	r3, r2, #0
100051a0:	009b      	lsls	r3, r3, #2
100051a2:	189b      	adds	r3, r3, r2
100051a4:	009b      	lsls	r3, r3, #2
100051a6:	4a14      	ldr	r2, [pc, #80]	; (100051f8 <xTaskRemoveFromEventList+0xa8>)
100051a8:	189a      	adds	r2, r3, r2
100051aa:	68bb      	ldr	r3, [r7, #8]
100051ac:	3304      	adds	r3, #4
100051ae:	1c10      	adds	r0, r2, #0
100051b0:	1c19      	adds	r1, r3, #0
100051b2:	f7fe fed3 	bl	10003f5c <vListInsertEnd>
100051b6:	e006      	b.n	100051c6 <xTaskRemoveFromEventList+0x76>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
100051b8:	68bb      	ldr	r3, [r7, #8]
100051ba:	3318      	adds	r3, #24
100051bc:	4a0f      	ldr	r2, [pc, #60]	; (100051fc <xTaskRemoveFromEventList+0xac>)
100051be:	1c10      	adds	r0, r2, #0
100051c0:	1c19      	adds	r1, r3, #0
100051c2:	f7fe fecb 	bl	10003f5c <vListInsertEnd>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
100051c6:	68bb      	ldr	r3, [r7, #8]
100051c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100051ca:	4b0d      	ldr	r3, [pc, #52]	; (10005200 <xTaskRemoveFromEventList+0xb0>)
100051cc:	681b      	ldr	r3, [r3, #0]
100051ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
100051d0:	429a      	cmp	r2, r3
100051d2:	d905      	bls.n	100051e0 <xTaskRemoveFromEventList+0x90>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
100051d4:	2301      	movs	r3, #1
100051d6:	60fb      	str	r3, [r7, #12]

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
100051d8:	4b0a      	ldr	r3, [pc, #40]	; (10005204 <xTaskRemoveFromEventList+0xb4>)
100051da:	2201      	movs	r2, #1
100051dc:	601a      	str	r2, [r3, #0]
100051de:	e001      	b.n	100051e4 <xTaskRemoveFromEventList+0x94>
    }
    else
    {
        xReturn = pdFALSE;
100051e0:	2300      	movs	r3, #0
100051e2:	60fb      	str	r3, [r7, #12]
    }

    return xReturn;
100051e4:	68fb      	ldr	r3, [r7, #12]
}
100051e6:	1c18      	adds	r0, r3, #0
100051e8:	46bd      	mov	sp, r7
100051ea:	b004      	add	sp, #16
100051ec:	bd80      	pop	{r7, pc}
100051ee:	46c0      	nop			; (mov r8, r8)
100051f0:	2000077c 	.word	0x2000077c
100051f4:	2000075c 	.word	0x2000075c
100051f8:	20000680 	.word	0x20000680
100051fc:	20000714 	.word	0x20000714
10005200:	2000067c 	.word	0x2000067c
10005204:	20000768 	.word	0x20000768

10005208 <vTaskInternalSetTimeOutState>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
10005208:	b580      	push	{r7, lr}
1000520a:	b082      	sub	sp, #8
1000520c:	af00      	add	r7, sp, #0
1000520e:	6078      	str	r0, [r7, #4]
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
10005210:	4b05      	ldr	r3, [pc, #20]	; (10005228 <vTaskInternalSetTimeOutState+0x20>)
10005212:	681a      	ldr	r2, [r3, #0]
10005214:	687b      	ldr	r3, [r7, #4]
10005216:	601a      	str	r2, [r3, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
10005218:	4b04      	ldr	r3, [pc, #16]	; (1000522c <vTaskInternalSetTimeOutState+0x24>)
1000521a:	681a      	ldr	r2, [r3, #0]
1000521c:	687b      	ldr	r3, [r7, #4]
1000521e:	605a      	str	r2, [r3, #4]
}
10005220:	46bd      	mov	sp, r7
10005222:	b002      	add	sp, #8
10005224:	bd80      	pop	{r7, pc}
10005226:	46c0      	nop			; (mov r8, r8)
10005228:	2000076c 	.word	0x2000076c
1000522c:	20000758 	.word	0x20000758

10005230 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
10005230:	b580      	push	{r7, lr}
10005232:	b086      	sub	sp, #24
10005234:	af00      	add	r7, sp, #0
10005236:	6078      	str	r0, [r7, #4]
10005238:	6039      	str	r1, [r7, #0]
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
1000523a:	687b      	ldr	r3, [r7, #4]
1000523c:	2b00      	cmp	r3, #0
1000523e:	d101      	bne.n	10005244 <xTaskCheckForTimeOut+0x14>
10005240:	b672      	cpsid	i
10005242:	e7fe      	b.n	10005242 <xTaskCheckForTimeOut+0x12>
    configASSERT( pxTicksToWait );
10005244:	683b      	ldr	r3, [r7, #0]
10005246:	2b00      	cmp	r3, #0
10005248:	d101      	bne.n	1000524e <xTaskCheckForTimeOut+0x1e>
1000524a:	b672      	cpsid	i
1000524c:	e7fe      	b.n	1000524c <xTaskCheckForTimeOut+0x1c>

    taskENTER_CRITICAL();
1000524e:	f7fe fda1 	bl	10003d94 <vPortEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
10005252:	4b26      	ldr	r3, [pc, #152]	; (100052ec <xTaskCheckForTimeOut+0xbc>)
10005254:	681b      	ldr	r3, [r3, #0]
10005256:	613b      	str	r3, [r7, #16]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
10005258:	687b      	ldr	r3, [r7, #4]
1000525a:	685b      	ldr	r3, [r3, #4]
1000525c:	693a      	ldr	r2, [r7, #16]
1000525e:	1ad3      	subs	r3, r2, r3
10005260:	60fb      	str	r3, [r7, #12]

        #if ( INCLUDE_xTaskAbortDelay == 1 )
            if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
10005262:	4b23      	ldr	r3, [pc, #140]	; (100052f0 <xTaskCheckForTimeOut+0xc0>)
10005264:	681b      	ldr	r3, [r3, #0]
10005266:	226d      	movs	r2, #109	; 0x6d
10005268:	5c9b      	ldrb	r3, [r3, r2]
1000526a:	2b00      	cmp	r3, #0
1000526c:	d007      	beq.n	1000527e <xTaskCheckForTimeOut+0x4e>
            {
                /* The delay was aborted, which is not the same as a time out,
                 * but has the same result. */
                pxCurrentTCB->ucDelayAborted = pdFALSE;
1000526e:	4b20      	ldr	r3, [pc, #128]	; (100052f0 <xTaskCheckForTimeOut+0xc0>)
10005270:	681b      	ldr	r3, [r3, #0]
10005272:	226d      	movs	r2, #109	; 0x6d
10005274:	2100      	movs	r1, #0
10005276:	5499      	strb	r1, [r3, r2]
                xReturn = pdTRUE;
10005278:	2301      	movs	r3, #1
1000527a:	617b      	str	r3, [r7, #20]
1000527c:	e02e      	b.n	100052dc <xTaskCheckForTimeOut+0xac>
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
1000527e:	683b      	ldr	r3, [r7, #0]
10005280:	681b      	ldr	r3, [r3, #0]
10005282:	3301      	adds	r3, #1
10005284:	d102      	bne.n	1000528c <xTaskCheckForTimeOut+0x5c>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
10005286:	2300      	movs	r3, #0
10005288:	617b      	str	r3, [r7, #20]
1000528a:	e027      	b.n	100052dc <xTaskCheckForTimeOut+0xac>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
1000528c:	687b      	ldr	r3, [r7, #4]
1000528e:	681a      	ldr	r2, [r3, #0]
10005290:	4b18      	ldr	r3, [pc, #96]	; (100052f4 <xTaskCheckForTimeOut+0xc4>)
10005292:	681b      	ldr	r3, [r3, #0]
10005294:	429a      	cmp	r2, r3
10005296:	d00a      	beq.n	100052ae <xTaskCheckForTimeOut+0x7e>
10005298:	687b      	ldr	r3, [r7, #4]
1000529a:	685a      	ldr	r2, [r3, #4]
1000529c:	693b      	ldr	r3, [r7, #16]
1000529e:	429a      	cmp	r2, r3
100052a0:	d805      	bhi.n	100052ae <xTaskCheckForTimeOut+0x7e>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
100052a2:	2301      	movs	r3, #1
100052a4:	617b      	str	r3, [r7, #20]
            *pxTicksToWait = ( TickType_t ) 0;
100052a6:	683b      	ldr	r3, [r7, #0]
100052a8:	2200      	movs	r2, #0
100052aa:	601a      	str	r2, [r3, #0]
100052ac:	e016      	b.n	100052dc <xTaskCheckForTimeOut+0xac>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
100052ae:	683b      	ldr	r3, [r7, #0]
100052b0:	681a      	ldr	r2, [r3, #0]
100052b2:	68fb      	ldr	r3, [r7, #12]
100052b4:	429a      	cmp	r2, r3
100052b6:	d90c      	bls.n	100052d2 <xTaskCheckForTimeOut+0xa2>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
100052b8:	683b      	ldr	r3, [r7, #0]
100052ba:	681a      	ldr	r2, [r3, #0]
100052bc:	68fb      	ldr	r3, [r7, #12]
100052be:	1ad2      	subs	r2, r2, r3
100052c0:	683b      	ldr	r3, [r7, #0]
100052c2:	601a      	str	r2, [r3, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
100052c4:	687b      	ldr	r3, [r7, #4]
100052c6:	1c18      	adds	r0, r3, #0
100052c8:	f7ff ff9e 	bl	10005208 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
100052cc:	2300      	movs	r3, #0
100052ce:	617b      	str	r3, [r7, #20]
100052d0:	e004      	b.n	100052dc <xTaskCheckForTimeOut+0xac>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
100052d2:	683b      	ldr	r3, [r7, #0]
100052d4:	2200      	movs	r2, #0
100052d6:	601a      	str	r2, [r3, #0]
            xReturn = pdTRUE;
100052d8:	2301      	movs	r3, #1
100052da:	617b      	str	r3, [r7, #20]
        }
    }
    taskEXIT_CRITICAL();
100052dc:	f7fe fd6a 	bl	10003db4 <vPortExitCritical>

    return xReturn;
100052e0:	697b      	ldr	r3, [r7, #20]
}
100052e2:	1c18      	adds	r0, r3, #0
100052e4:	46bd      	mov	sp, r7
100052e6:	b006      	add	sp, #24
100052e8:	bd80      	pop	{r7, pc}
100052ea:	46c0      	nop			; (mov r8, r8)
100052ec:	20000758 	.word	0x20000758
100052f0:	2000067c 	.word	0x2000067c
100052f4:	2000076c 	.word	0x2000076c

100052f8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
100052f8:	b580      	push	{r7, lr}
100052fa:	af00      	add	r7, sp, #0
    xYieldPending = pdTRUE;
100052fc:	4b02      	ldr	r3, [pc, #8]	; (10005308 <vTaskMissedYield+0x10>)
100052fe:	2201      	movs	r2, #1
10005300:	601a      	str	r2, [r3, #0]
}
10005302:	46bd      	mov	sp, r7
10005304:	bd80      	pop	{r7, pc}
10005306:	46c0      	nop			; (mov r8, r8)
10005308:	20000768 	.word	0x20000768

1000530c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
1000530c:	b580      	push	{r7, lr}
1000530e:	b082      	sub	sp, #8
10005310:	af00      	add	r7, sp, #0
10005312:	6078      	str	r0, [r7, #4]

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
10005314:	f000 f84e 	bl	100053b4 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
10005318:	4b03      	ldr	r3, [pc, #12]	; (10005328 <prvIdleTask+0x1c>)
1000531a:	681b      	ldr	r3, [r3, #0]
1000531c:	2b01      	cmp	r3, #1
1000531e:	d901      	bls.n	10005324 <prvIdleTask+0x18>
                {
                    taskYIELD();
10005320:	f7fe fd2a 	bl	10003d78 <vPortYield>
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_TICKLESS_IDLE */
    }
10005324:	e7f6      	b.n	10005314 <prvIdleTask+0x8>
10005326:	46c0      	nop			; (mov r8, r8)
10005328:	20000680 	.word	0x20000680

1000532c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
1000532c:	b580      	push	{r7, lr}
1000532e:	b082      	sub	sp, #8
10005330:	af00      	add	r7, sp, #0
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
10005332:	2300      	movs	r3, #0
10005334:	607b      	str	r3, [r7, #4]
10005336:	e00c      	b.n	10005352 <prvInitialiseTaskLists+0x26>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
10005338:	687a      	ldr	r2, [r7, #4]
1000533a:	1c13      	adds	r3, r2, #0
1000533c:	009b      	lsls	r3, r3, #2
1000533e:	189b      	adds	r3, r3, r2
10005340:	009b      	lsls	r3, r3, #2
10005342:	4a14      	ldr	r2, [pc, #80]	; (10005394 <prvInitialiseTaskLists+0x68>)
10005344:	189b      	adds	r3, r3, r2
10005346:	1c18      	adds	r0, r3, #0
10005348:	f7fe fde0 	bl	10003f0c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
1000534c:	687b      	ldr	r3, [r7, #4]
1000534e:	3301      	adds	r3, #1
10005350:	607b      	str	r3, [r7, #4]
10005352:	687b      	ldr	r3, [r7, #4]
10005354:	2b04      	cmp	r3, #4
10005356:	d9ef      	bls.n	10005338 <prvInitialiseTaskLists+0xc>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
10005358:	4b0f      	ldr	r3, [pc, #60]	; (10005398 <prvInitialiseTaskLists+0x6c>)
1000535a:	1c18      	adds	r0, r3, #0
1000535c:	f7fe fdd6 	bl	10003f0c <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
10005360:	4b0e      	ldr	r3, [pc, #56]	; (1000539c <prvInitialiseTaskLists+0x70>)
10005362:	1c18      	adds	r0, r3, #0
10005364:	f7fe fdd2 	bl	10003f0c <vListInitialise>
    vListInitialise( &xPendingReadyList );
10005368:	4b0d      	ldr	r3, [pc, #52]	; (100053a0 <prvInitialiseTaskLists+0x74>)
1000536a:	1c18      	adds	r0, r3, #0
1000536c:	f7fe fdce 	bl	10003f0c <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
10005370:	4b0c      	ldr	r3, [pc, #48]	; (100053a4 <prvInitialiseTaskLists+0x78>)
10005372:	1c18      	adds	r0, r3, #0
10005374:	f7fe fdca 	bl	10003f0c <vListInitialise>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
10005378:	4b0b      	ldr	r3, [pc, #44]	; (100053a8 <prvInitialiseTaskLists+0x7c>)
1000537a:	1c18      	adds	r0, r3, #0
1000537c:	f7fe fdc6 	bl	10003f0c <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
10005380:	4b0a      	ldr	r3, [pc, #40]	; (100053ac <prvInitialiseTaskLists+0x80>)
10005382:	4a05      	ldr	r2, [pc, #20]	; (10005398 <prvInitialiseTaskLists+0x6c>)
10005384:	601a      	str	r2, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
10005386:	4b0a      	ldr	r3, [pc, #40]	; (100053b0 <prvInitialiseTaskLists+0x84>)
10005388:	4a04      	ldr	r2, [pc, #16]	; (1000539c <prvInitialiseTaskLists+0x70>)
1000538a:	601a      	str	r2, [r3, #0]
}
1000538c:	46bd      	mov	sp, r7
1000538e:	b002      	add	sp, #8
10005390:	bd80      	pop	{r7, pc}
10005392:	46c0      	nop			; (mov r8, r8)
10005394:	20000680 	.word	0x20000680
10005398:	200006e4 	.word	0x200006e4
1000539c:	200006f8 	.word	0x200006f8
100053a0:	20000714 	.word	0x20000714
100053a4:	20000728 	.word	0x20000728
100053a8:	20000740 	.word	0x20000740
100053ac:	2000070c 	.word	0x2000070c
100053b0:	20000710 	.word	0x20000710

100053b4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
100053b4:	b580      	push	{r7, lr}
100053b6:	b082      	sub	sp, #8
100053b8:	af00      	add	r7, sp, #0
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
100053ba:	e01a      	b.n	100053f2 <prvCheckTasksWaitingTermination+0x3e>
            {
                taskENTER_CRITICAL();
100053bc:	f7fe fcea 	bl	10003d94 <vPortEnterCritical>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
100053c0:	4b0f      	ldr	r3, [pc, #60]	; (10005400 <prvCheckTasksWaitingTermination+0x4c>)
100053c2:	68db      	ldr	r3, [r3, #12]
100053c4:	68db      	ldr	r3, [r3, #12]
100053c6:	607b      	str	r3, [r7, #4]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
100053c8:	687b      	ldr	r3, [r7, #4]
100053ca:	3304      	adds	r3, #4
100053cc:	1c18      	adds	r0, r3, #0
100053ce:	f7fe fe1d 	bl	1000400c <uxListRemove>
                    --uxCurrentNumberOfTasks;
100053d2:	4b0c      	ldr	r3, [pc, #48]	; (10005404 <prvCheckTasksWaitingTermination+0x50>)
100053d4:	681b      	ldr	r3, [r3, #0]
100053d6:	1e5a      	subs	r2, r3, #1
100053d8:	4b0a      	ldr	r3, [pc, #40]	; (10005404 <prvCheckTasksWaitingTermination+0x50>)
100053da:	601a      	str	r2, [r3, #0]
                    --uxDeletedTasksWaitingCleanUp;
100053dc:	4b0a      	ldr	r3, [pc, #40]	; (10005408 <prvCheckTasksWaitingTermination+0x54>)
100053de:	681b      	ldr	r3, [r3, #0]
100053e0:	1e5a      	subs	r2, r3, #1
100053e2:	4b09      	ldr	r3, [pc, #36]	; (10005408 <prvCheckTasksWaitingTermination+0x54>)
100053e4:	601a      	str	r2, [r3, #0]
                }
                taskEXIT_CRITICAL();
100053e6:	f7fe fce5 	bl	10003db4 <vPortExitCritical>

                prvDeleteTCB( pxTCB );
100053ea:	687b      	ldr	r3, [r7, #4]
100053ec:	1c18      	adds	r0, r3, #0
100053ee:	f000 f80d 	bl	1000540c <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
100053f2:	4b05      	ldr	r3, [pc, #20]	; (10005408 <prvCheckTasksWaitingTermination+0x54>)
100053f4:	681b      	ldr	r3, [r3, #0]
100053f6:	2b00      	cmp	r3, #0
100053f8:	d1e0      	bne.n	100053bc <prvCheckTasksWaitingTermination+0x8>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
100053fa:	46bd      	mov	sp, r7
100053fc:	b002      	add	sp, #8
100053fe:	bd80      	pop	{r7, pc}
10005400:	20000728 	.word	0x20000728
10005404:	20000754 	.word	0x20000754
10005408:	2000073c 	.word	0x2000073c

1000540c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
1000540c:	b580      	push	{r7, lr}
1000540e:	b082      	sub	sp, #8
10005410:	af00      	add	r7, sp, #0
10005412:	6078      	str	r0, [r7, #4]

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
10005414:	687b      	ldr	r3, [r7, #4]
10005416:	6b1b      	ldr	r3, [r3, #48]	; 0x30
10005418:	1c18      	adds	r0, r3, #0
1000541a:	f7fe fd65 	bl	10003ee8 <vPortFree>
                vPortFree( pxTCB );
1000541e:	687b      	ldr	r3, [r7, #4]
10005420:	1c18      	adds	r0, r3, #0
10005422:	f7fe fd61 	bl	10003ee8 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
10005426:	46bd      	mov	sp, r7
10005428:	b002      	add	sp, #8
1000542a:	bd80      	pop	{r7, pc}

1000542c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
1000542c:	b580      	push	{r7, lr}
1000542e:	af00      	add	r7, sp, #0
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
10005430:	4b08      	ldr	r3, [pc, #32]	; (10005454 <prvResetNextTaskUnblockTime+0x28>)
10005432:	681b      	ldr	r3, [r3, #0]
10005434:	681b      	ldr	r3, [r3, #0]
10005436:	2b00      	cmp	r3, #0
10005438:	d104      	bne.n	10005444 <prvResetNextTaskUnblockTime+0x18>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
1000543a:	4b07      	ldr	r3, [pc, #28]	; (10005458 <prvResetNextTaskUnblockTime+0x2c>)
1000543c:	2201      	movs	r2, #1
1000543e:	4252      	negs	r2, r2
10005440:	601a      	str	r2, [r3, #0]
10005442:	e005      	b.n	10005450 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
10005444:	4b03      	ldr	r3, [pc, #12]	; (10005454 <prvResetNextTaskUnblockTime+0x28>)
10005446:	681b      	ldr	r3, [r3, #0]
10005448:	68db      	ldr	r3, [r3, #12]
1000544a:	681a      	ldr	r2, [r3, #0]
1000544c:	4b02      	ldr	r3, [pc, #8]	; (10005458 <prvResetNextTaskUnblockTime+0x2c>)
1000544e:	601a      	str	r2, [r3, #0]
    }
}
10005450:	46bd      	mov	sp, r7
10005452:	bd80      	pop	{r7, pc}
10005454:	2000070c 	.word	0x2000070c
10005458:	20000774 	.word	0x20000774

1000545c <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
1000545c:	b580      	push	{r7, lr}
1000545e:	b082      	sub	sp, #8
10005460:	af00      	add	r7, sp, #0
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
10005462:	4b0a      	ldr	r3, [pc, #40]	; (1000548c <xTaskGetSchedulerState+0x30>)
10005464:	681b      	ldr	r3, [r3, #0]
10005466:	2b00      	cmp	r3, #0
10005468:	d102      	bne.n	10005470 <xTaskGetSchedulerState+0x14>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
1000546a:	2301      	movs	r3, #1
1000546c:	607b      	str	r3, [r7, #4]
1000546e:	e008      	b.n	10005482 <xTaskGetSchedulerState+0x26>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10005470:	4b07      	ldr	r3, [pc, #28]	; (10005490 <xTaskGetSchedulerState+0x34>)
10005472:	681b      	ldr	r3, [r3, #0]
10005474:	2b00      	cmp	r3, #0
10005476:	d102      	bne.n	1000547e <xTaskGetSchedulerState+0x22>
            {
                xReturn = taskSCHEDULER_RUNNING;
10005478:	2302      	movs	r3, #2
1000547a:	607b      	str	r3, [r7, #4]
1000547c:	e001      	b.n	10005482 <xTaskGetSchedulerState+0x26>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
1000547e:	2300      	movs	r3, #0
10005480:	607b      	str	r3, [r7, #4]
            }
        }

        return xReturn;
10005482:	687b      	ldr	r3, [r7, #4]
    }
10005484:	1c18      	adds	r0, r3, #0
10005486:	46bd      	mov	sp, r7
10005488:	b002      	add	sp, #8
1000548a:	bd80      	pop	{r7, pc}
1000548c:	20000760 	.word	0x20000760
10005490:	2000077c 	.word	0x2000077c

10005494 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
10005494:	b580      	push	{r7, lr}
10005496:	b084      	sub	sp, #16
10005498:	af00      	add	r7, sp, #0
1000549a:	6078      	str	r0, [r7, #4]
        TCB_t * const pxTCB = pxMutexHolder;
1000549c:	687b      	ldr	r3, [r7, #4]
1000549e:	60bb      	str	r3, [r7, #8]
        BaseType_t xReturn = pdFALSE;
100054a0:	2300      	movs	r3, #0
100054a2:	60fb      	str	r3, [r7, #12]

        if( pxMutexHolder != NULL )
100054a4:	687b      	ldr	r3, [r7, #4]
100054a6:	2b00      	cmp	r3, #0
100054a8:	d044      	beq.n	10005534 <xTaskPriorityDisinherit+0xa0>
        {
            /* A task can only have an inherited priority if it holds the mutex.
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
100054aa:	4b25      	ldr	r3, [pc, #148]	; (10005540 <xTaskPriorityDisinherit+0xac>)
100054ac:	681b      	ldr	r3, [r3, #0]
100054ae:	68ba      	ldr	r2, [r7, #8]
100054b0:	429a      	cmp	r2, r3
100054b2:	d001      	beq.n	100054b8 <xTaskPriorityDisinherit+0x24>
100054b4:	b672      	cpsid	i
100054b6:	e7fe      	b.n	100054b6 <xTaskPriorityDisinherit+0x22>
            configASSERT( pxTCB->uxMutexesHeld );
100054b8:	68bb      	ldr	r3, [r7, #8]
100054ba:	6d1b      	ldr	r3, [r3, #80]	; 0x50
100054bc:	2b00      	cmp	r3, #0
100054be:	d101      	bne.n	100054c4 <xTaskPriorityDisinherit+0x30>
100054c0:	b672      	cpsid	i
100054c2:	e7fe      	b.n	100054c2 <xTaskPriorityDisinherit+0x2e>
            ( pxTCB->uxMutexesHeld )--;
100054c4:	68bb      	ldr	r3, [r7, #8]
100054c6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
100054c8:	1e5a      	subs	r2, r3, #1
100054ca:	68bb      	ldr	r3, [r7, #8]
100054cc:	651a      	str	r2, [r3, #80]	; 0x50

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
100054ce:	68bb      	ldr	r3, [r7, #8]
100054d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100054d2:	68bb      	ldr	r3, [r7, #8]
100054d4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
100054d6:	429a      	cmp	r2, r3
100054d8:	d02c      	beq.n	10005534 <xTaskPriorityDisinherit+0xa0>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
100054da:	68bb      	ldr	r3, [r7, #8]
100054dc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
100054de:	2b00      	cmp	r3, #0
100054e0:	d128      	bne.n	10005534 <xTaskPriorityDisinherit+0xa0>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
100054e2:	68bb      	ldr	r3, [r7, #8]
100054e4:	3304      	adds	r3, #4
100054e6:	1c18      	adds	r0, r3, #0
100054e8:	f7fe fd90 	bl	1000400c <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
100054ec:	68bb      	ldr	r3, [r7, #8]
100054ee:	6cda      	ldr	r2, [r3, #76]	; 0x4c
100054f0:	68bb      	ldr	r3, [r7, #8]
100054f2:	62da      	str	r2, [r3, #44]	; 0x2c

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
100054f4:	68bb      	ldr	r3, [r7, #8]
100054f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
100054f8:	2205      	movs	r2, #5
100054fa:	1ad2      	subs	r2, r2, r3
100054fc:	68bb      	ldr	r3, [r7, #8]
100054fe:	619a      	str	r2, [r3, #24]
                    prvAddTaskToReadyList( pxTCB );
10005500:	68bb      	ldr	r3, [r7, #8]
10005502:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10005504:	4b0f      	ldr	r3, [pc, #60]	; (10005544 <xTaskPriorityDisinherit+0xb0>)
10005506:	681b      	ldr	r3, [r3, #0]
10005508:	429a      	cmp	r2, r3
1000550a:	d903      	bls.n	10005514 <xTaskPriorityDisinherit+0x80>
1000550c:	68bb      	ldr	r3, [r7, #8]
1000550e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10005510:	4b0c      	ldr	r3, [pc, #48]	; (10005544 <xTaskPriorityDisinherit+0xb0>)
10005512:	601a      	str	r2, [r3, #0]
10005514:	68bb      	ldr	r3, [r7, #8]
10005516:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10005518:	1c13      	adds	r3, r2, #0
1000551a:	009b      	lsls	r3, r3, #2
1000551c:	189b      	adds	r3, r3, r2
1000551e:	009b      	lsls	r3, r3, #2
10005520:	4a09      	ldr	r2, [pc, #36]	; (10005548 <xTaskPriorityDisinherit+0xb4>)
10005522:	189a      	adds	r2, r3, r2
10005524:	68bb      	ldr	r3, [r7, #8]
10005526:	3304      	adds	r3, #4
10005528:	1c10      	adds	r0, r2, #0
1000552a:	1c19      	adds	r1, r3, #0
1000552c:	f7fe fd16 	bl	10003f5c <vListInsertEnd>
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
10005530:	2301      	movs	r3, #1
10005532:	60fb      	str	r3, [r7, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
10005534:	68fb      	ldr	r3, [r7, #12]
    }
10005536:	1c18      	adds	r0, r3, #0
10005538:	46bd      	mov	sp, r7
1000553a:	b004      	add	sp, #16
1000553c:	bd80      	pop	{r7, pc}
1000553e:	46c0      	nop			; (mov r8, r8)
10005540:	2000067c 	.word	0x2000067c
10005544:	2000075c 	.word	0x2000075c
10005548:	20000680 	.word	0x20000680

1000554c <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
1000554c:	b580      	push	{r7, lr}
1000554e:	b084      	sub	sp, #16
10005550:	af00      	add	r7, sp, #0
10005552:	6078      	str	r0, [r7, #4]
10005554:	6039      	str	r1, [r7, #0]
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
10005556:	4b23      	ldr	r3, [pc, #140]	; (100055e4 <prvAddCurrentTaskToDelayedList+0x98>)
10005558:	681b      	ldr	r3, [r3, #0]
1000555a:	60fb      	str	r3, [r7, #12]
    #if ( INCLUDE_xTaskAbortDelay == 1 )
        {
            /* About to enter a delayed list, so ensure the ucDelayAborted flag is
             * reset to pdFALSE so it can be detected as having been set to pdTRUE
             * when the task leaves the Blocked state. */
            pxCurrentTCB->ucDelayAborted = pdFALSE;
1000555c:	4b22      	ldr	r3, [pc, #136]	; (100055e8 <prvAddCurrentTaskToDelayedList+0x9c>)
1000555e:	681b      	ldr	r3, [r3, #0]
10005560:	226d      	movs	r2, #109	; 0x6d
10005562:	2100      	movs	r1, #0
10005564:	5499      	strb	r1, [r3, r2]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
10005566:	4b20      	ldr	r3, [pc, #128]	; (100055e8 <prvAddCurrentTaskToDelayedList+0x9c>)
10005568:	681b      	ldr	r3, [r3, #0]
1000556a:	3304      	adds	r3, #4
1000556c:	1c18      	adds	r0, r3, #0
1000556e:	f7fe fd4d 	bl	1000400c <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
10005572:	687b      	ldr	r3, [r7, #4]
10005574:	3301      	adds	r3, #1
10005576:	d10b      	bne.n	10005590 <prvAddCurrentTaskToDelayedList+0x44>
10005578:	683b      	ldr	r3, [r7, #0]
1000557a:	2b00      	cmp	r3, #0
1000557c:	d008      	beq.n	10005590 <prvAddCurrentTaskToDelayedList+0x44>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
1000557e:	4b1a      	ldr	r3, [pc, #104]	; (100055e8 <prvAddCurrentTaskToDelayedList+0x9c>)
10005580:	681b      	ldr	r3, [r3, #0]
10005582:	3304      	adds	r3, #4
10005584:	4a19      	ldr	r2, [pc, #100]	; (100055ec <prvAddCurrentTaskToDelayedList+0xa0>)
10005586:	1c10      	adds	r0, r2, #0
10005588:	1c19      	adds	r1, r3, #0
1000558a:	f7fe fce7 	bl	10003f5c <vListInsertEnd>
1000558e:	e026      	b.n	100055de <prvAddCurrentTaskToDelayedList+0x92>
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
10005590:	68fa      	ldr	r2, [r7, #12]
10005592:	687b      	ldr	r3, [r7, #4]
10005594:	18d3      	adds	r3, r2, r3
10005596:	60bb      	str	r3, [r7, #8]

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
10005598:	4b13      	ldr	r3, [pc, #76]	; (100055e8 <prvAddCurrentTaskToDelayedList+0x9c>)
1000559a:	681b      	ldr	r3, [r3, #0]
1000559c:	68ba      	ldr	r2, [r7, #8]
1000559e:	605a      	str	r2, [r3, #4]

                if( xTimeToWake < xConstTickCount )
100055a0:	68ba      	ldr	r2, [r7, #8]
100055a2:	68fb      	ldr	r3, [r7, #12]
100055a4:	429a      	cmp	r2, r3
100055a6:	d209      	bcs.n	100055bc <prvAddCurrentTaskToDelayedList+0x70>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
100055a8:	4b11      	ldr	r3, [pc, #68]	; (100055f0 <prvAddCurrentTaskToDelayedList+0xa4>)
100055aa:	681a      	ldr	r2, [r3, #0]
100055ac:	4b0e      	ldr	r3, [pc, #56]	; (100055e8 <prvAddCurrentTaskToDelayedList+0x9c>)
100055ae:	681b      	ldr	r3, [r3, #0]
100055b0:	3304      	adds	r3, #4
100055b2:	1c10      	adds	r0, r2, #0
100055b4:	1c19      	adds	r1, r3, #0
100055b6:	f7fe fcf3 	bl	10003fa0 <vListInsert>
100055ba:	e010      	b.n	100055de <prvAddCurrentTaskToDelayedList+0x92>
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
100055bc:	4b0d      	ldr	r3, [pc, #52]	; (100055f4 <prvAddCurrentTaskToDelayedList+0xa8>)
100055be:	681a      	ldr	r2, [r3, #0]
100055c0:	4b09      	ldr	r3, [pc, #36]	; (100055e8 <prvAddCurrentTaskToDelayedList+0x9c>)
100055c2:	681b      	ldr	r3, [r3, #0]
100055c4:	3304      	adds	r3, #4
100055c6:	1c10      	adds	r0, r2, #0
100055c8:	1c19      	adds	r1, r3, #0
100055ca:	f7fe fce9 	bl	10003fa0 <vListInsert>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
100055ce:	4b0a      	ldr	r3, [pc, #40]	; (100055f8 <prvAddCurrentTaskToDelayedList+0xac>)
100055d0:	681b      	ldr	r3, [r3, #0]
100055d2:	68ba      	ldr	r2, [r7, #8]
100055d4:	429a      	cmp	r2, r3
100055d6:	d202      	bcs.n	100055de <prvAddCurrentTaskToDelayedList+0x92>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
100055d8:	4b07      	ldr	r3, [pc, #28]	; (100055f8 <prvAddCurrentTaskToDelayedList+0xac>)
100055da:	68ba      	ldr	r2, [r7, #8]
100055dc:	601a      	str	r2, [r3, #0]

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
100055de:	46bd      	mov	sp, r7
100055e0:	b004      	add	sp, #16
100055e2:	bd80      	pop	{r7, pc}
100055e4:	20000758 	.word	0x20000758
100055e8:	2000067c 	.word	0x2000067c
100055ec:	20000740 	.word	0x20000740
100055f0:	20000710 	.word	0x20000710
100055f4:	2000070c 	.word	0x2000070c
100055f8:	20000774 	.word	0x20000774

100055fc <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
100055fc:	b580      	push	{r7, lr}
100055fe:	b084      	sub	sp, #16
10005600:	af02      	add	r7, sp, #8
        BaseType_t xReturn = pdFAIL;
10005602:	2300      	movs	r3, #0
10005604:	607b      	str	r3, [r7, #4]

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
10005606:	f000 fac9 	bl	10005b9c <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
1000560a:	4b0e      	ldr	r3, [pc, #56]	; (10005644 <xTimerCreateTimerTask+0x48>)
1000560c:	681b      	ldr	r3, [r3, #0]
1000560e:	2b00      	cmp	r3, #0
10005610:	d00d      	beq.n	1000562e <xTimerCreateTimerTask+0x32>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
10005612:	490d      	ldr	r1, [pc, #52]	; (10005648 <xTimerCreateTimerTask+0x4c>)
10005614:	4a0d      	ldr	r2, [pc, #52]	; (1000564c <xTimerCreateTimerTask+0x50>)
10005616:	2302      	movs	r3, #2
10005618:	9300      	str	r3, [sp, #0]
1000561a:	4b0d      	ldr	r3, [pc, #52]	; (10005650 <xTimerCreateTimerTask+0x54>)
1000561c:	9301      	str	r3, [sp, #4]
1000561e:	1c08      	adds	r0, r1, #0
10005620:	1c11      	adds	r1, r2, #0
10005622:	2278      	movs	r2, #120	; 0x78
10005624:	2300      	movs	r3, #0
10005626:	f7ff f9fd 	bl	10004a24 <xTaskCreate>
1000562a:	1c03      	adds	r3, r0, #0
1000562c:	607b      	str	r3, [r7, #4]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
1000562e:	687b      	ldr	r3, [r7, #4]
10005630:	2b00      	cmp	r3, #0
10005632:	d101      	bne.n	10005638 <xTimerCreateTimerTask+0x3c>
10005634:	b672      	cpsid	i
10005636:	e7fe      	b.n	10005636 <xTimerCreateTimerTask+0x3a>
        return xReturn;
10005638:	687b      	ldr	r3, [r7, #4]
    }
1000563a:	1c18      	adds	r0, r3, #0
1000563c:	46bd      	mov	sp, r7
1000563e:	b002      	add	sp, #8
10005640:	bd80      	pop	{r7, pc}
10005642:	46c0      	nop			; (mov r8, r8)
10005644:	200007b0 	.word	0x200007b0
10005648:	10005789 	.word	0x10005789
1000564c:	100067e8 	.word	0x100067e8
10005650:	200007b4 	.word	0x200007b4

10005654 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
10005654:	b580      	push	{r7, lr}
10005656:	b08a      	sub	sp, #40	; 0x28
10005658:	af00      	add	r7, sp, #0
1000565a:	60f8      	str	r0, [r7, #12]
1000565c:	60b9      	str	r1, [r7, #8]
1000565e:	607a      	str	r2, [r7, #4]
10005660:	603b      	str	r3, [r7, #0]
        BaseType_t xReturn = pdFAIL;
10005662:	2300      	movs	r3, #0
10005664:	627b      	str	r3, [r7, #36]	; 0x24
        DaemonTaskMessage_t xMessage;

        configASSERT( xTimer );
10005666:	68fb      	ldr	r3, [r7, #12]
10005668:	2b00      	cmp	r3, #0
1000566a:	d101      	bne.n	10005670 <xTimerGenericCommand+0x1c>
1000566c:	b672      	cpsid	i
1000566e:	e7fe      	b.n	1000566e <xTimerGenericCommand+0x1a>

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
10005670:	4b22      	ldr	r3, [pc, #136]	; (100056fc <xTimerGenericCommand+0xa8>)
10005672:	681b      	ldr	r3, [r3, #0]
10005674:	2b00      	cmp	r3, #0
10005676:	d03b      	beq.n	100056f0 <xTimerGenericCommand+0x9c>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
10005678:	2314      	movs	r3, #20
1000567a:	18fb      	adds	r3, r7, r3
1000567c:	68ba      	ldr	r2, [r7, #8]
1000567e:	601a      	str	r2, [r3, #0]
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
10005680:	2314      	movs	r3, #20
10005682:	18fb      	adds	r3, r7, r3
10005684:	687a      	ldr	r2, [r7, #4]
10005686:	605a      	str	r2, [r3, #4]
            xMessage.u.xTimerParameters.pxTimer = xTimer;
10005688:	2314      	movs	r3, #20
1000568a:	18fb      	adds	r3, r7, r3
1000568c:	68fa      	ldr	r2, [r7, #12]
1000568e:	609a      	str	r2, [r3, #8]

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
10005690:	68bb      	ldr	r3, [r7, #8]
10005692:	2b05      	cmp	r3, #5
10005694:	dc1f      	bgt.n	100056d6 <xTimerGenericCommand+0x82>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
10005696:	f7ff fee1 	bl	1000545c <xTaskGetSchedulerState>
1000569a:	1e03      	subs	r3, r0, #0
1000569c:	2b02      	cmp	r3, #2
1000569e:	d10d      	bne.n	100056bc <xTimerGenericCommand+0x68>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
100056a0:	4b16      	ldr	r3, [pc, #88]	; (100056fc <xTimerGenericCommand+0xa8>)
100056a2:	6819      	ldr	r1, [r3, #0]
100056a4:	2314      	movs	r3, #20
100056a6:	18fa      	adds	r2, r7, r3
100056a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
100056aa:	1c08      	adds	r0, r1, #0
100056ac:	1c11      	adds	r1, r2, #0
100056ae:	1c1a      	adds	r2, r3, #0
100056b0:	2300      	movs	r3, #0
100056b2:	f7fe fd9b 	bl	100041ec <xQueueGenericSend>
100056b6:	1c03      	adds	r3, r0, #0
100056b8:	627b      	str	r3, [r7, #36]	; 0x24
100056ba:	e019      	b.n	100056f0 <xTimerGenericCommand+0x9c>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
100056bc:	4b0f      	ldr	r3, [pc, #60]	; (100056fc <xTimerGenericCommand+0xa8>)
100056be:	681a      	ldr	r2, [r3, #0]
100056c0:	2314      	movs	r3, #20
100056c2:	18fb      	adds	r3, r7, r3
100056c4:	1c10      	adds	r0, r2, #0
100056c6:	1c19      	adds	r1, r3, #0
100056c8:	2200      	movs	r2, #0
100056ca:	2300      	movs	r3, #0
100056cc:	f7fe fd8e 	bl	100041ec <xQueueGenericSend>
100056d0:	1c03      	adds	r3, r0, #0
100056d2:	627b      	str	r3, [r7, #36]	; 0x24
100056d4:	e00c      	b.n	100056f0 <xTimerGenericCommand+0x9c>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
100056d6:	4b09      	ldr	r3, [pc, #36]	; (100056fc <xTimerGenericCommand+0xa8>)
100056d8:	6819      	ldr	r1, [r3, #0]
100056da:	2314      	movs	r3, #20
100056dc:	18fa      	adds	r2, r7, r3
100056de:	683b      	ldr	r3, [r7, #0]
100056e0:	1c08      	adds	r0, r1, #0
100056e2:	1c11      	adds	r1, r2, #0
100056e4:	1c1a      	adds	r2, r3, #0
100056e6:	2300      	movs	r3, #0
100056e8:	f7fe fe64 	bl	100043b4 <xQueueGenericSendFromISR>
100056ec:	1c03      	adds	r3, r0, #0
100056ee:	627b      	str	r3, [r7, #36]	; 0x24
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
100056f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    }
100056f2:	1c18      	adds	r0, r3, #0
100056f4:	46bd      	mov	sp, r7
100056f6:	b00a      	add	sp, #40	; 0x28
100056f8:	bd80      	pop	{r7, pc}
100056fa:	46c0      	nop			; (mov r8, r8)
100056fc:	200007b0 	.word	0x200007b0

10005700 <prvProcessExpiredTimer>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
10005700:	b580      	push	{r7, lr}
10005702:	b086      	sub	sp, #24
10005704:	af02      	add	r7, sp, #8
10005706:	6078      	str	r0, [r7, #4]
10005708:	6039      	str	r1, [r7, #0]
        BaseType_t xResult;
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
1000570a:	4b1e      	ldr	r3, [pc, #120]	; (10005784 <prvProcessExpiredTimer+0x84>)
1000570c:	681b      	ldr	r3, [r3, #0]
1000570e:	68db      	ldr	r3, [r3, #12]
10005710:	68db      	ldr	r3, [r3, #12]
10005712:	60fb      	str	r3, [r7, #12]

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
10005714:	68fb      	ldr	r3, [r7, #12]
10005716:	3304      	adds	r3, #4
10005718:	1c18      	adds	r0, r3, #0
1000571a:	f7fe fc77 	bl	1000400c <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
1000571e:	68fb      	ldr	r3, [r7, #12]
10005720:	2228      	movs	r2, #40	; 0x28
10005722:	5c9b      	ldrb	r3, [r3, r2]
10005724:	1c1a      	adds	r2, r3, #0
10005726:	2304      	movs	r3, #4
10005728:	4013      	ands	r3, r2
1000572a:	d01a      	beq.n	10005762 <prvProcessExpiredTimer+0x62>
        {
            /* The timer is inserted into a list using a time relative to anything
             * other than the current time.  It will therefore be inserted into the
             * correct list relative to the time this task thinks it is now. */
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
1000572c:	68fb      	ldr	r3, [r7, #12]
1000572e:	699a      	ldr	r2, [r3, #24]
10005730:	687b      	ldr	r3, [r7, #4]
10005732:	18d1      	adds	r1, r2, r3
10005734:	68f8      	ldr	r0, [r7, #12]
10005736:	683a      	ldr	r2, [r7, #0]
10005738:	687b      	ldr	r3, [r7, #4]
1000573a:	f000 f8c3 	bl	100058c4 <prvInsertTimerInActiveList>
1000573e:	1e03      	subs	r3, r0, #0
10005740:	d018      	beq.n	10005774 <prvProcessExpiredTimer+0x74>
            {
                /* The timer expired before it was added to the active timer
                 * list.  Reload it now.  */
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
10005742:	68f9      	ldr	r1, [r7, #12]
10005744:	687a      	ldr	r2, [r7, #4]
10005746:	2300      	movs	r3, #0
10005748:	9300      	str	r3, [sp, #0]
1000574a:	1c08      	adds	r0, r1, #0
1000574c:	2100      	movs	r1, #0
1000574e:	2300      	movs	r3, #0
10005750:	f7ff ff80 	bl	10005654 <xTimerGenericCommand>
10005754:	1c03      	adds	r3, r0, #0
10005756:	60bb      	str	r3, [r7, #8]
                configASSERT( xResult );
10005758:	68bb      	ldr	r3, [r7, #8]
1000575a:	2b00      	cmp	r3, #0
1000575c:	d10a      	bne.n	10005774 <prvProcessExpiredTimer+0x74>
1000575e:	b672      	cpsid	i
10005760:	e7fe      	b.n	10005760 <prvProcessExpiredTimer+0x60>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
10005762:	68fb      	ldr	r3, [r7, #12]
10005764:	2228      	movs	r2, #40	; 0x28
10005766:	5c9b      	ldrb	r3, [r3, r2]
10005768:	2201      	movs	r2, #1
1000576a:	4393      	bics	r3, r2
1000576c:	b2d9      	uxtb	r1, r3
1000576e:	68fb      	ldr	r3, [r7, #12]
10005770:	2228      	movs	r2, #40	; 0x28
10005772:	5499      	strb	r1, [r3, r2]
            mtCOVERAGE_TEST_MARKER();
        }

        /* Call the timer callback. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
10005774:	68fb      	ldr	r3, [r7, #12]
10005776:	6a1b      	ldr	r3, [r3, #32]
10005778:	68fa      	ldr	r2, [r7, #12]
1000577a:	1c10      	adds	r0, r2, #0
1000577c:	4798      	blx	r3
    }
1000577e:	46bd      	mov	sp, r7
10005780:	b004      	add	sp, #16
10005782:	bd80      	pop	{r7, pc}
10005784:	200007a8 	.word	0x200007a8

10005788 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
10005788:	b580      	push	{r7, lr}
1000578a:	b084      	sub	sp, #16
1000578c:	af00      	add	r7, sp, #0
1000578e:	6078      	str	r0, [r7, #4]

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
10005790:	2308      	movs	r3, #8
10005792:	18fb      	adds	r3, r7, r3
10005794:	1c18      	adds	r0, r3, #0
10005796:	f000 f853 	bl	10005840 <prvGetNextExpireTime>
1000579a:	1c03      	adds	r3, r0, #0
1000579c:	60fb      	str	r3, [r7, #12]

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
1000579e:	68bb      	ldr	r3, [r7, #8]
100057a0:	68fa      	ldr	r2, [r7, #12]
100057a2:	1c10      	adds	r0, r2, #0
100057a4:	1c19      	adds	r1, r3, #0
100057a6:	f000 f803 	bl	100057b0 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
100057aa:	f000 f8cd 	bl	10005948 <prvProcessReceivedCommands>
        }
100057ae:	e7ef      	b.n	10005790 <prvTimerTask+0x8>

100057b0 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
100057b0:	b580      	push	{r7, lr}
100057b2:	b084      	sub	sp, #16
100057b4:	af00      	add	r7, sp, #0
100057b6:	6078      	str	r0, [r7, #4]
100057b8:	6039      	str	r1, [r7, #0]
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
100057ba:	f7ff fae3 	bl	10004d84 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
100057be:	2308      	movs	r3, #8
100057c0:	18fb      	adds	r3, r7, r3
100057c2:	1c18      	adds	r0, r3, #0
100057c4:	f000 f85e 	bl	10005884 <prvSampleTimeNow>
100057c8:	1c03      	adds	r3, r0, #0
100057ca:	60fb      	str	r3, [r7, #12]

            if( xTimerListsWereSwitched == pdFALSE )
100057cc:	68bb      	ldr	r3, [r7, #8]
100057ce:	2b00      	cmp	r3, #0
100057d0:	d12d      	bne.n	1000582e <prvProcessTimerOrBlockTask+0x7e>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
100057d2:	683b      	ldr	r3, [r7, #0]
100057d4:	2b00      	cmp	r3, #0
100057d6:	d10c      	bne.n	100057f2 <prvProcessTimerOrBlockTask+0x42>
100057d8:	687a      	ldr	r2, [r7, #4]
100057da:	68fb      	ldr	r3, [r7, #12]
100057dc:	429a      	cmp	r2, r3
100057de:	d808      	bhi.n	100057f2 <prvProcessTimerOrBlockTask+0x42>
                {
                    ( void ) xTaskResumeAll();
100057e0:	f7ff fadc 	bl	10004d9c <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
100057e4:	687a      	ldr	r2, [r7, #4]
100057e6:	68fb      	ldr	r3, [r7, #12]
100057e8:	1c10      	adds	r0, r2, #0
100057ea:	1c19      	adds	r1, r3, #0
100057ec:	f7ff ff88 	bl	10005700 <prvProcessExpiredTimer>
100057f0:	e01f      	b.n	10005832 <prvProcessTimerOrBlockTask+0x82>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
100057f2:	683b      	ldr	r3, [r7, #0]
100057f4:	2b00      	cmp	r3, #0
100057f6:	d008      	beq.n	1000580a <prvProcessTimerOrBlockTask+0x5a>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
100057f8:	4b0f      	ldr	r3, [pc, #60]	; (10005838 <prvProcessTimerOrBlockTask+0x88>)
100057fa:	681b      	ldr	r3, [r3, #0]
100057fc:	681b      	ldr	r3, [r3, #0]
100057fe:	2b00      	cmp	r3, #0
10005800:	d101      	bne.n	10005806 <prvProcessTimerOrBlockTask+0x56>
10005802:	2301      	movs	r3, #1
10005804:	e000      	b.n	10005808 <prvProcessTimerOrBlockTask+0x58>
10005806:	2300      	movs	r3, #0
10005808:	603b      	str	r3, [r7, #0]
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
1000580a:	4b0c      	ldr	r3, [pc, #48]	; (1000583c <prvProcessTimerOrBlockTask+0x8c>)
1000580c:	6819      	ldr	r1, [r3, #0]
1000580e:	687a      	ldr	r2, [r7, #4]
10005810:	68fb      	ldr	r3, [r7, #12]
10005812:	1ad2      	subs	r2, r2, r3
10005814:	683b      	ldr	r3, [r7, #0]
10005816:	1c08      	adds	r0, r1, #0
10005818:	1c11      	adds	r1, r2, #0
1000581a:	1c1a      	adds	r2, r3, #0
1000581c:	f7ff f874 	bl	10004908 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
10005820:	f7ff fabc 	bl	10004d9c <xTaskResumeAll>
10005824:	1e03      	subs	r3, r0, #0
10005826:	d104      	bne.n	10005832 <prvProcessTimerOrBlockTask+0x82>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
10005828:	f7fe faa6 	bl	10003d78 <vPortYield>
1000582c:	e001      	b.n	10005832 <prvProcessTimerOrBlockTask+0x82>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
1000582e:	f7ff fab5 	bl	10004d9c <xTaskResumeAll>
            }
        }
    }
10005832:	46bd      	mov	sp, r7
10005834:	b004      	add	sp, #16
10005836:	bd80      	pop	{r7, pc}
10005838:	200007ac 	.word	0x200007ac
1000583c:	200007b0 	.word	0x200007b0

10005840 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
10005840:	b580      	push	{r7, lr}
10005842:	b084      	sub	sp, #16
10005844:	af00      	add	r7, sp, #0
10005846:	6078      	str	r0, [r7, #4]
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
10005848:	4b0d      	ldr	r3, [pc, #52]	; (10005880 <prvGetNextExpireTime+0x40>)
1000584a:	681b      	ldr	r3, [r3, #0]
1000584c:	681b      	ldr	r3, [r3, #0]
1000584e:	2b00      	cmp	r3, #0
10005850:	d101      	bne.n	10005856 <prvGetNextExpireTime+0x16>
10005852:	2201      	movs	r2, #1
10005854:	e000      	b.n	10005858 <prvGetNextExpireTime+0x18>
10005856:	2200      	movs	r2, #0
10005858:	687b      	ldr	r3, [r7, #4]
1000585a:	601a      	str	r2, [r3, #0]

        if( *pxListWasEmpty == pdFALSE )
1000585c:	687b      	ldr	r3, [r7, #4]
1000585e:	681b      	ldr	r3, [r3, #0]
10005860:	2b00      	cmp	r3, #0
10005862:	d105      	bne.n	10005870 <prvGetNextExpireTime+0x30>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
10005864:	4b06      	ldr	r3, [pc, #24]	; (10005880 <prvGetNextExpireTime+0x40>)
10005866:	681b      	ldr	r3, [r3, #0]
10005868:	68db      	ldr	r3, [r3, #12]
1000586a:	681b      	ldr	r3, [r3, #0]
1000586c:	60fb      	str	r3, [r7, #12]
1000586e:	e001      	b.n	10005874 <prvGetNextExpireTime+0x34>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
10005870:	2300      	movs	r3, #0
10005872:	60fb      	str	r3, [r7, #12]
        }

        return xNextExpireTime;
10005874:	68fb      	ldr	r3, [r7, #12]
    }
10005876:	1c18      	adds	r0, r3, #0
10005878:	46bd      	mov	sp, r7
1000587a:	b004      	add	sp, #16
1000587c:	bd80      	pop	{r7, pc}
1000587e:	46c0      	nop			; (mov r8, r8)
10005880:	200007a8 	.word	0x200007a8

10005884 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
10005884:	b580      	push	{r7, lr}
10005886:	b084      	sub	sp, #16
10005888:	af00      	add	r7, sp, #0
1000588a:	6078      	str	r0, [r7, #4]
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
1000588c:	f7ff fb12 	bl	10004eb4 <xTaskGetTickCount>
10005890:	1c03      	adds	r3, r0, #0
10005892:	60fb      	str	r3, [r7, #12]

        if( xTimeNow < xLastTime )
10005894:	4b0a      	ldr	r3, [pc, #40]	; (100058c0 <prvSampleTimeNow+0x3c>)
10005896:	681b      	ldr	r3, [r3, #0]
10005898:	68fa      	ldr	r2, [r7, #12]
1000589a:	429a      	cmp	r2, r3
1000589c:	d205      	bcs.n	100058aa <prvSampleTimeNow+0x26>
        {
            prvSwitchTimerLists();
1000589e:	f000 f91f 	bl	10005ae0 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
100058a2:	687b      	ldr	r3, [r7, #4]
100058a4:	2201      	movs	r2, #1
100058a6:	601a      	str	r2, [r3, #0]
100058a8:	e002      	b.n	100058b0 <prvSampleTimeNow+0x2c>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
100058aa:	687b      	ldr	r3, [r7, #4]
100058ac:	2200      	movs	r2, #0
100058ae:	601a      	str	r2, [r3, #0]
        }

        xLastTime = xTimeNow;
100058b0:	4b03      	ldr	r3, [pc, #12]	; (100058c0 <prvSampleTimeNow+0x3c>)
100058b2:	68fa      	ldr	r2, [r7, #12]
100058b4:	601a      	str	r2, [r3, #0]

        return xTimeNow;
100058b6:	68fb      	ldr	r3, [r7, #12]
    }
100058b8:	1c18      	adds	r0, r3, #0
100058ba:	46bd      	mov	sp, r7
100058bc:	b004      	add	sp, #16
100058be:	bd80      	pop	{r7, pc}
100058c0:	200007b8 	.word	0x200007b8

100058c4 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
100058c4:	b580      	push	{r7, lr}
100058c6:	b086      	sub	sp, #24
100058c8:	af00      	add	r7, sp, #0
100058ca:	60f8      	str	r0, [r7, #12]
100058cc:	60b9      	str	r1, [r7, #8]
100058ce:	607a      	str	r2, [r7, #4]
100058d0:	603b      	str	r3, [r7, #0]
        BaseType_t xProcessTimerNow = pdFALSE;
100058d2:	2300      	movs	r3, #0
100058d4:	617b      	str	r3, [r7, #20]

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
100058d6:	68fb      	ldr	r3, [r7, #12]
100058d8:	68ba      	ldr	r2, [r7, #8]
100058da:	605a      	str	r2, [r3, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
100058dc:	68fb      	ldr	r3, [r7, #12]
100058de:	68fa      	ldr	r2, [r7, #12]
100058e0:	611a      	str	r2, [r3, #16]

        if( xNextExpiryTime <= xTimeNow )
100058e2:	68ba      	ldr	r2, [r7, #8]
100058e4:	687b      	ldr	r3, [r7, #4]
100058e6:	429a      	cmp	r2, r3
100058e8:	d812      	bhi.n	10005910 <prvInsertTimerInActiveList+0x4c>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
100058ea:	687a      	ldr	r2, [r7, #4]
100058ec:	683b      	ldr	r3, [r7, #0]
100058ee:	1ad2      	subs	r2, r2, r3
100058f0:	68fb      	ldr	r3, [r7, #12]
100058f2:	699b      	ldr	r3, [r3, #24]
100058f4:	429a      	cmp	r2, r3
100058f6:	d302      	bcc.n	100058fe <prvInsertTimerInActiveList+0x3a>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
100058f8:	2301      	movs	r3, #1
100058fa:	617b      	str	r3, [r7, #20]
100058fc:	e01b      	b.n	10005936 <prvInsertTimerInActiveList+0x72>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
100058fe:	4b10      	ldr	r3, [pc, #64]	; (10005940 <prvInsertTimerInActiveList+0x7c>)
10005900:	681a      	ldr	r2, [r3, #0]
10005902:	68fb      	ldr	r3, [r7, #12]
10005904:	3304      	adds	r3, #4
10005906:	1c10      	adds	r0, r2, #0
10005908:	1c19      	adds	r1, r3, #0
1000590a:	f7fe fb49 	bl	10003fa0 <vListInsert>
1000590e:	e012      	b.n	10005936 <prvInsertTimerInActiveList+0x72>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
10005910:	687a      	ldr	r2, [r7, #4]
10005912:	683b      	ldr	r3, [r7, #0]
10005914:	429a      	cmp	r2, r3
10005916:	d206      	bcs.n	10005926 <prvInsertTimerInActiveList+0x62>
10005918:	68ba      	ldr	r2, [r7, #8]
1000591a:	683b      	ldr	r3, [r7, #0]
1000591c:	429a      	cmp	r2, r3
1000591e:	d302      	bcc.n	10005926 <prvInsertTimerInActiveList+0x62>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
10005920:	2301      	movs	r3, #1
10005922:	617b      	str	r3, [r7, #20]
10005924:	e007      	b.n	10005936 <prvInsertTimerInActiveList+0x72>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
10005926:	4b07      	ldr	r3, [pc, #28]	; (10005944 <prvInsertTimerInActiveList+0x80>)
10005928:	681a      	ldr	r2, [r3, #0]
1000592a:	68fb      	ldr	r3, [r7, #12]
1000592c:	3304      	adds	r3, #4
1000592e:	1c10      	adds	r0, r2, #0
10005930:	1c19      	adds	r1, r3, #0
10005932:	f7fe fb35 	bl	10003fa0 <vListInsert>
            }
        }

        return xProcessTimerNow;
10005936:	697b      	ldr	r3, [r7, #20]
    }
10005938:	1c18      	adds	r0, r3, #0
1000593a:	46bd      	mov	sp, r7
1000593c:	b006      	add	sp, #24
1000593e:	bd80      	pop	{r7, pc}
10005940:	200007ac 	.word	0x200007ac
10005944:	200007a8 	.word	0x200007a8

10005948 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
10005948:	b580      	push	{r7, lr}
1000594a:	b08c      	sub	sp, #48	; 0x30
1000594c:	af02      	add	r7, sp, #8
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched, xResult;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
1000594e:	e0b3      	b.n	10005ab8 <prvProcessReceivedCommands+0x170>
        {
            #if ( INCLUDE_xTimerPendFunctionCall == 1 )
                {
                    /* Negative commands are pended function calls rather than timer
                     * commands. */
                    if( xMessage.xMessageID < ( BaseType_t ) 0 )
10005950:	2308      	movs	r3, #8
10005952:	18fb      	adds	r3, r7, r3
10005954:	681b      	ldr	r3, [r3, #0]
10005956:	2b00      	cmp	r3, #0
10005958:	da11      	bge.n	1000597e <prvProcessReceivedCommands+0x36>
                    {
                        const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
1000595a:	2308      	movs	r3, #8
1000595c:	18fb      	adds	r3, r7, r3
1000595e:	3304      	adds	r3, #4
10005960:	627b      	str	r3, [r7, #36]	; 0x24

                        /* The timer uses the xCallbackParameters member to request a
                         * callback be executed.  Check the callback is not NULL. */
                        configASSERT( pxCallback );
10005962:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10005964:	2b00      	cmp	r3, #0
10005966:	d101      	bne.n	1000596c <prvProcessReceivedCommands+0x24>
10005968:	b672      	cpsid	i
1000596a:	e7fe      	b.n	1000596a <prvProcessReceivedCommands+0x22>

                        /* Call the function. */
                        pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
1000596c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
1000596e:	681a      	ldr	r2, [r3, #0]
10005970:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10005972:	6859      	ldr	r1, [r3, #4]
10005974:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10005976:	689b      	ldr	r3, [r3, #8]
10005978:	1c08      	adds	r0, r1, #0
1000597a:	1c19      	adds	r1, r3, #0
1000597c:	4790      	blx	r2
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
1000597e:	2308      	movs	r3, #8
10005980:	18fb      	adds	r3, r7, r3
10005982:	681b      	ldr	r3, [r3, #0]
10005984:	2b00      	cmp	r3, #0
10005986:	da00      	bge.n	1000598a <prvProcessReceivedCommands+0x42>
10005988:	e096      	b.n	10005ab8 <prvProcessReceivedCommands+0x170>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
1000598a:	2308      	movs	r3, #8
1000598c:	18fb      	adds	r3, r7, r3
1000598e:	689b      	ldr	r3, [r3, #8]
10005990:	623b      	str	r3, [r7, #32]

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
10005992:	6a3b      	ldr	r3, [r7, #32]
10005994:	695b      	ldr	r3, [r3, #20]
10005996:	2b00      	cmp	r3, #0
10005998:	d004      	beq.n	100059a4 <prvProcessReceivedCommands+0x5c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
1000599a:	6a3b      	ldr	r3, [r7, #32]
1000599c:	3304      	adds	r3, #4
1000599e:	1c18      	adds	r0, r3, #0
100059a0:	f7fe fb34 	bl	1000400c <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
100059a4:	1d3b      	adds	r3, r7, #4
100059a6:	1c18      	adds	r0, r3, #0
100059a8:	f7ff ff6c 	bl	10005884 <prvSampleTimeNow>
100059ac:	1c03      	adds	r3, r0, #0
100059ae:	61fb      	str	r3, [r7, #28]

                switch( xMessage.xMessageID )
100059b0:	2308      	movs	r3, #8
100059b2:	18fb      	adds	r3, r7, r3
100059b4:	681b      	ldr	r3, [r3, #0]
100059b6:	2b09      	cmp	r3, #9
100059b8:	d900      	bls.n	100059bc <prvProcessReceivedCommands+0x74>
100059ba:	e07c      	b.n	10005ab6 <prvProcessReceivedCommands+0x16e>
100059bc:	009a      	lsls	r2, r3, #2
100059be:	4b46      	ldr	r3, [pc, #280]	; (10005ad8 <prvProcessReceivedCommands+0x190>)
100059c0:	18d3      	adds	r3, r2, r3
100059c2:	681b      	ldr	r3, [r3, #0]
100059c4:	469f      	mov	pc, r3
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                    case tmrCOMMAND_START_DONT_TRACE:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
100059c6:	6a3b      	ldr	r3, [r7, #32]
100059c8:	2228      	movs	r2, #40	; 0x28
100059ca:	5c9b      	ldrb	r3, [r3, r2]
100059cc:	2201      	movs	r2, #1
100059ce:	4313      	orrs	r3, r2
100059d0:	b2d9      	uxtb	r1, r3
100059d2:	6a3b      	ldr	r3, [r7, #32]
100059d4:	2228      	movs	r2, #40	; 0x28
100059d6:	5499      	strb	r1, [r3, r2]

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
100059d8:	2308      	movs	r3, #8
100059da:	18fb      	adds	r3, r7, r3
100059dc:	685a      	ldr	r2, [r3, #4]
100059de:	6a3b      	ldr	r3, [r7, #32]
100059e0:	699b      	ldr	r3, [r3, #24]
100059e2:	18d1      	adds	r1, r2, r3
100059e4:	2308      	movs	r3, #8
100059e6:	18fb      	adds	r3, r7, r3
100059e8:	685b      	ldr	r3, [r3, #4]
100059ea:	6a38      	ldr	r0, [r7, #32]
100059ec:	69fa      	ldr	r2, [r7, #28]
100059ee:	f7ff ff69 	bl	100058c4 <prvInsertTimerInActiveList>
100059f2:	1e03      	subs	r3, r0, #0
100059f4:	d020      	beq.n	10005a38 <prvProcessReceivedCommands+0xf0>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
100059f6:	6a3b      	ldr	r3, [r7, #32]
100059f8:	6a1b      	ldr	r3, [r3, #32]
100059fa:	6a3a      	ldr	r2, [r7, #32]
100059fc:	1c10      	adds	r0, r2, #0
100059fe:	4798      	blx	r3
                            traceTIMER_EXPIRED( pxTimer );

                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
10005a00:	6a3b      	ldr	r3, [r7, #32]
10005a02:	2228      	movs	r2, #40	; 0x28
10005a04:	5c9b      	ldrb	r3, [r3, r2]
10005a06:	1c1a      	adds	r2, r3, #0
10005a08:	2304      	movs	r3, #4
10005a0a:	4013      	ands	r3, r2
10005a0c:	d014      	beq.n	10005a38 <prvProcessReceivedCommands+0xf0>
                            {
                                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
10005a0e:	2308      	movs	r3, #8
10005a10:	18fb      	adds	r3, r7, r3
10005a12:	685a      	ldr	r2, [r3, #4]
10005a14:	6a3b      	ldr	r3, [r7, #32]
10005a16:	699b      	ldr	r3, [r3, #24]
10005a18:	18d2      	adds	r2, r2, r3
10005a1a:	6a39      	ldr	r1, [r7, #32]
10005a1c:	2300      	movs	r3, #0
10005a1e:	9300      	str	r3, [sp, #0]
10005a20:	1c08      	adds	r0, r1, #0
10005a22:	2100      	movs	r1, #0
10005a24:	2300      	movs	r3, #0
10005a26:	f7ff fe15 	bl	10005654 <xTimerGenericCommand>
10005a2a:	1c03      	adds	r3, r0, #0
10005a2c:	61bb      	str	r3, [r7, #24]
                                configASSERT( xResult );
10005a2e:	69bb      	ldr	r3, [r7, #24]
10005a30:	2b00      	cmp	r3, #0
10005a32:	d101      	bne.n	10005a38 <prvProcessReceivedCommands+0xf0>
10005a34:	b672      	cpsid	i
10005a36:	e7fe      	b.n	10005a36 <prvProcessReceivedCommands+0xee>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        break;
10005a38:	e03e      	b.n	10005ab8 <prvProcessReceivedCommands+0x170>

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
10005a3a:	6a3b      	ldr	r3, [r7, #32]
10005a3c:	2228      	movs	r2, #40	; 0x28
10005a3e:	5c9b      	ldrb	r3, [r3, r2]
10005a40:	2201      	movs	r2, #1
10005a42:	4393      	bics	r3, r2
10005a44:	b2d9      	uxtb	r1, r3
10005a46:	6a3b      	ldr	r3, [r7, #32]
10005a48:	2228      	movs	r2, #40	; 0x28
10005a4a:	5499      	strb	r1, [r3, r2]
                        break;
10005a4c:	e034      	b.n	10005ab8 <prvProcessReceivedCommands+0x170>

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
10005a4e:	6a3b      	ldr	r3, [r7, #32]
10005a50:	2228      	movs	r2, #40	; 0x28
10005a52:	5c9b      	ldrb	r3, [r3, r2]
10005a54:	2201      	movs	r2, #1
10005a56:	4313      	orrs	r3, r2
10005a58:	b2d9      	uxtb	r1, r3
10005a5a:	6a3b      	ldr	r3, [r7, #32]
10005a5c:	2228      	movs	r2, #40	; 0x28
10005a5e:	5499      	strb	r1, [r3, r2]
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
10005a60:	2308      	movs	r3, #8
10005a62:	18fb      	adds	r3, r7, r3
10005a64:	685a      	ldr	r2, [r3, #4]
10005a66:	6a3b      	ldr	r3, [r7, #32]
10005a68:	619a      	str	r2, [r3, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
10005a6a:	6a3b      	ldr	r3, [r7, #32]
10005a6c:	699b      	ldr	r3, [r3, #24]
10005a6e:	2b00      	cmp	r3, #0
10005a70:	d101      	bne.n	10005a76 <prvProcessReceivedCommands+0x12e>
10005a72:	b672      	cpsid	i
10005a74:	e7fe      	b.n	10005a74 <prvProcessReceivedCommands+0x12c>
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
10005a76:	6a3b      	ldr	r3, [r7, #32]
10005a78:	699a      	ldr	r2, [r3, #24]
10005a7a:	69fb      	ldr	r3, [r7, #28]
10005a7c:	18d1      	adds	r1, r2, r3
10005a7e:	6a38      	ldr	r0, [r7, #32]
10005a80:	69fa      	ldr	r2, [r7, #28]
10005a82:	69fb      	ldr	r3, [r7, #28]
10005a84:	f7ff ff1e 	bl	100058c4 <prvInsertTimerInActiveList>
                        break;
10005a88:	e016      	b.n	10005ab8 <prvProcessReceivedCommands+0x170>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
10005a8a:	6a3b      	ldr	r3, [r7, #32]
10005a8c:	2228      	movs	r2, #40	; 0x28
10005a8e:	5c9b      	ldrb	r3, [r3, r2]
10005a90:	1c1a      	adds	r2, r3, #0
10005a92:	2302      	movs	r3, #2
10005a94:	4013      	ands	r3, r2
10005a96:	d104      	bne.n	10005aa2 <prvProcessReceivedCommands+0x15a>
                                {
                                    vPortFree( pxTimer );
10005a98:	6a3b      	ldr	r3, [r7, #32]
10005a9a:	1c18      	adds	r0, r3, #0
10005a9c:	f7fe fa24 	bl	10003ee8 <vPortFree>
10005aa0:	e008      	b.n	10005ab4 <prvProcessReceivedCommands+0x16c>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
10005aa2:	6a3b      	ldr	r3, [r7, #32]
10005aa4:	2228      	movs	r2, #40	; 0x28
10005aa6:	5c9b      	ldrb	r3, [r3, r2]
10005aa8:	2201      	movs	r2, #1
10005aaa:	4393      	bics	r3, r2
10005aac:	b2d9      	uxtb	r1, r3
10005aae:	6a3b      	ldr	r3, [r7, #32]
10005ab0:	2228      	movs	r2, #40	; 0x28
10005ab2:	5499      	strb	r1, [r3, r2]
                                 * no need to free the memory - just mark the timer as
                                 * "not active". */
                                pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                            }
                        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
                        break;
10005ab4:	e000      	b.n	10005ab8 <prvProcessReceivedCommands+0x170>

                    default:
                        /* Don't expect to get here. */
                        break;
10005ab6:	46c0      	nop			; (mov r8, r8)
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched, xResult;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
10005ab8:	4b08      	ldr	r3, [pc, #32]	; (10005adc <prvProcessReceivedCommands+0x194>)
10005aba:	681a      	ldr	r2, [r3, #0]
10005abc:	2308      	movs	r3, #8
10005abe:	18fb      	adds	r3, r7, r3
10005ac0:	1c10      	adds	r0, r2, #0
10005ac2:	1c19      	adds	r1, r3, #0
10005ac4:	2200      	movs	r2, #0
10005ac6:	f7fe fd0d 	bl	100044e4 <xQueueReceive>
10005aca:	1e03      	subs	r3, r0, #0
10005acc:	d000      	beq.n	10005ad0 <prvProcessReceivedCommands+0x188>
10005ace:	e73f      	b.n	10005950 <prvProcessReceivedCommands+0x8>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
10005ad0:	46bd      	mov	sp, r7
10005ad2:	b00a      	add	sp, #40	; 0x28
10005ad4:	bd80      	pop	{r7, pc}
10005ad6:	46c0      	nop			; (mov r8, r8)
10005ad8:	100067f8 	.word	0x100067f8
10005adc:	200007b0 	.word	0x200007b0

10005ae0 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
10005ae0:	b580      	push	{r7, lr}
10005ae2:	b088      	sub	sp, #32
10005ae4:	af02      	add	r7, sp, #8

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
10005ae6:	e042      	b.n	10005b6e <prvSwitchTimerLists+0x8e>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
10005ae8:	4b2a      	ldr	r3, [pc, #168]	; (10005b94 <prvSwitchTimerLists+0xb4>)
10005aea:	681b      	ldr	r3, [r3, #0]
10005aec:	68db      	ldr	r3, [r3, #12]
10005aee:	681b      	ldr	r3, [r3, #0]
10005af0:	617b      	str	r3, [r7, #20]

            /* Remove the timer from the list. */
            pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10005af2:	4b28      	ldr	r3, [pc, #160]	; (10005b94 <prvSwitchTimerLists+0xb4>)
10005af4:	681b      	ldr	r3, [r3, #0]
10005af6:	68db      	ldr	r3, [r3, #12]
10005af8:	68db      	ldr	r3, [r3, #12]
10005afa:	613b      	str	r3, [r7, #16]
            ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
10005afc:	693b      	ldr	r3, [r7, #16]
10005afe:	3304      	adds	r3, #4
10005b00:	1c18      	adds	r0, r3, #0
10005b02:	f7fe fa83 	bl	1000400c <uxListRemove>
            traceTIMER_EXPIRED( pxTimer );

            /* Execute its callback, then send a command to restart the timer if
             * it is an auto-reload timer.  It cannot be restarted here as the lists
             * have not yet been switched. */
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
10005b06:	693b      	ldr	r3, [r7, #16]
10005b08:	6a1b      	ldr	r3, [r3, #32]
10005b0a:	693a      	ldr	r2, [r7, #16]
10005b0c:	1c10      	adds	r0, r2, #0
10005b0e:	4798      	blx	r3

            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
10005b10:	693b      	ldr	r3, [r7, #16]
10005b12:	2228      	movs	r2, #40	; 0x28
10005b14:	5c9b      	ldrb	r3, [r3, r2]
10005b16:	1c1a      	adds	r2, r3, #0
10005b18:	2304      	movs	r3, #4
10005b1a:	4013      	ands	r3, r2
10005b1c:	d027      	beq.n	10005b6e <prvSwitchTimerLists+0x8e>
                 * the timer going into the same timer list then it has already expired
                 * and the timer should be re-inserted into the current list so it is
                 * processed again within this loop.  Otherwise a command should be sent
                 * to restart the timer to ensure it is only inserted into a list after
                 * the lists have been swapped. */
                xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
10005b1e:	693b      	ldr	r3, [r7, #16]
10005b20:	699a      	ldr	r2, [r3, #24]
10005b22:	697b      	ldr	r3, [r7, #20]
10005b24:	18d3      	adds	r3, r2, r3
10005b26:	60fb      	str	r3, [r7, #12]

                if( xReloadTime > xNextExpireTime )
10005b28:	68fa      	ldr	r2, [r7, #12]
10005b2a:	697b      	ldr	r3, [r7, #20]
10005b2c:	429a      	cmp	r2, r3
10005b2e:	d90e      	bls.n	10005b4e <prvSwitchTimerLists+0x6e>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
10005b30:	693b      	ldr	r3, [r7, #16]
10005b32:	68fa      	ldr	r2, [r7, #12]
10005b34:	605a      	str	r2, [r3, #4]
                    listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
10005b36:	693b      	ldr	r3, [r7, #16]
10005b38:	693a      	ldr	r2, [r7, #16]
10005b3a:	611a      	str	r2, [r3, #16]
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
10005b3c:	4b15      	ldr	r3, [pc, #84]	; (10005b94 <prvSwitchTimerLists+0xb4>)
10005b3e:	681a      	ldr	r2, [r3, #0]
10005b40:	693b      	ldr	r3, [r7, #16]
10005b42:	3304      	adds	r3, #4
10005b44:	1c10      	adds	r0, r2, #0
10005b46:	1c19      	adds	r1, r3, #0
10005b48:	f7fe fa2a 	bl	10003fa0 <vListInsert>
10005b4c:	e00f      	b.n	10005b6e <prvSwitchTimerLists+0x8e>
                }
                else
                {
                    xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
10005b4e:	6939      	ldr	r1, [r7, #16]
10005b50:	697a      	ldr	r2, [r7, #20]
10005b52:	2300      	movs	r3, #0
10005b54:	9300      	str	r3, [sp, #0]
10005b56:	1c08      	adds	r0, r1, #0
10005b58:	2100      	movs	r1, #0
10005b5a:	2300      	movs	r3, #0
10005b5c:	f7ff fd7a 	bl	10005654 <xTimerGenericCommand>
10005b60:	1c03      	adds	r3, r0, #0
10005b62:	60bb      	str	r3, [r7, #8]
                    configASSERT( xResult );
10005b64:	68bb      	ldr	r3, [r7, #8]
10005b66:	2b00      	cmp	r3, #0
10005b68:	d101      	bne.n	10005b6e <prvSwitchTimerLists+0x8e>
10005b6a:	b672      	cpsid	i
10005b6c:	e7fe      	b.n	10005b6c <prvSwitchTimerLists+0x8c>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
10005b6e:	4b09      	ldr	r3, [pc, #36]	; (10005b94 <prvSwitchTimerLists+0xb4>)
10005b70:	681b      	ldr	r3, [r3, #0]
10005b72:	681b      	ldr	r3, [r3, #0]
10005b74:	2b00      	cmp	r3, #0
10005b76:	d1b7      	bne.n	10005ae8 <prvSwitchTimerLists+0x8>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        pxTemp = pxCurrentTimerList;
10005b78:	4b06      	ldr	r3, [pc, #24]	; (10005b94 <prvSwitchTimerLists+0xb4>)
10005b7a:	681b      	ldr	r3, [r3, #0]
10005b7c:	607b      	str	r3, [r7, #4]
        pxCurrentTimerList = pxOverflowTimerList;
10005b7e:	4b06      	ldr	r3, [pc, #24]	; (10005b98 <prvSwitchTimerLists+0xb8>)
10005b80:	681a      	ldr	r2, [r3, #0]
10005b82:	4b04      	ldr	r3, [pc, #16]	; (10005b94 <prvSwitchTimerLists+0xb4>)
10005b84:	601a      	str	r2, [r3, #0]
        pxOverflowTimerList = pxTemp;
10005b86:	4b04      	ldr	r3, [pc, #16]	; (10005b98 <prvSwitchTimerLists+0xb8>)
10005b88:	687a      	ldr	r2, [r7, #4]
10005b8a:	601a      	str	r2, [r3, #0]
    }
10005b8c:	46bd      	mov	sp, r7
10005b8e:	b006      	add	sp, #24
10005b90:	bd80      	pop	{r7, pc}
10005b92:	46c0      	nop			; (mov r8, r8)
10005b94:	200007a8 	.word	0x200007a8
10005b98:	200007ac 	.word	0x200007ac

10005b9c <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
10005b9c:	b580      	push	{r7, lr}
10005b9e:	af00      	add	r7, sp, #0
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
10005ba0:	f7fe f8f8 	bl	10003d94 <vPortEnterCritical>
        {
            if( xTimerQueue == NULL )
10005ba4:	4b14      	ldr	r3, [pc, #80]	; (10005bf8 <prvCheckForValidListAndQueue+0x5c>)
10005ba6:	681b      	ldr	r3, [r3, #0]
10005ba8:	2b00      	cmp	r3, #0
10005baa:	d120      	bne.n	10005bee <prvCheckForValidListAndQueue+0x52>
            {
                vListInitialise( &xActiveTimerList1 );
10005bac:	4b13      	ldr	r3, [pc, #76]	; (10005bfc <prvCheckForValidListAndQueue+0x60>)
10005bae:	1c18      	adds	r0, r3, #0
10005bb0:	f7fe f9ac 	bl	10003f0c <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
10005bb4:	4b12      	ldr	r3, [pc, #72]	; (10005c00 <prvCheckForValidListAndQueue+0x64>)
10005bb6:	1c18      	adds	r0, r3, #0
10005bb8:	f7fe f9a8 	bl	10003f0c <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
10005bbc:	4b11      	ldr	r3, [pc, #68]	; (10005c04 <prvCheckForValidListAndQueue+0x68>)
10005bbe:	4a0f      	ldr	r2, [pc, #60]	; (10005bfc <prvCheckForValidListAndQueue+0x60>)
10005bc0:	601a      	str	r2, [r3, #0]
                pxOverflowTimerList = &xActiveTimerList2;
10005bc2:	4b11      	ldr	r3, [pc, #68]	; (10005c08 <prvCheckForValidListAndQueue+0x6c>)
10005bc4:	4a0e      	ldr	r2, [pc, #56]	; (10005c00 <prvCheckForValidListAndQueue+0x64>)
10005bc6:	601a      	str	r2, [r3, #0]

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
10005bc8:	2005      	movs	r0, #5
10005bca:	2110      	movs	r1, #16
10005bcc:	2200      	movs	r2, #0
10005bce:	f7fe fa99 	bl	10004104 <xQueueGenericCreate>
10005bd2:	1c02      	adds	r2, r0, #0
10005bd4:	4b08      	ldr	r3, [pc, #32]	; (10005bf8 <prvCheckForValidListAndQueue+0x5c>)
10005bd6:	601a      	str	r2, [r3, #0]
                    }
                #endif /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */

                #if ( configQUEUE_REGISTRY_SIZE > 0 )
                    {
                        if( xTimerQueue != NULL )
10005bd8:	4b07      	ldr	r3, [pc, #28]	; (10005bf8 <prvCheckForValidListAndQueue+0x5c>)
10005bda:	681b      	ldr	r3, [r3, #0]
10005bdc:	2b00      	cmp	r3, #0
10005bde:	d006      	beq.n	10005bee <prvCheckForValidListAndQueue+0x52>
                        {
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
10005be0:	4b05      	ldr	r3, [pc, #20]	; (10005bf8 <prvCheckForValidListAndQueue+0x5c>)
10005be2:	681a      	ldr	r2, [r3, #0]
10005be4:	4b09      	ldr	r3, [pc, #36]	; (10005c0c <prvCheckForValidListAndQueue+0x70>)
10005be6:	1c10      	adds	r0, r2, #0
10005be8:	1c19      	adds	r1, r3, #0
10005bea:	f7fe fe67 	bl	100048bc <vQueueAddToRegistry>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
10005bee:	f7fe f8e1 	bl	10003db4 <vPortExitCritical>
    }
10005bf2:	46bd      	mov	sp, r7
10005bf4:	bd80      	pop	{r7, pc}
10005bf6:	46c0      	nop			; (mov r8, r8)
10005bf8:	200007b0 	.word	0x200007b0
10005bfc:	20000780 	.word	0x20000780
10005c00:	20000794 	.word	0x20000794
10005c04:	200007a8 	.word	0x200007a8
10005c08:	200007ac 	.word	0x200007ac
10005c0c:	100067f0 	.word	0x100067f0

10005c10 <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
10005c10:	b580      	push	{r7, lr}
10005c12:	b082      	sub	sp, #8
10005c14:	af00      	add	r7, sp, #0
10005c16:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
10005c18:	687b      	ldr	r3, [r7, #4]
10005c1a:	6819      	ldr	r1, [r3, #0]
10005c1c:	687b      	ldr	r3, [r7, #4]
10005c1e:	7b1a      	ldrb	r2, [r3, #12]
10005c20:	687b      	ldr	r3, [r7, #4]
10005c22:	3304      	adds	r3, #4
10005c24:	1c08      	adds	r0, r1, #0
10005c26:	1c11      	adds	r1, r2, #0
10005c28:	1c1a      	adds	r2, r3, #0
10005c2a:	f7fb faad 	bl	10001188 <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
10005c2e:	687b      	ldr	r3, [r7, #4]
10005c30:	6819      	ldr	r1, [r3, #0]
10005c32:	687b      	ldr	r3, [r7, #4]
10005c34:	7b1a      	ldrb	r2, [r3, #12]
10005c36:	687b      	ldr	r3, [r7, #4]
10005c38:	7b5b      	ldrb	r3, [r3, #13]
10005c3a:	1c08      	adds	r0, r1, #0
10005c3c:	1c11      	adds	r1, r2, #0
10005c3e:	1c1a      	adds	r2, r3, #0
10005c40:	f7fc f890 	bl	10001d64 <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
10005c44:	2300      	movs	r3, #0
}
10005c46:	1c18      	adds	r0, r3, #0
10005c48:	46bd      	mov	sp, r7
10005c4a:	b002      	add	sp, #8
10005c4c:	bd80      	pop	{r7, pc}
10005c4e:	46c0      	nop			; (mov r8, r8)

10005c50 <SystemCoreSetup>:
{
  .initialized = false
};
 
void SystemCoreSetup(void)
{
10005c50:	b580      	push	{r7, lr}
10005c52:	af00      	add	r7, sp, #0
#if UC_SERIES == XMC14
  /* Enable Prefetch unit */
  SCU_GENERAL->PFUCR &= ~SCU_GENERAL_PFUCR_PFUBYP_Msk;
10005c54:	4b03      	ldr	r3, [pc, #12]	; (10005c64 <SystemCoreSetup+0x14>)
10005c56:	4a03      	ldr	r2, [pc, #12]	; (10005c64 <SystemCoreSetup+0x14>)
10005c58:	6e92      	ldr	r2, [r2, #104]	; 0x68
10005c5a:	2101      	movs	r1, #1
10005c5c:	438a      	bics	r2, r1
10005c5e:	669a      	str	r2, [r3, #104]	; 0x68
#endif
}
10005c60:	46bd      	mov	sp, r7
10005c62:	bd80      	pop	{r7, pc}
10005c64:	40010000 	.word	0x40010000

10005c68 <CLOCK_XMC1_Init>:

/*
 * API to initialize the CLOCK_XMC1 APP Interrupts
 */
CLOCK_XMC1_STATUS_t CLOCK_XMC1_Init(CLOCK_XMC1_t *handle)
{
10005c68:	b580      	push	{r7, lr}
10005c6a:	b084      	sub	sp, #16
10005c6c:	af00      	add	r7, sp, #0
10005c6e:	6078      	str	r0, [r7, #4]
  CLOCK_XMC1_STATUS_t status = CLOCK_XMC1_STATUS_SUCCESS;
10005c70:	230f      	movs	r3, #15
10005c72:	18fb      	adds	r3, r7, r3
10005c74:	2200      	movs	r2, #0
10005c76:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t loci_event_status = CLOCK_XMC1_STATUS_SUCCESS;
10005c78:	230e      	movs	r3, #14
10005c7a:	18fb      	adds	r3, r7, r3
10005c7c:	2200      	movs	r2, #0
10005c7e:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t stdbyclkfail_status = CLOCK_XMC1_STATUS_SUCCESS;
10005c80:	230d      	movs	r3, #13
10005c82:	18fb      	adds	r3, r7, r3
10005c84:	2200      	movs	r2, #0
10005c86:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t loss_ext_clock_event_status = CLOCK_XMC1_STATUS_SUCCESS;
10005c88:	230c      	movs	r3, #12
10005c8a:	18fb      	adds	r3, r7, r3
10005c8c:	2200      	movs	r2, #0
10005c8e:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t dco1_out_sync_status = CLOCK_XMC1_STATUS_SUCCESS;
10005c90:	230b      	movs	r3, #11
10005c92:	18fb      	adds	r3, r7, r3
10005c94:	2200      	movs	r2, #0
10005c96:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("CLOCK_XMC1_Init: CLOCK_XMC1 APP handle pointer uninitialized", (handle != NULL));

  if (handle->init_status == false)
10005c98:	687b      	ldr	r3, [r7, #4]
10005c9a:	781b      	ldrb	r3, [r3, #0]
10005c9c:	2201      	movs	r2, #1
10005c9e:	4053      	eors	r3, r2
10005ca0:	b2db      	uxtb	r3, r3
10005ca2:	2b00      	cmp	r3, #0
10005ca4:	d01b      	beq.n	10005cde <CLOCK_XMC1_Init+0x76>

#endif
    }

#endif
    status = (CLOCK_XMC1_STATUS_t)(((uint32_t)loci_event_status) | ((uint32_t)stdbyclkfail_status) |
10005ca6:	230e      	movs	r3, #14
10005ca8:	18fa      	adds	r2, r7, r3
10005caa:	230d      	movs	r3, #13
10005cac:	18fb      	adds	r3, r7, r3
10005cae:	7812      	ldrb	r2, [r2, #0]
10005cb0:	781b      	ldrb	r3, [r3, #0]
10005cb2:	4313      	orrs	r3, r2
10005cb4:	b2da      	uxtb	r2, r3
10005cb6:	230c      	movs	r3, #12
10005cb8:	18fb      	adds	r3, r7, r3
10005cba:	781b      	ldrb	r3, [r3, #0]
10005cbc:	4313      	orrs	r3, r2
10005cbe:	b2d9      	uxtb	r1, r3
10005cc0:	230f      	movs	r3, #15
10005cc2:	18fb      	adds	r3, r7, r3
10005cc4:	220b      	movs	r2, #11
10005cc6:	18ba      	adds	r2, r7, r2
10005cc8:	7812      	ldrb	r2, [r2, #0]
10005cca:	430a      	orrs	r2, r1
10005ccc:	701a      	strb	r2, [r3, #0]
    		                       ((uint32_t)loss_ext_clock_event_status) | ((uint32_t)dco1_out_sync_status));
    if (CLOCK_XMC1_STATUS_SUCCESS == status)
10005cce:	230f      	movs	r3, #15
10005cd0:	18fb      	adds	r3, r7, r3
10005cd2:	781b      	ldrb	r3, [r3, #0]
10005cd4:	2b00      	cmp	r3, #0
10005cd6:	d102      	bne.n	10005cde <CLOCK_XMC1_Init+0x76>
    {
      handle->init_status = true;
10005cd8:	687b      	ldr	r3, [r7, #4]
10005cda:	2201      	movs	r2, #1
10005cdc:	701a      	strb	r2, [r3, #0]
    }
  }
  return (status);
10005cde:	230f      	movs	r3, #15
10005ce0:	18fb      	adds	r3, r7, r3
10005ce2:	781b      	ldrb	r3, [r3, #0]
}
10005ce4:	1c18      	adds	r0, r3, #0
10005ce6:	46bd      	mov	sp, r7
10005ce8:	b004      	add	sp, #16
10005cea:	bd80      	pop	{r7, pc}

10005cec <SystemCoreClockSetup>:

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
void SystemCoreClockSetup(void)
{
10005cec:	b590      	push	{r4, r7, lr}
10005cee:	b085      	sub	sp, #20
10005cf0:	af00      	add	r7, sp, #0
/* LOCAL DATA STRUCTURES */
const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC1_0_CONFIG =
10005cf2:	1c3b      	adds	r3, r7, #0
10005cf4:	4a05      	ldr	r2, [pc, #20]	; (10005d0c <SystemCoreClockSetup+0x20>)
10005cf6:	ca13      	ldmia	r2!, {r0, r1, r4}
10005cf8:	c313      	stmia	r3!, {r0, r1, r4}
10005cfa:	6812      	ldr	r2, [r2, #0]
10005cfc:	601a      	str	r2, [r3, #0]
  .osclp_mode = XMC_SCU_CLOCK_OSCLP_MODE_DISABLED

};

  /* Configure FDIV, IDIV, PCLKSEL dividers*/
  XMC_SCU_CLOCK_Init(&CLOCK_XMC1_0_CONFIG);
10005cfe:	1c3b      	adds	r3, r7, #0
10005d00:	1c18      	adds	r0, r3, #0
10005d02:	f7fb fb19 	bl	10001338 <XMC_SCU_CLOCK_Init>
}
10005d06:	46bd      	mov	sp, r7
10005d08:	b005      	add	sp, #20
10005d0a:	bd90      	pop	{r4, r7, pc}
10005d0c:	10006850 	.word	0x10006850

10005d10 <XMC_CAN_NODE_SetEventNodePointer>:
 */

__STATIC_INLINE void XMC_CAN_NODE_SetEventNodePointer(XMC_CAN_NODE_t *const can_node,
    const XMC_CAN_NODE_POINTER_EVENT_t ptr_event,
    const uint32_t service_request)
{
10005d10:	b580      	push	{r7, lr}
10005d12:	b084      	sub	sp, #16
10005d14:	af00      	add	r7, sp, #0
10005d16:	60f8      	str	r0, [r7, #12]
10005d18:	607a      	str	r2, [r7, #4]
10005d1a:	230b      	movs	r3, #11
10005d1c:	18fb      	adds	r3, r7, r3
10005d1e:	1c0a      	adds	r2, r1, #0
10005d20:	701a      	strb	r2, [r3, #0]
  can_node->NIPR = (uint32_t)((can_node->NIPR) & ~(uint32_t)(CAN_NODE_NIPR_Msk << (uint32_t)ptr_event)) | (service_request << (uint32_t)ptr_event);
10005d22:	68fb      	ldr	r3, [r7, #12]
10005d24:	689b      	ldr	r3, [r3, #8]
10005d26:	220b      	movs	r2, #11
10005d28:	18ba      	adds	r2, r7, r2
10005d2a:	7812      	ldrb	r2, [r2, #0]
10005d2c:	2107      	movs	r1, #7
10005d2e:	4091      	lsls	r1, r2
10005d30:	1c0a      	adds	r2, r1, #0
10005d32:	43d2      	mvns	r2, r2
10005d34:	401a      	ands	r2, r3
10005d36:	230b      	movs	r3, #11
10005d38:	18fb      	adds	r3, r7, r3
10005d3a:	781b      	ldrb	r3, [r3, #0]
10005d3c:	6879      	ldr	r1, [r7, #4]
10005d3e:	4099      	lsls	r1, r3
10005d40:	1c0b      	adds	r3, r1, #0
10005d42:	431a      	orrs	r2, r3
10005d44:	68fb      	ldr	r3, [r7, #12]
10005d46:	609a      	str	r2, [r3, #8]
}
10005d48:	46bd      	mov	sp, r7
10005d4a:	b004      	add	sp, #16
10005d4c:	bd80      	pop	{r7, pc}
10005d4e:	46c0      	nop			; (mov r8, r8)

10005d50 <XMC_CAN_NODE_SetReceiveInput>:
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_SetReceiveInput(XMC_CAN_NODE_t *const can_node,
    const XMC_CAN_NODE_RECEIVE_INPUT_t input)
{
10005d50:	b580      	push	{r7, lr}
10005d52:	b082      	sub	sp, #8
10005d54:	af00      	add	r7, sp, #0
10005d56:	6078      	str	r0, [r7, #4]
10005d58:	1c0a      	adds	r2, r1, #0
10005d5a:	1cfb      	adds	r3, r7, #3
10005d5c:	701a      	strb	r2, [r3, #0]
  can_node->NPCR = ((can_node->NPCR) & ~(uint32_t)(CAN_NODE_NPCR_RXSEL_Msk)) |
10005d5e:	687b      	ldr	r3, [r7, #4]
10005d60:	68db      	ldr	r3, [r3, #12]
10005d62:	2207      	movs	r2, #7
10005d64:	4393      	bics	r3, r2
10005d66:	1c1a      	adds	r2, r3, #0
                   (((uint32_t)input << CAN_NODE_NPCR_RXSEL_Pos) & (uint32_t)CAN_NODE_NPCR_RXSEL_Msk);
10005d68:	1cfb      	adds	r3, r7, #3
10005d6a:	781b      	ldrb	r3, [r3, #0]
10005d6c:	2107      	movs	r1, #7
10005d6e:	400b      	ands	r3, r1
 */

__STATIC_INLINE void XMC_CAN_NODE_SetReceiveInput(XMC_CAN_NODE_t *const can_node,
    const XMC_CAN_NODE_RECEIVE_INPUT_t input)
{
  can_node->NPCR = ((can_node->NPCR) & ~(uint32_t)(CAN_NODE_NPCR_RXSEL_Msk)) |
10005d70:	431a      	orrs	r2, r3
10005d72:	687b      	ldr	r3, [r7, #4]
10005d74:	60da      	str	r2, [r3, #12]
                   (((uint32_t)input << CAN_NODE_NPCR_RXSEL_Pos) & (uint32_t)CAN_NODE_NPCR_RXSEL_Msk);
}
10005d76:	46bd      	mov	sp, r7
10005d78:	b002      	add	sp, #8
10005d7a:	bd80      	pop	{r7, pc}

10005d7c <XMC_CAN_NODE_EnableLoopBack>:
 *  NPCRx can be written only if bit NCRx.CCE is set.
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_EnableLoopBack(XMC_CAN_NODE_t *const can_node)
{
10005d7c:	b580      	push	{r7, lr}
10005d7e:	b082      	sub	sp, #8
10005d80:	af00      	add	r7, sp, #0
10005d82:	6078      	str	r0, [r7, #4]
  can_node->NPCR |= (uint32_t)CAN_NODE_NPCR_LBM_Msk;
10005d84:	687b      	ldr	r3, [r7, #4]
10005d86:	68db      	ldr	r3, [r3, #12]
10005d88:	2280      	movs	r2, #128	; 0x80
10005d8a:	0052      	lsls	r2, r2, #1
10005d8c:	431a      	orrs	r2, r3
10005d8e:	687b      	ldr	r3, [r7, #4]
10005d90:	60da      	str	r2, [r3, #12]
}
10005d92:	46bd      	mov	sp, r7
10005d94:	b002      	add	sp, #8
10005d96:	bd80      	pop	{r7, pc}

10005d98 <XMC_CAN_NODE_EnableConfigurationChange>:
 * XMC_CAN_NODE_DisableConfigurationChange()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_EnableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
10005d98:	b580      	push	{r7, lr}
10005d9a:	b082      	sub	sp, #8
10005d9c:	af00      	add	r7, sp, #0
10005d9e:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_CCE_Msk;
10005da0:	687b      	ldr	r3, [r7, #4]
10005da2:	681b      	ldr	r3, [r3, #0]
10005da4:	2240      	movs	r2, #64	; 0x40
10005da6:	431a      	orrs	r2, r3
10005da8:	687b      	ldr	r3, [r7, #4]
10005daa:	601a      	str	r2, [r3, #0]
}
10005dac:	46bd      	mov	sp, r7
10005dae:	b002      	add	sp, #8
10005db0:	bd80      	pop	{r7, pc}
10005db2:	46c0      	nop			; (mov r8, r8)

10005db4 <XMC_CAN_NODE_DisableConfigurationChange>:
 * XMC_CAN_NODE_EnableConfigurationChange()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_DisableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
10005db4:	b580      	push	{r7, lr}
10005db6:	b082      	sub	sp, #8
10005db8:	af00      	add	r7, sp, #0
10005dba:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CCE_Msk;
10005dbc:	687b      	ldr	r3, [r7, #4]
10005dbe:	681b      	ldr	r3, [r3, #0]
10005dc0:	2240      	movs	r2, #64	; 0x40
10005dc2:	4393      	bics	r3, r2
10005dc4:	1c1a      	adds	r2, r3, #0
10005dc6:	687b      	ldr	r3, [r7, #4]
10005dc8:	601a      	str	r2, [r3, #0]
}
10005dca:	46bd      	mov	sp, r7
10005dcc:	b002      	add	sp, #8
10005dce:	bd80      	pop	{r7, pc}

10005dd0 <XMC_CAN_NODE_SetInitBit>:
 * XMC_CAN_NODE_ResetInitBit()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_SetInitBit(XMC_CAN_NODE_t *const can_node)
{
10005dd0:	b580      	push	{r7, lr}
10005dd2:	b082      	sub	sp, #8
10005dd4:	af00      	add	r7, sp, #0
10005dd6:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_INIT_Msk;
10005dd8:	687b      	ldr	r3, [r7, #4]
10005dda:	681b      	ldr	r3, [r3, #0]
10005ddc:	2201      	movs	r2, #1
10005dde:	431a      	orrs	r2, r3
10005de0:	687b      	ldr	r3, [r7, #4]
10005de2:	601a      	str	r2, [r3, #0]
}
10005de4:	46bd      	mov	sp, r7
10005de6:	b002      	add	sp, #8
10005de8:	bd80      	pop	{r7, pc}
10005dea:	46c0      	nop			; (mov r8, r8)

10005dec <XMC_CAN_NODE_ResetInitBit>:
 * \par<b>Related API's:</b><br>
 * XMC_CAN_NODE_SetInitBit()
 *
 */
__STATIC_INLINE void XMC_CAN_NODE_ResetInitBit(XMC_CAN_NODE_t *const can_node)
{
10005dec:	b580      	push	{r7, lr}
10005dee:	b082      	sub	sp, #8
10005df0:	af00      	add	r7, sp, #0
10005df2:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_INIT_Msk;
10005df4:	687b      	ldr	r3, [r7, #4]
10005df6:	681b      	ldr	r3, [r3, #0]
10005df8:	2201      	movs	r2, #1
10005dfa:	4393      	bics	r3, r2
10005dfc:	1c1a      	adds	r2, r3, #0
10005dfe:	687b      	ldr	r3, [r7, #4]
10005e00:	601a      	str	r2, [r3, #0]
}
10005e02:	46bd      	mov	sp, r7
10005e04:	b002      	add	sp, #8
10005e06:	bd80      	pop	{r7, pc}

10005e08 <XMC_CAN_NODE_ReSetAnalyzerMode>:
 * XMC_CAN_NODE_SetAnalyzerMode()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_ReSetAnalyzerMode(XMC_CAN_NODE_t *const can_node)
{
10005e08:	b580      	push	{r7, lr}
10005e0a:	b082      	sub	sp, #8
10005e0c:	af00      	add	r7, sp, #0
10005e0e:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CALM_Msk;
10005e10:	687b      	ldr	r3, [r7, #4]
10005e12:	681b      	ldr	r3, [r3, #0]
10005e14:	2280      	movs	r2, #128	; 0x80
10005e16:	4393      	bics	r3, r2
10005e18:	1c1a      	adds	r2, r3, #0
10005e1a:	687b      	ldr	r3, [r7, #4]
10005e1c:	601a      	str	r2, [r3, #0]
}
10005e1e:	46bd      	mov	sp, r7
10005e20:	b002      	add	sp, #8
10005e22:	bd80      	pop	{r7, pc}

10005e24 <XMC_CAN_MO_SetEventNodePointer>:
 */

__STATIC_INLINE void XMC_CAN_MO_SetEventNodePointer(const XMC_CAN_MO_t *const can_mo,
    const XMC_CAN_MO_POINTER_EVENT_t can_mo_ptr_int,
    const uint32_t service_request)
{
10005e24:	b580      	push	{r7, lr}
10005e26:	b084      	sub	sp, #16
10005e28:	af00      	add	r7, sp, #0
10005e2a:	60f8      	str	r0, [r7, #12]
10005e2c:	607a      	str	r2, [r7, #4]
10005e2e:	230b      	movs	r3, #11
10005e30:	18fb      	adds	r3, r7, r3
10005e32:	1c0a      	adds	r2, r1, #0
10005e34:	701a      	strb	r2, [r3, #0]
  can_mo->can_mo_ptr->MOIPR = ((can_mo->can_mo_ptr->MOIPR ) & ~(uint32_t)((uint32_t)CAN_MO_MOIPR_Msk << (uint32_t)can_mo_ptr_int)) |
10005e36:	68fb      	ldr	r3, [r7, #12]
10005e38:	681b      	ldr	r3, [r3, #0]
10005e3a:	68fa      	ldr	r2, [r7, #12]
10005e3c:	6812      	ldr	r2, [r2, #0]
10005e3e:	6892      	ldr	r2, [r2, #8]
10005e40:	210b      	movs	r1, #11
10005e42:	1879      	adds	r1, r7, r1
10005e44:	7809      	ldrb	r1, [r1, #0]
10005e46:	2007      	movs	r0, #7
10005e48:	4088      	lsls	r0, r1
10005e4a:	1c01      	adds	r1, r0, #0
10005e4c:	43c9      	mvns	r1, r1
10005e4e:	4011      	ands	r1, r2
                              (service_request << (uint32_t)can_mo_ptr_int);
10005e50:	220b      	movs	r2, #11
10005e52:	18ba      	adds	r2, r7, r2
10005e54:	7812      	ldrb	r2, [r2, #0]
10005e56:	6878      	ldr	r0, [r7, #4]
10005e58:	4090      	lsls	r0, r2
10005e5a:	1c02      	adds	r2, r0, #0

__STATIC_INLINE void XMC_CAN_MO_SetEventNodePointer(const XMC_CAN_MO_t *const can_mo,
    const XMC_CAN_MO_POINTER_EVENT_t can_mo_ptr_int,
    const uint32_t service_request)
{
  can_mo->can_mo_ptr->MOIPR = ((can_mo->can_mo_ptr->MOIPR ) & ~(uint32_t)((uint32_t)CAN_MO_MOIPR_Msk << (uint32_t)can_mo_ptr_int)) |
10005e5c:	430a      	orrs	r2, r1
10005e5e:	609a      	str	r2, [r3, #8]
                              (service_request << (uint32_t)can_mo_ptr_int);
}
10005e60:	46bd      	mov	sp, r7
10005e62:	b004      	add	sp, #16
10005e64:	bd80      	pop	{r7, pc}
10005e66:	46c0      	nop			; (mov r8, r8)

10005e68 <XMC_CAN_MO_EnableEvent>:
 *
 */

__STATIC_INLINE void XMC_CAN_MO_EnableEvent(const XMC_CAN_MO_t *const can_mo,
    const uint32_t event)
{
10005e68:	b580      	push	{r7, lr}
10005e6a:	b082      	sub	sp, #8
10005e6c:	af00      	add	r7, sp, #0
10005e6e:	6078      	str	r0, [r7, #4]
10005e70:	6039      	str	r1, [r7, #0]
  can_mo->can_mo_ptr->MOFCR |= event;
10005e72:	687b      	ldr	r3, [r7, #4]
10005e74:	681b      	ldr	r3, [r3, #0]
10005e76:	687a      	ldr	r2, [r7, #4]
10005e78:	6812      	ldr	r2, [r2, #0]
10005e7a:	6811      	ldr	r1, [r2, #0]
10005e7c:	683a      	ldr	r2, [r7, #0]
10005e7e:	430a      	orrs	r2, r1
10005e80:	601a      	str	r2, [r3, #0]
}
10005e82:	46bd      	mov	sp, r7
10005e84:	b002      	add	sp, #8
10005e86:	bd80      	pop	{r7, pc}

10005e88 <CAN_NODE_MO_EnableTxEvent>:
 *   return (1);
 * }
 * @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_EnableTxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
10005e88:	b580      	push	{r7, lr}
10005e8a:	b082      	sub	sp, #8
10005e8c:	af00      	add	r7, sp, #0
10005e8e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_EnableTxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_EnableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_TRANSMIT);
10005e90:	687b      	ldr	r3, [r7, #4]
10005e92:	681a      	ldr	r2, [r3, #0]
10005e94:	2380      	movs	r3, #128	; 0x80
10005e96:	029b      	lsls	r3, r3, #10
10005e98:	1c10      	adds	r0, r2, #0
10005e9a:	1c19      	adds	r1, r3, #0
10005e9c:	f7ff ffe4 	bl	10005e68 <XMC_CAN_MO_EnableEvent>
}
10005ea0:	46bd      	mov	sp, r7
10005ea2:	b002      	add	sp, #8
10005ea4:	bd80      	pop	{r7, pc}
10005ea6:	46c0      	nop			; (mov r8, r8)

10005ea8 <CAN_NODE_MO_EnableRxEvent>:
 *   return (1);
 * }
 * @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_EnableRxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
10005ea8:	b580      	push	{r7, lr}
10005eaa:	b082      	sub	sp, #8
10005eac:	af00      	add	r7, sp, #0
10005eae:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_EnableRxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_EnableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_RECEIVE);
10005eb0:	687b      	ldr	r3, [r7, #4]
10005eb2:	681a      	ldr	r2, [r3, #0]
10005eb4:	2380      	movs	r3, #128	; 0x80
10005eb6:	025b      	lsls	r3, r3, #9
10005eb8:	1c10      	adds	r0, r2, #0
10005eba:	1c19      	adds	r1, r3, #0
10005ebc:	f7ff ffd4 	bl	10005e68 <XMC_CAN_MO_EnableEvent>
}
10005ec0:	46bd      	mov	sp, r7
10005ec2:	b002      	add	sp, #8
10005ec4:	bd80      	pop	{r7, pc}
10005ec6:	46c0      	nop			; (mov r8, r8)

10005ec8 <CAN_NODE_SetNodeEvents>:
  * @param  handle is a pointer pointing to APP data structure.
  * @return None
  */

static void CAN_NODE_SetNodeEvents(const CAN_NODE_t *handle)
{
10005ec8:	b580      	push	{r7, lr}
10005eca:	b084      	sub	sp, #16
10005ecc:	af00      	add	r7, sp, #0
10005ece:	6078      	str	r0, [r7, #4]
  uint32_t lnode_event = 0U;
10005ed0:	2300      	movs	r3, #0
10005ed2:	60fb      	str	r3, [r7, #12]

  XMC_ASSERT("CAN_NODE_lInit: handle null", handle != NULL);

  CAN_NODE_SetNodePointer(handle); /* set node service pointer */
10005ed4:	687b      	ldr	r3, [r7, #4]
10005ed6:	1c18      	adds	r0, r3, #0
10005ed8:	f000 f832 	bl	10005f40 <CAN_NODE_SetNodePointer>

  if (handle->txok_event_enable == true)
10005edc:	687b      	ldr	r3, [r7, #4]
10005ede:	22a4      	movs	r2, #164	; 0xa4
10005ee0:	5c9b      	ldrb	r3, [r3, r2]
10005ee2:	2b00      	cmp	r3, #0
10005ee4:	d003      	beq.n	10005eee <CAN_NODE_SetNodeEvents+0x26>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_TX_INT;
10005ee6:	68fb      	ldr	r3, [r7, #12]
10005ee8:	2202      	movs	r2, #2
10005eea:	4313      	orrs	r3, r2
10005eec:	60fb      	str	r3, [r7, #12]
  }
  if (handle->lec_event_enable == true)
10005eee:	687b      	ldr	r3, [r7, #4]
10005ef0:	22a3      	movs	r2, #163	; 0xa3
10005ef2:	5c9b      	ldrb	r3, [r3, r2]
10005ef4:	2b00      	cmp	r3, #0
10005ef6:	d003      	beq.n	10005f00 <CAN_NODE_SetNodeEvents+0x38>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_LEC;
10005ef8:	68fb      	ldr	r3, [r7, #12]
10005efa:	2204      	movs	r2, #4
10005efc:	4313      	orrs	r3, r2
10005efe:	60fb      	str	r3, [r7, #12]
  }
  if (handle->alert_event_enable == true)
10005f00:	687b      	ldr	r3, [r7, #4]
10005f02:	22a5      	movs	r2, #165	; 0xa5
10005f04:	5c9b      	ldrb	r3, [r3, r2]
10005f06:	2b00      	cmp	r3, #0
10005f08:	d003      	beq.n	10005f12 <CAN_NODE_SetNodeEvents+0x4a>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_ALERT;
10005f0a:	68fb      	ldr	r3, [r7, #12]
10005f0c:	2208      	movs	r2, #8
10005f0e:	4313      	orrs	r3, r2
10005f10:	60fb      	str	r3, [r7, #12]
  }
  XMC_CAN_NODE_EnableEvent(handle->node_ptr, (XMC_CAN_NODE_EVENT_t)lnode_event);
10005f12:	687b      	ldr	r3, [r7, #4]
10005f14:	685a      	ldr	r2, [r3, #4]
10005f16:	68fb      	ldr	r3, [r7, #12]
10005f18:	1c10      	adds	r0, r2, #0
10005f1a:	1c19      	adds	r1, r3, #0
10005f1c:	f7fb ff08 	bl	10001d30 <XMC_CAN_NODE_EnableEvent>

  if (handle->framecount_event_enable == true)
10005f20:	687b      	ldr	r3, [r7, #4]
10005f22:	22a6      	movs	r2, #166	; 0xa6
10005f24:	5c9b      	ldrb	r3, [r3, r2]
10005f26:	2b00      	cmp	r3, #0
10005f28:	d007      	beq.n	10005f3a <CAN_NODE_SetNodeEvents+0x72>
  {
    XMC_CAN_NODE_EnableEvent(handle->node_ptr, XMC_CAN_NODE_EVENT_CFCIE);
10005f2a:	687b      	ldr	r3, [r7, #4]
10005f2c:	685a      	ldr	r2, [r3, #4]
10005f2e:	2380      	movs	r3, #128	; 0x80
10005f30:	03db      	lsls	r3, r3, #15
10005f32:	1c10      	adds	r0, r2, #0
10005f34:	1c19      	adds	r1, r3, #0
10005f36:	f7fb fefb 	bl	10001d30 <XMC_CAN_NODE_EnableEvent>
  }

}
10005f3a:	46bd      	mov	sp, r7
10005f3c:	b004      	add	sp, #16
10005f3e:	bd80      	pop	{r7, pc}

10005f40 <CAN_NODE_SetNodePointer>:
  * @brief  Function to set the Node event pointer
  *
  */

static void CAN_NODE_SetNodePointer(const CAN_NODE_t *handle)
{
10005f40:	b580      	push	{r7, lr}
10005f42:	b082      	sub	sp, #8
10005f44:	af00      	add	r7, sp, #0
10005f46:	6078      	str	r0, [r7, #4]

  XMC_ASSERT("CAN_NODE_SetNodePointer: handle null", handle != NULL);

  /* Configured the node event pointer for the alert event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_ALERT,
10005f48:	687b      	ldr	r3, [r7, #4]
10005f4a:	6859      	ldr	r1, [r3, #4]
                                                        handle->node_sr_ptr->alert_event_sr);
10005f4c:	687b      	ldr	r3, [r7, #4]
10005f4e:	228c      	movs	r2, #140	; 0x8c
10005f50:	589b      	ldr	r3, [r3, r2]
10005f52:	781b      	ldrb	r3, [r3, #0]
{

  XMC_ASSERT("CAN_NODE_SetNodePointer: handle null", handle != NULL);

  /* Configured the node event pointer for the alert event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_ALERT,
10005f54:	1c08      	adds	r0, r1, #0
10005f56:	2100      	movs	r1, #0
10005f58:	1c1a      	adds	r2, r3, #0
10005f5a:	f7ff fed9 	bl	10005d10 <XMC_CAN_NODE_SetEventNodePointer>
                                                        handle->node_sr_ptr->alert_event_sr);
  /* Configured the node event pointer for the LEC event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_LEC,
10005f5e:	687b      	ldr	r3, [r7, #4]
10005f60:	6859      	ldr	r1, [r3, #4]
                                                         handle->node_sr_ptr->lec_event_sr);
10005f62:	687b      	ldr	r3, [r7, #4]
10005f64:	228c      	movs	r2, #140	; 0x8c
10005f66:	589b      	ldr	r3, [r3, r2]
10005f68:	785b      	ldrb	r3, [r3, #1]

  /* Configured the node event pointer for the alert event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_ALERT,
                                                        handle->node_sr_ptr->alert_event_sr);
  /* Configured the node event pointer for the LEC event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_LEC,
10005f6a:	1c08      	adds	r0, r1, #0
10005f6c:	2104      	movs	r1, #4
10005f6e:	1c1a      	adds	r2, r3, #0
10005f70:	f7ff fece 	bl	10005d10 <XMC_CAN_NODE_SetEventNodePointer>
                                                         handle->node_sr_ptr->lec_event_sr);
  /* Configured the node event pointer for the TXOK event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_TRANSFER_OK,
10005f74:	687b      	ldr	r3, [r7, #4]
10005f76:	6859      	ldr	r1, [r3, #4]
                                                               handle->node_sr_ptr->txok_event_sr);
10005f78:	687b      	ldr	r3, [r7, #4]
10005f7a:	228c      	movs	r2, #140	; 0x8c
10005f7c:	589b      	ldr	r3, [r3, r2]
10005f7e:	789b      	ldrb	r3, [r3, #2]
                                                        handle->node_sr_ptr->alert_event_sr);
  /* Configured the node event pointer for the LEC event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_LEC,
                                                         handle->node_sr_ptr->lec_event_sr);
  /* Configured the node event pointer for the TXOK event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_TRANSFER_OK,
10005f80:	1c08      	adds	r0, r1, #0
10005f82:	2108      	movs	r1, #8
10005f84:	1c1a      	adds	r2, r3, #0
10005f86:	f7ff fec3 	bl	10005d10 <XMC_CAN_NODE_SetEventNodePointer>
                                                               handle->node_sr_ptr->txok_event_sr);
  /* Configured the node event pointer for the Frame counter event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_FRAME_COUNTER,
10005f8a:	687b      	ldr	r3, [r7, #4]
10005f8c:	6859      	ldr	r1, [r3, #4]
                                                             handle->node_sr_ptr->framecount_event_sr);
10005f8e:	687b      	ldr	r3, [r7, #4]
10005f90:	228c      	movs	r2, #140	; 0x8c
10005f92:	589b      	ldr	r3, [r3, r2]
10005f94:	78db      	ldrb	r3, [r3, #3]
                                                         handle->node_sr_ptr->lec_event_sr);
  /* Configured the node event pointer for the TXOK event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_TRANSFER_OK,
                                                               handle->node_sr_ptr->txok_event_sr);
  /* Configured the node event pointer for the Frame counter event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_FRAME_COUNTER,
10005f96:	1c08      	adds	r0, r1, #0
10005f98:	210c      	movs	r1, #12
10005f9a:	1c1a      	adds	r2, r3, #0
10005f9c:	f7ff feb8 	bl	10005d10 <XMC_CAN_NODE_SetEventNodePointer>
                                                             handle->node_sr_ptr->framecount_event_sr);

}
10005fa0:	46bd      	mov	sp, r7
10005fa2:	b002      	add	sp, #8
10005fa4:	bd80      	pop	{r7, pc}
10005fa6:	46c0      	nop			; (mov r8, r8)

10005fa8 <CAN_NODE_MO_Init>:
  XMC_CAN_NODE_NominalBitTimeConfigure(can_node, can_bit_time);
}

/*  Function to initialize the CAN MO based on UI configuration. */
void CAN_NODE_MO_Init(const CAN_NODE_LMO_t *lmo_ptr)
{
10005fa8:	b580      	push	{r7, lr}
10005faa:	b082      	sub	sp, #8
10005fac:	af00      	add	r7, sp, #0
10005fae:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_Init: lmo_ptr null", lmo_ptr != NULL);

  XMC_CAN_MO_Config(lmo_ptr->mo_ptr);
10005fb0:	687b      	ldr	r3, [r7, #4]
10005fb2:	681b      	ldr	r3, [r3, #0]
10005fb4:	1c18      	adds	r0, r3, #0
10005fb6:	f7fb fda1 	bl	10001afc <XMC_CAN_MO_Config>

  if (lmo_ptr->tx_event_enable == true)
10005fba:	687b      	ldr	r3, [r7, #4]
10005fbc:	79db      	ldrb	r3, [r3, #7]
10005fbe:	2b00      	cmp	r3, #0
10005fc0:	d00c      	beq.n	10005fdc <CAN_NODE_MO_Init+0x34>
  {
    XMC_CAN_MO_SetEventNodePointer(lmo_ptr->mo_ptr, XMC_CAN_MO_POINTER_EVENT_TRANSMIT, lmo_ptr->tx_sr);
10005fc2:	687b      	ldr	r3, [r7, #4]
10005fc4:	681a      	ldr	r2, [r3, #0]
10005fc6:	687b      	ldr	r3, [r7, #4]
10005fc8:	795b      	ldrb	r3, [r3, #5]
10005fca:	1c10      	adds	r0, r2, #0
10005fcc:	2104      	movs	r1, #4
10005fce:	1c1a      	adds	r2, r3, #0
10005fd0:	f7ff ff28 	bl	10005e24 <XMC_CAN_MO_SetEventNodePointer>
    CAN_NODE_MO_EnableTxEvent(lmo_ptr);
10005fd4:	687b      	ldr	r3, [r7, #4]
10005fd6:	1c18      	adds	r0, r3, #0
10005fd8:	f7ff ff56 	bl	10005e88 <CAN_NODE_MO_EnableTxEvent>
  }
  if (lmo_ptr->rx_event_enable == true)
10005fdc:	687b      	ldr	r3, [r7, #4]
10005fde:	7a1b      	ldrb	r3, [r3, #8]
10005fe0:	2b00      	cmp	r3, #0
10005fe2:	d00c      	beq.n	10005ffe <CAN_NODE_MO_Init+0x56>
  {
    XMC_CAN_MO_SetEventNodePointer(lmo_ptr->mo_ptr, XMC_CAN_MO_POINTER_EVENT_RECEIVE, lmo_ptr->rx_sr);
10005fe4:	687b      	ldr	r3, [r7, #4]
10005fe6:	681a      	ldr	r2, [r3, #0]
10005fe8:	687b      	ldr	r3, [r7, #4]
10005fea:	799b      	ldrb	r3, [r3, #6]
10005fec:	1c10      	adds	r0, r2, #0
10005fee:	2100      	movs	r1, #0
10005ff0:	1c1a      	adds	r2, r3, #0
10005ff2:	f7ff ff17 	bl	10005e24 <XMC_CAN_MO_SetEventNodePointer>
    CAN_NODE_MO_EnableRxEvent(lmo_ptr);
10005ff6:	687b      	ldr	r3, [r7, #4]
10005ff8:	1c18      	adds	r0, r3, #0
10005ffa:	f7ff ff55 	bl	10005ea8 <CAN_NODE_MO_EnableRxEvent>
  }

}
10005ffe:	46bd      	mov	sp, r7
10006000:	b002      	add	sp, #8
10006002:	bd80      	pop	{r7, pc}

10006004 <CAN_NODE_MO_Transmit>:

/* Function to transmit the can MO frame.  */
CAN_NODE_STATUS_t CAN_NODE_MO_Transmit(const CAN_NODE_LMO_t *lmo_ptr)
{
10006004:	b590      	push	{r4, r7, lr}
10006006:	b085      	sub	sp, #20
10006008:	af00      	add	r7, sp, #0
1000600a:	6078      	str	r0, [r7, #4]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
1000600c:	230f      	movs	r3, #15
1000600e:	18fb      	adds	r3, r7, r3
10006010:	2200      	movs	r2, #0
10006012:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("CAN_NODE_MO_Transmit: lmo_ptr null", lmo_ptr != NULL);

  status = (CAN_NODE_STATUS_t)XMC_CAN_MO_Transmit(lmo_ptr->mo_ptr);
10006014:	687b      	ldr	r3, [r7, #4]
10006016:	681b      	ldr	r3, [r3, #0]
10006018:	220f      	movs	r2, #15
1000601a:	18bc      	adds	r4, r7, r2
1000601c:	1c18      	adds	r0, r3, #0
1000601e:	f7fb fe4f 	bl	10001cc0 <XMC_CAN_MO_Transmit>
10006022:	1c03      	adds	r3, r0, #0
10006024:	7023      	strb	r3, [r4, #0]
  return (status);
10006026:	230f      	movs	r3, #15
10006028:	18fb      	adds	r3, r7, r3
1000602a:	781b      	ldrb	r3, [r3, #0]
}
1000602c:	1c18      	adds	r0, r3, #0
1000602e:	46bd      	mov	sp, r7
10006030:	b005      	add	sp, #20
10006032:	bd90      	pop	{r4, r7, pc}

10006034 <CAN_NODE_MO_UpdateData>:
  return (status);
}

/* Function to updates the data for the CAN Message Object. */
CAN_NODE_STATUS_t CAN_NODE_MO_UpdateData(const CAN_NODE_LMO_t *const lmo_ptr, uint8_t *array_data)
{
10006034:	b590      	push	{r4, r7, lr}
10006036:	b085      	sub	sp, #20
10006038:	af00      	add	r7, sp, #0
1000603a:	6078      	str	r0, [r7, #4]
1000603c:	6039      	str	r1, [r7, #0]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
1000603e:	230f      	movs	r3, #15
10006040:	18fb      	adds	r3, r7, r3
10006042:	2200      	movs	r2, #0
10006044:	701a      	strb	r2, [r3, #0]
  uint32_t *data_pointer = (uint32_t*) array_data;
10006046:	683b      	ldr	r3, [r7, #0]
10006048:	60bb      	str	r3, [r7, #8]

  XMC_ASSERT("CAN_NODE_MO_UpdateData: lmo_ptr null", lmo_ptr != NULL);

  lmo_ptr->mo_ptr->can_data[0U] = *data_pointer;
1000604a:	687b      	ldr	r3, [r7, #4]
1000604c:	681b      	ldr	r3, [r3, #0]
1000604e:	68ba      	ldr	r2, [r7, #8]
10006050:	6812      	ldr	r2, [r2, #0]
10006052:	611a      	str	r2, [r3, #16]
  lmo_ptr->mo_ptr->can_data[1U] = *(data_pointer + 1U);
10006054:	687b      	ldr	r3, [r7, #4]
10006056:	681b      	ldr	r3, [r3, #0]
10006058:	68ba      	ldr	r2, [r7, #8]
1000605a:	6852      	ldr	r2, [r2, #4]
1000605c:	615a      	str	r2, [r3, #20]

  status = (CAN_NODE_STATUS_t)XMC_CAN_MO_UpdateData(lmo_ptr->mo_ptr);
1000605e:	687b      	ldr	r3, [r7, #4]
10006060:	681b      	ldr	r3, [r3, #0]
10006062:	220f      	movs	r2, #15
10006064:	18bc      	adds	r4, r7, r2
10006066:	1c18      	adds	r0, r3, #0
10006068:	f7fb fde8 	bl	10001c3c <XMC_CAN_MO_UpdateData>
1000606c:	1c03      	adds	r3, r0, #0
1000606e:	7023      	strb	r3, [r4, #0]
  return (status);
10006070:	230f      	movs	r3, #15
10006072:	18fb      	adds	r3, r7, r3
10006074:	781b      	ldrb	r3, [r3, #0]
}
10006076:	1c18      	adds	r0, r3, #0
10006078:	46bd      	mov	sp, r7
1000607a:	b005      	add	sp, #20
1000607c:	bd90      	pop	{r4, r7, pc}
1000607e:	46c0      	nop			; (mov r8, r8)

10006080 <CAN_NODE_Init>:
/*  Function to initialize the CAN node by configuring the baud rate, can bus type (External or internal)
 *  and message objects.
 */

CAN_NODE_STATUS_t CAN_NODE_Init(const CAN_NODE_t* handle)
{
10006080:	b590      	push	{r4, r7, lr}
10006082:	b087      	sub	sp, #28
10006084:	af00      	add	r7, sp, #0
10006086:	6078      	str	r0, [r7, #4]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
10006088:	2317      	movs	r3, #23
1000608a:	18fb      	adds	r3, r7, r3
1000608c:	2200      	movs	r2, #0
1000608e:	701a      	strb	r2, [r3, #0]
  uint32_t loop_count;
  const CAN_NODE_LMO_t *lmo_ptr;

  XMC_ASSERT("CAN_NODE_Init: handle null", handle != NULL);

  const CAN_NODE_GPIO_t *const lgpio_ptr = handle->gpio_out;
10006090:	687b      	ldr	r3, [r7, #4]
10006092:	2290      	movs	r2, #144	; 0x90
10006094:	589b      	ldr	r3, [r3, r2]
10006096:	60fb      	str	r3, [r7, #12]

  /* Initialize the GLOBAL_CAN APP */
  status  = (CAN_NODE_STATUS_t)GLOBAL_CAN_Init(handle->global_ptr);
10006098:	687b      	ldr	r3, [r7, #4]
1000609a:	681b      	ldr	r3, [r3, #0]
1000609c:	2217      	movs	r2, #23
1000609e:	18bc      	adds	r4, r7, r2
100060a0:	1c18      	adds	r0, r3, #0
100060a2:	f7fd fdb9 	bl	10003c18 <GLOBAL_CAN_Init>
100060a6:	1c03      	adds	r3, r0, #0
100060a8:	7023      	strb	r3, [r4, #0]

  if (status == CAN_NODE_STATUS_SUCCESS)
100060aa:	2317      	movs	r3, #23
100060ac:	18fb      	adds	r3, r7, r3
100060ae:	781b      	ldrb	r3, [r3, #0]
100060b0:	2b00      	cmp	r3, #0
100060b2:	d000      	beq.n	100060b6 <CAN_NODE_Init+0x36>
100060b4:	e085      	b.n	100061c2 <CAN_NODE_Init+0x142>
  {
    /* Initialize the GUI configured values for baud rate to NBTR Reg */
    if (XMC_CAN_NODE_NominalBitTimeConfigureEx(handle->node_ptr, handle->baudrate_config) == XMC_CAN_STATUS_SUCCESS)
100060b6:	687b      	ldr	r3, [r7, #4]
100060b8:	685a      	ldr	r2, [r3, #4]
100060ba:	687b      	ldr	r3, [r7, #4]
100060bc:	689b      	ldr	r3, [r3, #8]
100060be:	1c10      	adds	r0, r2, #0
100060c0:	1c19      	adds	r1, r3, #0
100060c2:	f7fb fb8f 	bl	100017e4 <XMC_CAN_NODE_NominalBitTimeConfigureEx>
100060c6:	1e03      	subs	r3, r0, #0
100060c8:	d176      	bne.n	100061b8 <CAN_NODE_Init+0x138>
    {
      /* set CCE and INIT bit NCR for node configuration */

      XMC_CAN_NODE_EnableConfigurationChange(handle->node_ptr);
100060ca:	687b      	ldr	r3, [r7, #4]
100060cc:	685b      	ldr	r3, [r3, #4]
100060ce:	1c18      	adds	r0, r3, #0
100060d0:	f7ff fe62 	bl	10005d98 <XMC_CAN_NODE_EnableConfigurationChange>
      XMC_CAN_NODE_SetInitBit(handle->node_ptr);
100060d4:	687b      	ldr	r3, [r7, #4]
100060d6:	685b      	ldr	r3, [r3, #4]
100060d8:	1c18      	adds	r0, r3, #0
100060da:	f7ff fe79 	bl	10005dd0 <XMC_CAN_NODE_SetInitBit>
      XMC_CAN_NODE_ReSetAnalyzerMode(handle->node_ptr);
100060de:	687b      	ldr	r3, [r7, #4]
100060e0:	685b      	ldr	r3, [r3, #4]
100060e2:	1c18      	adds	r0, r3, #0
100060e4:	f7ff fe90 	bl	10005e08 <XMC_CAN_NODE_ReSetAnalyzerMode>

      if (handle->loopback_enable == true) /* Loop back mode enabled */
100060e8:	687b      	ldr	r3, [r7, #4]
100060ea:	22a7      	movs	r2, #167	; 0xa7
100060ec:	5c9b      	ldrb	r3, [r3, r2]
100060ee:	2b00      	cmp	r3, #0
100060f0:	d005      	beq.n	100060fe <CAN_NODE_Init+0x7e>
      {
        XMC_CAN_NODE_EnableLoopBack(handle->node_ptr);
100060f2:	687b      	ldr	r3, [r7, #4]
100060f4:	685b      	ldr	r3, [r3, #4]
100060f6:	1c18      	adds	r0, r3, #0
100060f8:	f7ff fe40 	bl	10005d7c <XMC_CAN_NODE_EnableLoopBack>
100060fc:	e016      	b.n	1000612c <CAN_NODE_Init+0xac>
      }
      else
      {
        XMC_GPIO_Init(handle->gpio_in->port, handle->gpio_in->pin, handle->gpio_in_config);
100060fe:	687b      	ldr	r3, [r7, #4]
10006100:	2298      	movs	r2, #152	; 0x98
10006102:	589b      	ldr	r3, [r3, r2]
10006104:	6818      	ldr	r0, [r3, #0]
10006106:	687b      	ldr	r3, [r7, #4]
10006108:	2298      	movs	r2, #152	; 0x98
1000610a:	589b      	ldr	r3, [r3, r2]
1000610c:	7919      	ldrb	r1, [r3, #4]
1000610e:	687b      	ldr	r3, [r7, #4]
10006110:	229c      	movs	r2, #156	; 0x9c
10006112:	589b      	ldr	r3, [r3, r2]
10006114:	1c1a      	adds	r2, r3, #0
10006116:	f7fb f837 	bl	10001188 <XMC_GPIO_Init>
        XMC_CAN_NODE_SetReceiveInput(handle->node_ptr, handle->rx_signal);
1000611a:	687b      	ldr	r3, [r7, #4]
1000611c:	6859      	ldr	r1, [r3, #4]
1000611e:	687b      	ldr	r3, [r7, #4]
10006120:	22a0      	movs	r2, #160	; 0xa0
10006122:	5c9b      	ldrb	r3, [r3, r2]
10006124:	1c08      	adds	r0, r1, #0
10006126:	1c19      	adds	r1, r3, #0
10006128:	f7ff fe12 	bl	10005d50 <XMC_CAN_NODE_SetReceiveInput>
      }
      CAN_NODE_SetNodeEvents(handle); /* API to enable node events */
1000612c:	687b      	ldr	r3, [r7, #4]
1000612e:	1c18      	adds	r0, r3, #0
10006130:	f7ff feca 	bl	10005ec8 <CAN_NODE_SetNodeEvents>

      for (loop_count = 0U; loop_count < handle->mo_count; loop_count++)
10006134:	2300      	movs	r3, #0
10006136:	613b      	str	r3, [r7, #16]
10006138:	e01a      	b.n	10006170 <CAN_NODE_Init+0xf0>
      {
        lmo_ptr = handle->lmobj_ptr[loop_count];
1000613a:	687a      	ldr	r2, [r7, #4]
1000613c:	693b      	ldr	r3, [r7, #16]
1000613e:	3302      	adds	r3, #2
10006140:	009b      	lsls	r3, r3, #2
10006142:	18d3      	adds	r3, r2, r3
10006144:	685b      	ldr	r3, [r3, #4]
10006146:	60bb      	str	r3, [r7, #8]
        XMC_CAN_AllocateMOtoNodeList(handle->global_ptr->canglobal_ptr, handle->node_num, lmo_ptr->number);
10006148:	687b      	ldr	r3, [r7, #4]
1000614a:	681b      	ldr	r3, [r3, #0]
1000614c:	6859      	ldr	r1, [r3, #4]
1000614e:	687b      	ldr	r3, [r7, #4]
10006150:	22a1      	movs	r2, #161	; 0xa1
10006152:	5c9a      	ldrb	r2, [r3, r2]
10006154:	68bb      	ldr	r3, [r7, #8]
10006156:	791b      	ldrb	r3, [r3, #4]
10006158:	1c08      	adds	r0, r1, #0
1000615a:	1c11      	adds	r1, r2, #0
1000615c:	1c1a      	adds	r2, r3, #0
1000615e:	f7fb fbef 	bl	10001940 <XMC_CAN_AllocateMOtoNodeList>
        CAN_NODE_MO_Init(lmo_ptr);
10006162:	68bb      	ldr	r3, [r7, #8]
10006164:	1c18      	adds	r0, r3, #0
10006166:	f7ff ff1f 	bl	10005fa8 <CAN_NODE_MO_Init>
        XMC_GPIO_Init(handle->gpio_in->port, handle->gpio_in->pin, handle->gpio_in_config);
        XMC_CAN_NODE_SetReceiveInput(handle->node_ptr, handle->rx_signal);
      }
      CAN_NODE_SetNodeEvents(handle); /* API to enable node events */

      for (loop_count = 0U; loop_count < handle->mo_count; loop_count++)
1000616a:	693b      	ldr	r3, [r7, #16]
1000616c:	3301      	adds	r3, #1
1000616e:	613b      	str	r3, [r7, #16]
10006170:	687b      	ldr	r3, [r7, #4]
10006172:	22a2      	movs	r2, #162	; 0xa2
10006174:	5c9b      	ldrb	r3, [r3, r2]
10006176:	1e1a      	subs	r2, r3, #0
10006178:	693b      	ldr	r3, [r7, #16]
1000617a:	429a      	cmp	r2, r3
1000617c:	d8dd      	bhi.n	1000613a <CAN_NODE_Init+0xba>
        lmo_ptr = handle->lmobj_ptr[loop_count];
        XMC_CAN_AllocateMOtoNodeList(handle->global_ptr->canglobal_ptr, handle->node_num, lmo_ptr->number);
        CAN_NODE_MO_Init(lmo_ptr);
      }
      /* reset CCE and INIT bit NCR for node configuration */
      XMC_CAN_NODE_DisableConfigurationChange(handle->node_ptr);
1000617e:	687b      	ldr	r3, [r7, #4]
10006180:	685b      	ldr	r3, [r3, #4]
10006182:	1c18      	adds	r0, r3, #0
10006184:	f7ff fe16 	bl	10005db4 <XMC_CAN_NODE_DisableConfigurationChange>
      XMC_CAN_NODE_ResetInitBit(handle->node_ptr);
10006188:	687b      	ldr	r3, [r7, #4]
1000618a:	685b      	ldr	r3, [r3, #4]
1000618c:	1c18      	adds	r0, r3, #0
1000618e:	f7ff fe2d 	bl	10005dec <XMC_CAN_NODE_ResetInitBit>
      if (handle->loopback_enable == false)
10006192:	687b      	ldr	r3, [r7, #4]
10006194:	22a7      	movs	r2, #167	; 0xa7
10006196:	5c9b      	ldrb	r3, [r3, r2]
10006198:	2201      	movs	r2, #1
1000619a:	4053      	eors	r3, r2
1000619c:	b2db      	uxtb	r3, r3
1000619e:	2b00      	cmp	r3, #0
100061a0:	d013      	beq.n	100061ca <CAN_NODE_Init+0x14a>
      {
        /* CAN transmit pin configuration */
        XMC_GPIO_Init(lgpio_ptr->port, lgpio_ptr->pin, handle->gpio_out_config);
100061a2:	68fb      	ldr	r3, [r7, #12]
100061a4:	6818      	ldr	r0, [r3, #0]
100061a6:	68fb      	ldr	r3, [r7, #12]
100061a8:	7919      	ldrb	r1, [r3, #4]
100061aa:	687b      	ldr	r3, [r7, #4]
100061ac:	2294      	movs	r2, #148	; 0x94
100061ae:	589b      	ldr	r3, [r3, r2]
100061b0:	1c1a      	adds	r2, r3, #0
100061b2:	f7fa ffe9 	bl	10001188 <XMC_GPIO_Init>
100061b6:	e008      	b.n	100061ca <CAN_NODE_Init+0x14a>
      }
    }
    else
    {
      status = CAN_NODE_STATUS_FAILURE;
100061b8:	2317      	movs	r3, #23
100061ba:	18fb      	adds	r3, r7, r3
100061bc:	2201      	movs	r2, #1
100061be:	701a      	strb	r2, [r3, #0]
100061c0:	e003      	b.n	100061ca <CAN_NODE_Init+0x14a>
    }
  }
  else
  {
    status = CAN_NODE_STATUS_FAILURE;
100061c2:	2317      	movs	r3, #23
100061c4:	18fb      	adds	r3, r7, r3
100061c6:	2201      	movs	r2, #1
100061c8:	701a      	strb	r2, [r3, #0]
  }

  return (status);
100061ca:	2317      	movs	r3, #23
100061cc:	18fb      	adds	r3, r7, r3
100061ce:	781b      	ldrb	r3, [r3, #0]
}
100061d0:	1c18      	adds	r0, r3, #0
100061d2:	46bd      	mov	sp, r7
100061d4:	b007      	add	sp, #28
100061d6:	bd90      	pop	{r4, r7, pc}

100061d8 <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
__WEAK DAVE_STATUS_t DAVE_Init(void)
{
100061d8:	b590      	push	{r4, r7, lr}
100061da:	b083      	sub	sp, #12
100061dc:	af00      	add	r7, sp, #0
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
100061de:	1dfb      	adds	r3, r7, #7
100061e0:	2200      	movs	r2, #0
100061e2:	701a      	strb	r2, [r3, #0]
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC1_Init(&CLOCK_XMC1_0);
100061e4:	1dfc      	adds	r4, r7, #7
100061e6:	4b27      	ldr	r3, [pc, #156]	; (10006284 <DAVE_Init+0xac>)
100061e8:	1c18      	adds	r0, r3, #0
100061ea:	f7ff fd3d 	bl	10005c68 <CLOCK_XMC1_Init>
100061ee:	1c03      	adds	r3, r0, #0
100061f0:	7023      	strb	r3, [r4, #0]

  if (init_status == DAVE_STATUS_SUCCESS)
100061f2:	1dfb      	adds	r3, r7, #7
100061f4:	781b      	ldrb	r3, [r3, #0]
100061f6:	2b00      	cmp	r3, #0
100061f8:	d106      	bne.n	10006208 <DAVE_Init+0x30>
  {
	 /**  Initialization of UART APP instance UART_0 */
	 init_status = (DAVE_STATUS_t)UART_Init(&UART_0); 
100061fa:	1dfc      	adds	r4, r7, #7
100061fc:	4b22      	ldr	r3, [pc, #136]	; (10006288 <DAVE_Init+0xb0>)
100061fe:	1c18      	adds	r0, r3, #0
10006200:	f7fc fb00 	bl	10002804 <UART_Init>
10006204:	1c03      	adds	r3, r0, #0
10006206:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10006208:	1dfb      	adds	r3, r7, #7
1000620a:	781b      	ldrb	r3, [r3, #0]
1000620c:	2b00      	cmp	r3, #0
1000620e:	d106      	bne.n	1000621e <DAVE_Init+0x46>
  {
	 /**  Initialization of CAN_NODE APP instance CAN_NODE_0 */
	 init_status = (DAVE_STATUS_t)CAN_NODE_Init(&CAN_NODE_0); 
10006210:	1dfc      	adds	r4, r7, #7
10006212:	4b1e      	ldr	r3, [pc, #120]	; (1000628c <DAVE_Init+0xb4>)
10006214:	1c18      	adds	r0, r3, #0
10006216:	f7ff ff33 	bl	10006080 <CAN_NODE_Init>
1000621a:	1c03      	adds	r3, r0, #0
1000621c:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
1000621e:	1dfb      	adds	r3, r7, #7
10006220:	781b      	ldrb	r3, [r3, #0]
10006222:	2b00      	cmp	r3, #0
10006224:	d106      	bne.n	10006234 <DAVE_Init+0x5c>
  {
	 /**  Initialization of SPI_MASTER APP instance SPI_MASTER_0 */
	 init_status = (DAVE_STATUS_t)SPI_MASTER_Init(&SPI_MASTER_0); 
10006226:	1dfc      	adds	r4, r7, #7
10006228:	4b19      	ldr	r3, [pc, #100]	; (10006290 <DAVE_Init+0xb8>)
1000622a:	1c18      	adds	r0, r3, #0
1000622c:	f7fc ff36 	bl	1000309c <SPI_MASTER_Init>
10006230:	1c03      	adds	r3, r0, #0
10006232:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10006234:	1dfb      	adds	r3, r7, #7
10006236:	781b      	ldrb	r3, [r3, #0]
10006238:	2b00      	cmp	r3, #0
1000623a:	d106      	bne.n	1000624a <DAVE_Init+0x72>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_0 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0); 
1000623c:	1dfc      	adds	r4, r7, #7
1000623e:	4b15      	ldr	r3, [pc, #84]	; (10006294 <DAVE_Init+0xbc>)
10006240:	1c18      	adds	r0, r3, #0
10006242:	f7ff fce5 	bl	10005c10 <DIGITAL_IO_Init>
10006246:	1c03      	adds	r3, r0, #0
10006248:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
1000624a:	1dfb      	adds	r3, r7, #7
1000624c:	781b      	ldrb	r3, [r3, #0]
1000624e:	2b00      	cmp	r3, #0
10006250:	d106      	bne.n	10006260 <DAVE_Init+0x88>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_1); 
10006252:	1dfc      	adds	r4, r7, #7
10006254:	4b10      	ldr	r3, [pc, #64]	; (10006298 <DAVE_Init+0xc0>)
10006256:	1c18      	adds	r0, r3, #0
10006258:	f7ff fcda 	bl	10005c10 <DIGITAL_IO_Init>
1000625c:	1c03      	adds	r3, r0, #0
1000625e:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10006260:	1dfb      	adds	r3, r7, #7
10006262:	781b      	ldrb	r3, [r3, #0]
10006264:	2b00      	cmp	r3, #0
10006266:	d106      	bne.n	10006276 <DAVE_Init+0x9e>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_2); 
10006268:	1dfc      	adds	r4, r7, #7
1000626a:	4b0c      	ldr	r3, [pc, #48]	; (1000629c <DAVE_Init+0xc4>)
1000626c:	1c18      	adds	r0, r3, #0
1000626e:	f7ff fccf 	bl	10005c10 <DIGITAL_IO_Init>
10006272:	1c03      	adds	r3, r0, #0
10006274:	7023      	strb	r3, [r4, #0]
   }  
  return init_status;
10006276:	1dfb      	adds	r3, r7, #7
10006278:	781b      	ldrb	r3, [r3, #0]
} /**  End of function DAVE_Init */
1000627a:	1c18      	adds	r0, r3, #0
1000627c:	46bd      	mov	sp, r7
1000627e:	b003      	add	sp, #12
10006280:	bd90      	pop	{r4, r7, pc}
10006282:	46c0      	nop			; (mov r8, r8)
10006284:	200007bc 	.word	0x200007bc
10006288:	20000550 	.word	0x20000550
1000628c:	1000689c 	.word	0x1000689c
10006290:	2000059c 	.word	0x2000059c
10006294:	10006820 	.word	0x10006820
10006298:	10006830 	.word	0x10006830
1000629c:	10006840 	.word	0x10006840

100062a0 <XMC_GPIO_SetOutputHigh>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
100062a0:	b580      	push	{r7, lr}
100062a2:	b082      	sub	sp, #8
100062a4:	af00      	add	r7, sp, #0
100062a6:	6078      	str	r0, [r7, #4]
100062a8:	1c0a      	adds	r2, r1, #0
100062aa:	1cfb      	adds	r3, r7, #3
100062ac:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
100062ae:	1cfb      	adds	r3, r7, #3
100062b0:	781b      	ldrb	r3, [r3, #0]
100062b2:	2201      	movs	r2, #1
100062b4:	409a      	lsls	r2, r3
100062b6:	687b      	ldr	r3, [r7, #4]
100062b8:	605a      	str	r2, [r3, #4]
}
100062ba:	46bd      	mov	sp, r7
100062bc:	b002      	add	sp, #8
100062be:	bd80      	pop	{r7, pc}

100062c0 <XMC_GPIO_SetOutputLow>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.\n
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
100062c0:	b580      	push	{r7, lr}
100062c2:	b082      	sub	sp, #8
100062c4:	af00      	add	r7, sp, #0
100062c6:	6078      	str	r0, [r7, #4]
100062c8:	1c0a      	adds	r2, r1, #0
100062ca:	1cfb      	adds	r3, r7, #3
100062cc:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
100062ce:	1cfb      	adds	r3, r7, #3
100062d0:	781b      	ldrb	r3, [r3, #0]
100062d2:	2280      	movs	r2, #128	; 0x80
100062d4:	0252      	lsls	r2, r2, #9
100062d6:	409a      	lsls	r2, r3
100062d8:	687b      	ldr	r3, [r7, #4]
100062da:	605a      	str	r2, [r3, #4]
}
100062dc:	46bd      	mov	sp, r7
100062de:	b002      	add	sp, #8
100062e0:	bd80      	pop	{r7, pc}
100062e2:	46c0      	nop			; (mov r8, r8)

100062e4 <XMC_GPIO_ToggleOutput>:
 * and does not contain any flip-flop. A read action delivers the value of 0.
 *
 */

__STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
100062e4:	b580      	push	{r7, lr}
100062e6:	b082      	sub	sp, #8
100062e8:	af00      	add	r7, sp, #0
100062ea:	6078      	str	r0, [r7, #4]
100062ec:	1c0a      	adds	r2, r1, #0
100062ee:	1cfb      	adds	r3, r7, #3
100062f0:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10001U << pin;
100062f2:	1cfb      	adds	r3, r7, #3
100062f4:	781b      	ldrb	r3, [r3, #0]
100062f6:	4a03      	ldr	r2, [pc, #12]	; (10006304 <XMC_GPIO_ToggleOutput+0x20>)
100062f8:	409a      	lsls	r2, r3
100062fa:	687b      	ldr	r3, [r7, #4]
100062fc:	605a      	str	r2, [r3, #4]
}
100062fe:	46bd      	mov	sp, r7
10006300:	b002      	add	sp, #8
10006302:	bd80      	pop	{r7, pc}
10006304:	00010001 	.word	0x00010001

10006308 <DIGITAL_IO_SetOutputHigh>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputHigh(const DIGITAL_IO_t *const handler)
{
10006308:	b580      	push	{r7, lr}
1000630a:	b082      	sub	sp, #8
1000630c:	af00      	add	r7, sp, #0
1000630e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputHigh: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
10006310:	687b      	ldr	r3, [r7, #4]
10006312:	681a      	ldr	r2, [r3, #0]
10006314:	687b      	ldr	r3, [r7, #4]
10006316:	7b1b      	ldrb	r3, [r3, #12]
10006318:	1c10      	adds	r0, r2, #0
1000631a:	1c19      	adds	r1, r3, #0
1000631c:	f7ff ffc0 	bl	100062a0 <XMC_GPIO_SetOutputHigh>
}
10006320:	46bd      	mov	sp, r7
10006322:	b002      	add	sp, #8
10006324:	bd80      	pop	{r7, pc}
10006326:	46c0      	nop			; (mov r8, r8)

10006328 <DIGITAL_IO_SetOutputLow>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputLow(const DIGITAL_IO_t *const handler)
{
10006328:	b580      	push	{r7, lr}
1000632a:	b082      	sub	sp, #8
1000632c:	af00      	add	r7, sp, #0
1000632e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputLow: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
10006330:	687b      	ldr	r3, [r7, #4]
10006332:	681a      	ldr	r2, [r3, #0]
10006334:	687b      	ldr	r3, [r7, #4]
10006336:	7b1b      	ldrb	r3, [r3, #12]
10006338:	1c10      	adds	r0, r2, #0
1000633a:	1c19      	adds	r1, r3, #0
1000633c:	f7ff ffc0 	bl	100062c0 <XMC_GPIO_SetOutputLow>
}
10006340:	46bd      	mov	sp, r7
10006342:	b002      	add	sp, #8
10006344:	bd80      	pop	{r7, pc}
10006346:	46c0      	nop			; (mov r8, r8)

10006348 <DIGITAL_IO_ToggleOutput>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_ToggleOutput(const DIGITAL_IO_t *const handler)
{
10006348:	b580      	push	{r7, lr}
1000634a:	b082      	sub	sp, #8
1000634c:	af00      	add	r7, sp, #0
1000634e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_ToggleOutput: handler null pointer", handler != NULL);
  XMC_GPIO_ToggleOutput(handler->gpio_port, handler->gpio_pin);
10006350:	687b      	ldr	r3, [r7, #4]
10006352:	681a      	ldr	r2, [r3, #0]
10006354:	687b      	ldr	r3, [r7, #4]
10006356:	7b1b      	ldrb	r3, [r3, #12]
10006358:	1c10      	adds	r0, r2, #0
1000635a:	1c19      	adds	r1, r3, #0
1000635c:	f7ff ffc2 	bl	100062e4 <XMC_GPIO_ToggleOutput>
}
10006360:	46bd      	mov	sp, r7
10006362:	b002      	add	sp, #8
10006364:	bd80      	pop	{r7, pc}
10006366:	46c0      	nop			; (mov r8, r8)

10006368 <vTask1>:
uint8_t uart_data;


uint8_t spi_data;

void vTask1(void *pvParameters) {
10006368:	b580      	push	{r7, lr}
1000636a:	b084      	sub	sp, #16
1000636c:	af00      	add	r7, sp, #0
1000636e:	6078      	str	r0, [r7, #4]
    while(1) {
        // Toggle the LED
    	array_data = can_data_arr;
10006370:	4b16      	ldr	r3, [pc, #88]	; (100063cc <vTask1+0x64>)
10006372:	781b      	ldrb	r3, [r3, #0]
10006374:	1c1a      	adds	r2, r3, #0
10006376:	4b16      	ldr	r3, [pc, #88]	; (100063d0 <vTask1+0x68>)
10006378:	601a      	str	r2, [r3, #0]
    	UART_Receive(&UART_0, &uart_data, sizeof(uart_data));
1000637a:	4a16      	ldr	r2, [pc, #88]	; (100063d4 <vTask1+0x6c>)
1000637c:	4b16      	ldr	r3, [pc, #88]	; (100063d8 <vTask1+0x70>)
1000637e:	1c10      	adds	r0, r2, #0
10006380:	1c19      	adds	r1, r3, #0
10006382:	2201      	movs	r2, #1
10006384:	f7fc fa56 	bl	10002834 <UART_Receive>
    	XMC_CAN_MO_t* lmsgobjct_ptr_0 = CAN_NODE_0.lmobj_ptr[0]->mo_ptr;
10006388:	4b14      	ldr	r3, [pc, #80]	; (100063dc <vTask1+0x74>)
1000638a:	68db      	ldr	r3, [r3, #12]
1000638c:	681b      	ldr	r3, [r3, #0]
1000638e:	60fb      	str	r3, [r7, #12]
    	CAN_NODE_STATUS_t status_1; // variable for struct
    	    const CAN_NODE_t *HandlePtr1 = &CAN_NODE_0;
10006390:	4b12      	ldr	r3, [pc, #72]	; (100063dc <vTask1+0x74>)
10006392:	60bb      	str	r3, [r7, #8]
    	    (CAN_NODE_STATUS_t)CAN_NODE_MO_UpdateData(HandlePtr1->lmobj_ptr[0],array_data);
10006394:	68bb      	ldr	r3, [r7, #8]
10006396:	68da      	ldr	r2, [r3, #12]
10006398:	4b0d      	ldr	r3, [pc, #52]	; (100063d0 <vTask1+0x68>)
1000639a:	681b      	ldr	r3, [r3, #0]
1000639c:	1c10      	adds	r0, r2, #0
1000639e:	1c19      	adds	r1, r3, #0
100063a0:	f7ff fe48 	bl	10006034 <CAN_NODE_MO_UpdateData>
    	    memcpy(&lmsgobjct_ptr_0->can_data_byte, &uart_data,1);
100063a4:	68fb      	ldr	r3, [r7, #12]
100063a6:	3310      	adds	r3, #16
100063a8:	4a0b      	ldr	r2, [pc, #44]	; (100063d8 <vTask1+0x70>)
100063aa:	7812      	ldrb	r2, [r2, #0]
100063ac:	701a      	strb	r2, [r3, #0]
    	    CAN_NODE_MO_Transmit(HandlePtr1->lmobj_ptr[0]);
100063ae:	68bb      	ldr	r3, [r7, #8]
100063b0:	68db      	ldr	r3, [r3, #12]
100063b2:	1c18      	adds	r0, r3, #0
100063b4:	f7ff fe26 	bl	10006004 <CAN_NODE_MO_Transmit>
        DIGITAL_IO_ToggleOutput(&DIGITAL_IO_0);
100063b8:	4b09      	ldr	r3, [pc, #36]	; (100063e0 <vTask1+0x78>)
100063ba:	1c18      	adds	r0, r3, #0
100063bc:	f7ff ffc4 	bl	10006348 <DIGITAL_IO_ToggleOutput>
       // can_data_arr[1]=1;
        vTaskDelay(pdMS_TO_TICKS(1000));  // Delay for 1000 milliseconds
100063c0:	23fa      	movs	r3, #250	; 0xfa
100063c2:	009b      	lsls	r3, r3, #2
100063c4:	1c18      	adds	r0, r3, #0
100063c6:	f7fe fc77 	bl	10004cb8 <vTaskDelay>

    }
100063ca:	e7d1      	b.n	10006370 <vTask1+0x8>
100063cc:	20000808 	.word	0x20000808
100063d0:	2000080c 	.word	0x2000080c
100063d4:	20000550 	.word	0x20000550
100063d8:	20000809 	.word	0x20000809
100063dc:	1000689c 	.word	0x1000689c
100063e0:	10006820 	.word	0x10006820

100063e4 <vTask2>:
}


// Task function for Task 2
void vTask2(void *pvParameters) {
100063e4:	b580      	push	{r7, lr}
100063e6:	b082      	sub	sp, #8
100063e8:	af00      	add	r7, sp, #0
100063ea:	6078      	str	r0, [r7, #4]
    while(1) {


    	UART_Receive(&UART_0, &uart_data, sizeof(uart_data));
100063ec:	4a11      	ldr	r2, [pc, #68]	; (10006434 <vTask2+0x50>)
100063ee:	4b12      	ldr	r3, [pc, #72]	; (10006438 <vTask2+0x54>)
100063f0:	1c10      	adds	r0, r2, #0
100063f2:	1c19      	adds	r1, r3, #0
100063f4:	2201      	movs	r2, #1
100063f6:	f7fc fa1d 	bl	10002834 <UART_Receive>
    	memcpy(&spi_data, &uart_data,8);
100063fa:	4a10      	ldr	r2, [pc, #64]	; (1000643c <vTask2+0x58>)
100063fc:	4b0e      	ldr	r3, [pc, #56]	; (10006438 <vTask2+0x54>)
100063fe:	1c10      	adds	r0, r2, #0
10006400:	1c19      	adds	r1, r3, #0
10006402:	2208      	movs	r2, #8
10006404:	f000 f890 	bl	10006528 <memcpy>

    	SPI_MASTER_Transmit(&SPI_MASTER_0,&spi_data, sizeof(spi_data));
10006408:	4a0d      	ldr	r2, [pc, #52]	; (10006440 <vTask2+0x5c>)
1000640a:	4b0c      	ldr	r3, [pc, #48]	; (1000643c <vTask2+0x58>)
1000640c:	1c10      	adds	r0, r2, #0
1000640e:	1c19      	adds	r1, r3, #0
10006410:	2201      	movs	r2, #1
10006412:	f7fc fe57 	bl	100030c4 <SPI_MASTER_Transmit>

        // Turn on the LED
        DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_2);
10006416:	4b0b      	ldr	r3, [pc, #44]	; (10006444 <vTask2+0x60>)
10006418:	1c18      	adds	r0, r3, #0
1000641a:	f7ff ff75 	bl	10006308 <DIGITAL_IO_SetOutputHigh>

        vTaskDelay(pdMS_TO_TICKS(250));   // Delay for 250 milliseconds
1000641e:	20fa      	movs	r0, #250	; 0xfa
10006420:	f7fe fc4a 	bl	10004cb8 <vTaskDelay>

        // Turn off the LED
        DIGITAL_IO_SetOutputLow(&DIGITAL_IO_2);
10006424:	4b07      	ldr	r3, [pc, #28]	; (10006444 <vTask2+0x60>)
10006426:	1c18      	adds	r0, r3, #0
10006428:	f7ff ff7e 	bl	10006328 <DIGITAL_IO_SetOutputLow>

        vTaskDelay(pdMS_TO_TICKS(250));   // Delay for 250 milliseconds
1000642c:	20fa      	movs	r0, #250	; 0xfa
1000642e:	f7fe fc43 	bl	10004cb8 <vTaskDelay>
    }
10006432:	e7db      	b.n	100063ec <vTask2+0x8>
10006434:	20000550 	.word	0x20000550
10006438:	20000809 	.word	0x20000809
1000643c:	2000080a 	.word	0x2000080a
10006440:	2000059c 	.word	0x2000059c
10006444:	10006840 	.word	0x10006840

10006448 <main>:
}

int main(void) {
10006448:	b590      	push	{r4, r7, lr}
1000644a:	b085      	sub	sp, #20
1000644c:	af02      	add	r7, sp, #8
    // Initialize the DAVE Apps
    DAVE_STATUS_t status;

     status = DAVE_Init();    // Initialize DAVE Apps
1000644e:	1dfc      	adds	r4, r7, #7
10006450:	f7ff fec2 	bl	100061d8 <DAVE_Init>
10006454:	1c03      	adds	r3, r0, #0
10006456:	7023      	strb	r3, [r4, #0]

    // Check for initialization errors
    if(status != DAVE_STATUS_SUCCESS) {
10006458:	1dfb      	adds	r3, r7, #7
1000645a:	781b      	ldrb	r3, [r3, #0]
1000645c:	2b00      	cmp	r3, #0
1000645e:	d000      	beq.n	10006462 <main+0x1a>
        // Initialization failed
        while(1) {}
10006460:	e7fe      	b.n	10006460 <main+0x18>
    }

    // Create Task 1
    xTaskCreate(vTask1, "Task 1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
10006462:	490d      	ldr	r1, [pc, #52]	; (10006498 <main+0x50>)
10006464:	4a0d      	ldr	r2, [pc, #52]	; (1000649c <main+0x54>)
10006466:	2301      	movs	r3, #1
10006468:	9300      	str	r3, [sp, #0]
1000646a:	2300      	movs	r3, #0
1000646c:	9301      	str	r3, [sp, #4]
1000646e:	1c08      	adds	r0, r1, #0
10006470:	1c11      	adds	r1, r2, #0
10006472:	223c      	movs	r2, #60	; 0x3c
10006474:	2300      	movs	r3, #0
10006476:	f7fe fad5 	bl	10004a24 <xTaskCreate>



    // Create Task 3
    xTaskCreate(vTask2, "Task 2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
1000647a:	4909      	ldr	r1, [pc, #36]	; (100064a0 <main+0x58>)
1000647c:	4a09      	ldr	r2, [pc, #36]	; (100064a4 <main+0x5c>)
1000647e:	2301      	movs	r3, #1
10006480:	9300      	str	r3, [sp, #0]
10006482:	2300      	movs	r3, #0
10006484:	9301      	str	r3, [sp, #4]
10006486:	1c08      	adds	r0, r1, #0
10006488:	1c11      	adds	r1, r2, #0
1000648a:	223c      	movs	r2, #60	; 0x3c
1000648c:	2300      	movs	r3, #0
1000648e:	f7fe fac9 	bl	10004a24 <xTaskCreate>


    // Start the FreeRTOS scheduler
    vTaskStartScheduler();
10006492:	f7fe fc35 	bl	10004d00 <vTaskStartScheduler>

    while(1) {
    }
10006496:	e7fe      	b.n	10006496 <main+0x4e>
10006498:	10006369 	.word	0x10006369
1000649c:	10006944 	.word	0x10006944
100064a0:	100063e5 	.word	0x100063e5
100064a4:	1000694c 	.word	0x1000694c

100064a8 <__errno>:
100064a8:	4b01      	ldr	r3, [pc, #4]	; (100064b0 <__errno+0x8>)
100064aa:	6818      	ldr	r0, [r3, #0]
100064ac:	4770      	bx	lr
100064ae:	46c0      	nop			; (mov r8, r8)
100064b0:	20000640 	.word	0x20000640

100064b4 <__libc_init_array>:
100064b4:	4b0e      	ldr	r3, [pc, #56]	; (100064f0 <__libc_init_array+0x3c>)
100064b6:	b570      	push	{r4, r5, r6, lr}
100064b8:	2500      	movs	r5, #0
100064ba:	1c1e      	adds	r6, r3, #0
100064bc:	4c0d      	ldr	r4, [pc, #52]	; (100064f4 <__libc_init_array+0x40>)
100064be:	1ae4      	subs	r4, r4, r3
100064c0:	10a4      	asrs	r4, r4, #2
100064c2:	42a5      	cmp	r5, r4
100064c4:	d004      	beq.n	100064d0 <__libc_init_array+0x1c>
100064c6:	00ab      	lsls	r3, r5, #2
100064c8:	58f3      	ldr	r3, [r6, r3]
100064ca:	4798      	blx	r3
100064cc:	3501      	adds	r5, #1
100064ce:	e7f8      	b.n	100064c2 <__libc_init_array+0xe>
100064d0:	f7fc f8e8 	bl	100026a4 <_init>
100064d4:	4b08      	ldr	r3, [pc, #32]	; (100064f8 <__libc_init_array+0x44>)
100064d6:	2500      	movs	r5, #0
100064d8:	1c1e      	adds	r6, r3, #0
100064da:	4c08      	ldr	r4, [pc, #32]	; (100064fc <__libc_init_array+0x48>)
100064dc:	1ae4      	subs	r4, r4, r3
100064de:	10a4      	asrs	r4, r4, #2
100064e0:	42a5      	cmp	r5, r4
100064e2:	d004      	beq.n	100064ee <__libc_init_array+0x3a>
100064e4:	00ab      	lsls	r3, r5, #2
100064e6:	58f3      	ldr	r3, [r6, r3]
100064e8:	4798      	blx	r3
100064ea:	3501      	adds	r5, #1
100064ec:	e7f8      	b.n	100064e0 <__libc_init_array+0x2c>
100064ee:	bd70      	pop	{r4, r5, r6, pc}
100064f0:	20000644 	.word	0x20000644
100064f4:	20000644 	.word	0x20000644
100064f8:	20000644 	.word	0x20000644
100064fc:	20000644 	.word	0x20000644

10006500 <malloc>:
10006500:	b508      	push	{r3, lr}
10006502:	4b03      	ldr	r3, [pc, #12]	; (10006510 <malloc+0x10>)
10006504:	1c01      	adds	r1, r0, #0
10006506:	6818      	ldr	r0, [r3, #0]
10006508:	f000 f866 	bl	100065d8 <_malloc_r>
1000650c:	bd08      	pop	{r3, pc}
1000650e:	46c0      	nop			; (mov r8, r8)
10006510:	20000640 	.word	0x20000640

10006514 <free>:
10006514:	b508      	push	{r3, lr}
10006516:	4b03      	ldr	r3, [pc, #12]	; (10006524 <free+0x10>)
10006518:	1c01      	adds	r1, r0, #0
1000651a:	6818      	ldr	r0, [r3, #0]
1000651c:	f000 f816 	bl	1000654c <_free_r>
10006520:	bd08      	pop	{r3, pc}
10006522:	46c0      	nop			; (mov r8, r8)
10006524:	20000640 	.word	0x20000640

10006528 <memcpy>:
10006528:	2300      	movs	r3, #0
1000652a:	b510      	push	{r4, lr}
1000652c:	4293      	cmp	r3, r2
1000652e:	d003      	beq.n	10006538 <memcpy+0x10>
10006530:	5ccc      	ldrb	r4, [r1, r3]
10006532:	54c4      	strb	r4, [r0, r3]
10006534:	3301      	adds	r3, #1
10006536:	e7f9      	b.n	1000652c <memcpy+0x4>
10006538:	bd10      	pop	{r4, pc}

1000653a <memset>:
1000653a:	1c03      	adds	r3, r0, #0
1000653c:	1882      	adds	r2, r0, r2
1000653e:	4293      	cmp	r3, r2
10006540:	d002      	beq.n	10006548 <memset+0xe>
10006542:	7019      	strb	r1, [r3, #0]
10006544:	3301      	adds	r3, #1
10006546:	e7fa      	b.n	1000653e <memset+0x4>
10006548:	4770      	bx	lr
	...

1000654c <_free_r>:
1000654c:	b530      	push	{r4, r5, lr}
1000654e:	2900      	cmp	r1, #0
10006550:	d03e      	beq.n	100065d0 <_free_r+0x84>
10006552:	3904      	subs	r1, #4
10006554:	680b      	ldr	r3, [r1, #0]
10006556:	2b00      	cmp	r3, #0
10006558:	da00      	bge.n	1000655c <_free_r+0x10>
1000655a:	18c9      	adds	r1, r1, r3
1000655c:	4a1d      	ldr	r2, [pc, #116]	; (100065d4 <_free_r+0x88>)
1000655e:	6813      	ldr	r3, [r2, #0]
10006560:	1c14      	adds	r4, r2, #0
10006562:	2b00      	cmp	r3, #0
10006564:	d102      	bne.n	1000656c <_free_r+0x20>
10006566:	604b      	str	r3, [r1, #4]
10006568:	6011      	str	r1, [r2, #0]
1000656a:	e031      	b.n	100065d0 <_free_r+0x84>
1000656c:	4299      	cmp	r1, r3
1000656e:	d20d      	bcs.n	1000658c <_free_r+0x40>
10006570:	6808      	ldr	r0, [r1, #0]
10006572:	180a      	adds	r2, r1, r0
10006574:	429a      	cmp	r2, r3
10006576:	d103      	bne.n	10006580 <_free_r+0x34>
10006578:	6813      	ldr	r3, [r2, #0]
1000657a:	18c3      	adds	r3, r0, r3
1000657c:	600b      	str	r3, [r1, #0]
1000657e:	6853      	ldr	r3, [r2, #4]
10006580:	604b      	str	r3, [r1, #4]
10006582:	6021      	str	r1, [r4, #0]
10006584:	e024      	b.n	100065d0 <_free_r+0x84>
10006586:	428a      	cmp	r2, r1
10006588:	d803      	bhi.n	10006592 <_free_r+0x46>
1000658a:	1c13      	adds	r3, r2, #0
1000658c:	685a      	ldr	r2, [r3, #4]
1000658e:	2a00      	cmp	r2, #0
10006590:	d1f9      	bne.n	10006586 <_free_r+0x3a>
10006592:	681d      	ldr	r5, [r3, #0]
10006594:	195c      	adds	r4, r3, r5
10006596:	428c      	cmp	r4, r1
10006598:	d10b      	bne.n	100065b2 <_free_r+0x66>
1000659a:	6809      	ldr	r1, [r1, #0]
1000659c:	1869      	adds	r1, r5, r1
1000659e:	1858      	adds	r0, r3, r1
100065a0:	6019      	str	r1, [r3, #0]
100065a2:	4290      	cmp	r0, r2
100065a4:	d114      	bne.n	100065d0 <_free_r+0x84>
100065a6:	6810      	ldr	r0, [r2, #0]
100065a8:	6852      	ldr	r2, [r2, #4]
100065aa:	1809      	adds	r1, r1, r0
100065ac:	6019      	str	r1, [r3, #0]
100065ae:	605a      	str	r2, [r3, #4]
100065b0:	e00e      	b.n	100065d0 <_free_r+0x84>
100065b2:	428c      	cmp	r4, r1
100065b4:	d902      	bls.n	100065bc <_free_r+0x70>
100065b6:	230c      	movs	r3, #12
100065b8:	6003      	str	r3, [r0, #0]
100065ba:	e009      	b.n	100065d0 <_free_r+0x84>
100065bc:	6808      	ldr	r0, [r1, #0]
100065be:	180c      	adds	r4, r1, r0
100065c0:	4294      	cmp	r4, r2
100065c2:	d103      	bne.n	100065cc <_free_r+0x80>
100065c4:	6814      	ldr	r4, [r2, #0]
100065c6:	6852      	ldr	r2, [r2, #4]
100065c8:	1900      	adds	r0, r0, r4
100065ca:	6008      	str	r0, [r1, #0]
100065cc:	604a      	str	r2, [r1, #4]
100065ce:	6059      	str	r1, [r3, #4]
100065d0:	bd30      	pop	{r4, r5, pc}
100065d2:	46c0      	nop			; (mov r8, r8)
100065d4:	200007c4 	.word	0x200007c4

100065d8 <_malloc_r>:
100065d8:	2303      	movs	r3, #3
100065da:	b570      	push	{r4, r5, r6, lr}
100065dc:	1ccc      	adds	r4, r1, #3
100065de:	439c      	bics	r4, r3
100065e0:	3408      	adds	r4, #8
100065e2:	1c05      	adds	r5, r0, #0
100065e4:	2c0c      	cmp	r4, #12
100065e6:	d201      	bcs.n	100065ec <_malloc_r+0x14>
100065e8:	240c      	movs	r4, #12
100065ea:	e005      	b.n	100065f8 <_malloc_r+0x20>
100065ec:	2c00      	cmp	r4, #0
100065ee:	da03      	bge.n	100065f8 <_malloc_r+0x20>
100065f0:	230c      	movs	r3, #12
100065f2:	2000      	movs	r0, #0
100065f4:	602b      	str	r3, [r5, #0]
100065f6:	e042      	b.n	1000667e <_malloc_r+0xa6>
100065f8:	428c      	cmp	r4, r1
100065fa:	d3f9      	bcc.n	100065f0 <_malloc_r+0x18>
100065fc:	4a20      	ldr	r2, [pc, #128]	; (10006680 <_malloc_r+0xa8>)
100065fe:	6813      	ldr	r3, [r2, #0]
10006600:	1c10      	adds	r0, r2, #0
10006602:	1c19      	adds	r1, r3, #0
10006604:	2900      	cmp	r1, #0
10006606:	d013      	beq.n	10006630 <_malloc_r+0x58>
10006608:	680a      	ldr	r2, [r1, #0]
1000660a:	1b12      	subs	r2, r2, r4
1000660c:	d40d      	bmi.n	1000662a <_malloc_r+0x52>
1000660e:	2a0b      	cmp	r2, #11
10006610:	d902      	bls.n	10006618 <_malloc_r+0x40>
10006612:	600a      	str	r2, [r1, #0]
10006614:	188b      	adds	r3, r1, r2
10006616:	e01f      	b.n	10006658 <_malloc_r+0x80>
10006618:	428b      	cmp	r3, r1
1000661a:	d102      	bne.n	10006622 <_malloc_r+0x4a>
1000661c:	685a      	ldr	r2, [r3, #4]
1000661e:	6002      	str	r2, [r0, #0]
10006620:	e01b      	b.n	1000665a <_malloc_r+0x82>
10006622:	684a      	ldr	r2, [r1, #4]
10006624:	605a      	str	r2, [r3, #4]
10006626:	1c0b      	adds	r3, r1, #0
10006628:	e017      	b.n	1000665a <_malloc_r+0x82>
1000662a:	1c0b      	adds	r3, r1, #0
1000662c:	6849      	ldr	r1, [r1, #4]
1000662e:	e7e9      	b.n	10006604 <_malloc_r+0x2c>
10006630:	4e14      	ldr	r6, [pc, #80]	; (10006684 <_malloc_r+0xac>)
10006632:	6833      	ldr	r3, [r6, #0]
10006634:	2b00      	cmp	r3, #0
10006636:	d103      	bne.n	10006640 <_malloc_r+0x68>
10006638:	1c28      	adds	r0, r5, #0
1000663a:	f000 f825 	bl	10006688 <_sbrk_r>
1000663e:	6030      	str	r0, [r6, #0]
10006640:	1c28      	adds	r0, r5, #0
10006642:	1c21      	adds	r1, r4, #0
10006644:	f000 f820 	bl	10006688 <_sbrk_r>
10006648:	1c03      	adds	r3, r0, #0
1000664a:	1c42      	adds	r2, r0, #1
1000664c:	d0d0      	beq.n	100065f0 <_malloc_r+0x18>
1000664e:	2203      	movs	r2, #3
10006650:	1cc6      	adds	r6, r0, #3
10006652:	4396      	bics	r6, r2
10006654:	4286      	cmp	r6, r0
10006656:	d10a      	bne.n	1000666e <_malloc_r+0x96>
10006658:	601c      	str	r4, [r3, #0]
1000665a:	1c18      	adds	r0, r3, #0
1000665c:	2107      	movs	r1, #7
1000665e:	300b      	adds	r0, #11
10006660:	1d1a      	adds	r2, r3, #4
10006662:	4388      	bics	r0, r1
10006664:	1a82      	subs	r2, r0, r2
10006666:	d00a      	beq.n	1000667e <_malloc_r+0xa6>
10006668:	4251      	negs	r1, r2
1000666a:	5099      	str	r1, [r3, r2]
1000666c:	e007      	b.n	1000667e <_malloc_r+0xa6>
1000666e:	1a31      	subs	r1, r6, r0
10006670:	1c28      	adds	r0, r5, #0
10006672:	f000 f809 	bl	10006688 <_sbrk_r>
10006676:	1c43      	adds	r3, r0, #1
10006678:	d0ba      	beq.n	100065f0 <_malloc_r+0x18>
1000667a:	1c33      	adds	r3, r6, #0
1000667c:	e7ec      	b.n	10006658 <_malloc_r+0x80>
1000667e:	bd70      	pop	{r4, r5, r6, pc}
10006680:	200007c4 	.word	0x200007c4
10006684:	200007c0 	.word	0x200007c0

10006688 <_sbrk_r>:
10006688:	b538      	push	{r3, r4, r5, lr}
1000668a:	2300      	movs	r3, #0
1000668c:	4c06      	ldr	r4, [pc, #24]	; (100066a8 <_sbrk_r+0x20>)
1000668e:	1c05      	adds	r5, r0, #0
10006690:	1c08      	adds	r0, r1, #0
10006692:	6023      	str	r3, [r4, #0]
10006694:	f7fb ffd2 	bl	1000263c <_sbrk>
10006698:	1c43      	adds	r3, r0, #1
1000669a:	d103      	bne.n	100066a4 <_sbrk_r+0x1c>
1000669c:	6823      	ldr	r3, [r4, #0]
1000669e:	2b00      	cmp	r3, #0
100066a0:	d000      	beq.n	100066a4 <_sbrk_r+0x1c>
100066a2:	602b      	str	r3, [r5, #0]
100066a4:	bd38      	pop	{r3, r4, r5, pc}
100066a6:	46c0      	nop			; (mov r8, r8)
100066a8:	20000810 	.word	0x20000810

100066ac <UART_0_channel_config>:
100066ac:	00002580 01080800 00000010              .%..........

100066b8 <UART_0_tx_pin_config>:
100066b8:	0000009c 00000001                       ........

100066c0 <UART_0_tx_pin>:
100066c0:	40040100 00000002 100066b8              ...@.....f..

100066cc <UART_0_config>:
100066cc:	100066ac 10002d65 00000000 00000000     .f..e-..........
	...
100066f0:	100066c0 04000000 00000204              .f..........

100066fc <UART_0_rx_pin_config>:
100066fc:	00000000 00000001                       ........

10006704 <SPI_MASTER_0_MOSI>:
10006704:	40040100 00000005                       ...@....

1000670c <SPI_MASTER_0_MISO>:
1000670c:	40040100 00000004                       ...@....

10006714 <SPI_MASTER_0_SCLKOUT>:
10006714:	40040100 00000006                       ...@....

1000671c <SPI_MASTER_0_SCLKOUT_Config>:
1000671c:	00000090 00000001 00000000 00000000     ................

1000672c <SPI_MASTER_0_SS_0>:
1000672c:	40040000 0000000c                       ...@....

10006734 <SPI_MASTER_0_SS_0_Config>:
10006734:	00000098 00000001 00000000 00080000     ................

10006744 <SPI_MASTER_0_Config>:
10006744:	2000056c 10003a5d 10006704 2000055c     l.. ]:...g..\.. 
10006754:	1000670c 2000066c 00000000 00000000     .g..l.. ........
	...
1000676c:	10006714 1000671c 1000672c 00000000     .g...g..,g......
	...
10006794:	10006734 00000000 00000000 00000000     4g..............
	...
100067c0:	00000404 00000000 01000000 00010302     ................
100067d0:	454c4449 00000000 09632509 25097525     IDLE.....%c.%u.%
100067e0:	75250975 00000a0d 20726d54 00637653     u.%u....Tmr Svc.
100067f0:	51726d54 00000000 100059c6 100059c6     TmrQ.....Y...Y..
10006800:	100059c6 10005a3a 10005a4e 10005a8a     .Y..:Z..NZ...Z..
10006810:	100059c6 100059c6 10005a3a 10005a4e     .Y...Y..:Z..NZ..

10006820 <DIGITAL_IO_0>:
10006820:	40040100 00000000 00000000 00000008     ...@............

10006830 <DIGITAL_IO_1>:
10006830:	40040100 00000000 00000000 00000001     ...@............

10006840 <DIGITAL_IO_2>:
10006840:	40040100 00000000 00000000 00000000     ...@............
10006850:	00010000 03300000 00010000 00000000     ......0.........

10006860 <CAN_NODE_0_gpio_out>:
10006860:	40040200 0000000a                       ...@....

10006868 <CAN_NODE_0_gpio_out_config>:
10006868:	000000a4 00000001                       ........

10006870 <CAN_NODE_0_gpio_in>:
10006870:	40040000 0000000d                       ...@....

10006878 <CAN_NODE_0_gpio_in_config>:
	...

10006880 <CAN_NODE_0_BitTimeConfig>:
10006880:	02dc6c00 0007a120 00011f40              .l.. ...@...

1000688c <CAN_NODE_0_sr>:
1000688c:	00000000                                ....

10006890 <CAN_NODE_0_LMO_01_Config>:
10006890:	200005c0 00000013 00000000              ... ........

1000689c <CAN_NODE_0>:
1000689c:	200005a8 50040300 10006880 10006890     ... ...P.h...h..
	...
10006928:	1000688c 10006860 10006868 10006870     .h..`h..hh..ph..
10006938:	10006878 00010101 00000000 6b736154     xh..........Task
10006948:	00003120 6b736154 00003220 00000043      1..Task 2..C...

Disassembly of section .VENEER_Code:

2000000c <HardFault_Veener>:
/* ==================VENEERS VENEERS VENEERS VENEERS VENEERS=============== */
    .section ".XmcVeneerCode","ax",%progbits
    
    .align 1
    
	Insert_InterruptVeener HardFault
2000000c:	482c      	ldr	r0, [pc, #176]	; (200000c0 <IRQ31_Veener+0x4>)
2000000e:	4700      	bx	r0
	...

2000002c <SVC_Veener>:
    .long 0
    .long 0
    .long 0
    .long 0
    .long 0
	Insert_InterruptVeener SVC
2000002c:	4825      	ldr	r0, [pc, #148]	; (200000c4 <IRQ31_Veener+0x8>)
2000002e:	4700      	bx	r0
	...

20000038 <PendSV_Veener>:
    .long 0
    .long 0
	Insert_InterruptVeener PendSV	
20000038:	4823      	ldr	r0, [pc, #140]	; (200000c8 <IRQ31_Veener+0xc>)
2000003a:	4700      	bx	r0

2000003c <SysTick_Veener>:
	Insert_InterruptVeener SysTick
2000003c:	4823      	ldr	r0, [pc, #140]	; (200000cc <IRQ31_Veener+0x10>)
2000003e:	4700      	bx	r0

20000040 <IRQ0_Veener>:
	
	Insert_InterruptVeener IRQ0	
20000040:	4823      	ldr	r0, [pc, #140]	; (200000d0 <IRQ31_Veener+0x14>)
20000042:	4700      	bx	r0

20000044 <IRQ1_Veener>:
	Insert_InterruptVeener IRQ1	
20000044:	4823      	ldr	r0, [pc, #140]	; (200000d4 <IRQ31_Veener+0x18>)
20000046:	4700      	bx	r0

20000048 <IRQ2_Veener>:
	Insert_InterruptVeener IRQ2	
20000048:	4823      	ldr	r0, [pc, #140]	; (200000d8 <IRQ31_Veener+0x1c>)
2000004a:	4700      	bx	r0

2000004c <IRQ3_Veener>:
	Insert_InterruptVeener IRQ3	
2000004c:	4823      	ldr	r0, [pc, #140]	; (200000dc <IRQ31_Veener+0x20>)
2000004e:	4700      	bx	r0

20000050 <IRQ4_Veener>:
	Insert_InterruptVeener IRQ4	
20000050:	4823      	ldr	r0, [pc, #140]	; (200000e0 <IRQ31_Veener+0x24>)
20000052:	4700      	bx	r0

20000054 <IRQ5_Veener>:
	Insert_InterruptVeener IRQ5	
20000054:	4823      	ldr	r0, [pc, #140]	; (200000e4 <IRQ31_Veener+0x28>)
20000056:	4700      	bx	r0

20000058 <IRQ6_Veener>:
	Insert_InterruptVeener IRQ6	
20000058:	4823      	ldr	r0, [pc, #140]	; (200000e8 <IRQ31_Veener+0x2c>)
2000005a:	4700      	bx	r0

2000005c <IRQ7_Veener>:
	Insert_InterruptVeener IRQ7	
2000005c:	4823      	ldr	r0, [pc, #140]	; (200000ec <IRQ31_Veener+0x30>)
2000005e:	4700      	bx	r0

20000060 <IRQ8_Veener>:
	Insert_InterruptVeener IRQ8	
20000060:	4823      	ldr	r0, [pc, #140]	; (200000f0 <IRQ31_Veener+0x34>)
20000062:	4700      	bx	r0

20000064 <IRQ9_Veener>:
	Insert_InterruptVeener IRQ9	
20000064:	4823      	ldr	r0, [pc, #140]	; (200000f4 <IRQ31_Veener+0x38>)
20000066:	4700      	bx	r0

20000068 <IRQ10_Veener>:
	Insert_InterruptVeener IRQ10	
20000068:	4823      	ldr	r0, [pc, #140]	; (200000f8 <IRQ31_Veener+0x3c>)
2000006a:	4700      	bx	r0

2000006c <IRQ11_Veener>:
	Insert_InterruptVeener IRQ11	
2000006c:	4823      	ldr	r0, [pc, #140]	; (200000fc <IRQ31_Veener+0x40>)
2000006e:	4700      	bx	r0

20000070 <IRQ12_Veener>:
	Insert_InterruptVeener IRQ12	
20000070:	4823      	ldr	r0, [pc, #140]	; (20000100 <IRQ31_Veener+0x44>)
20000072:	4700      	bx	r0

20000074 <IRQ13_Veener>:
	Insert_InterruptVeener IRQ13	
20000074:	4823      	ldr	r0, [pc, #140]	; (20000104 <IRQ31_Veener+0x48>)
20000076:	4700      	bx	r0

20000078 <IRQ14_Veener>:
	Insert_InterruptVeener IRQ14	
20000078:	4823      	ldr	r0, [pc, #140]	; (20000108 <IRQ31_Veener+0x4c>)
2000007a:	4700      	bx	r0

2000007c <IRQ15_Veener>:
	Insert_InterruptVeener IRQ15	
2000007c:	4823      	ldr	r0, [pc, #140]	; (2000010c <IRQ31_Veener+0x50>)
2000007e:	4700      	bx	r0

20000080 <IRQ16_Veener>:
	Insert_InterruptVeener IRQ16	
20000080:	4823      	ldr	r0, [pc, #140]	; (20000110 <IRQ31_Veener+0x54>)
20000082:	4700      	bx	r0

20000084 <IRQ17_Veener>:
	Insert_InterruptVeener IRQ17	
20000084:	4823      	ldr	r0, [pc, #140]	; (20000114 <IRQ31_Veener+0x58>)
20000086:	4700      	bx	r0

20000088 <IRQ18_Veener>:
	Insert_InterruptVeener IRQ18	
20000088:	4823      	ldr	r0, [pc, #140]	; (20000118 <IRQ31_Veener+0x5c>)
2000008a:	4700      	bx	r0

2000008c <IRQ19_Veener>:
	Insert_InterruptVeener IRQ19	
2000008c:	4823      	ldr	r0, [pc, #140]	; (2000011c <IRQ31_Veener+0x60>)
2000008e:	4700      	bx	r0

20000090 <IRQ20_Veener>:
	Insert_InterruptVeener IRQ20
20000090:	4823      	ldr	r0, [pc, #140]	; (20000120 <IRQ31_Veener+0x64>)
20000092:	4700      	bx	r0

20000094 <IRQ21_Veener>:
	Insert_InterruptVeener IRQ21
20000094:	4823      	ldr	r0, [pc, #140]	; (20000124 <IRQ31_Veener+0x68>)
20000096:	4700      	bx	r0

20000098 <IRQ22_Veener>:
	Insert_InterruptVeener IRQ22	
20000098:	4823      	ldr	r0, [pc, #140]	; (20000128 <IRQ31_Veener+0x6c>)
2000009a:	4700      	bx	r0

2000009c <IRQ23_Veener>:
	Insert_InterruptVeener IRQ23	
2000009c:	4823      	ldr	r0, [pc, #140]	; (2000012c <IRQ31_Veener+0x70>)
2000009e:	4700      	bx	r0

200000a0 <IRQ24_Veener>:
	Insert_InterruptVeener IRQ24	
200000a0:	4823      	ldr	r0, [pc, #140]	; (20000130 <IRQ31_Veener+0x74>)
200000a2:	4700      	bx	r0

200000a4 <IRQ25_Veener>:
	Insert_InterruptVeener IRQ25	
200000a4:	4823      	ldr	r0, [pc, #140]	; (20000134 <IRQ31_Veener+0x78>)
200000a6:	4700      	bx	r0

200000a8 <IRQ26_Veener>:
	Insert_InterruptVeener IRQ26	
200000a8:	4823      	ldr	r0, [pc, #140]	; (20000138 <IRQ31_Veener+0x7c>)
200000aa:	4700      	bx	r0

200000ac <IRQ27_Veener>:
	Insert_InterruptVeener IRQ27	
200000ac:	4823      	ldr	r0, [pc, #140]	; (2000013c <IRQ31_Veener+0x80>)
200000ae:	4700      	bx	r0

200000b0 <IRQ28_Veener>:
	Insert_InterruptVeener IRQ28	
200000b0:	4823      	ldr	r0, [pc, #140]	; (20000140 <IRQ31_Veener+0x84>)
200000b2:	4700      	bx	r0

200000b4 <IRQ29_Veener>:
	Insert_InterruptVeener IRQ29	
200000b4:	4823      	ldr	r0, [pc, #140]	; (20000144 <IRQ31_Veener+0x88>)
200000b6:	4700      	bx	r0

200000b8 <IRQ30_Veener>:
	Insert_InterruptVeener IRQ30	
200000b8:	4823      	ldr	r0, [pc, #140]	; (20000148 <IRQ31_Veener+0x8c>)
200000ba:	4700      	bx	r0

200000bc <IRQ31_Veener>:
	Insert_InterruptVeener IRQ31	
200000bc:	4823      	ldr	r0, [pc, #140]	; (2000014c <IRQ31_Veener+0x90>)
200000be:	4700      	bx	r0
/* ==================VENEERS VENEERS VENEERS VENEERS VENEERS=============== */
    .section ".XmcVeneerCode","ax",%progbits
    
    .align 1
    
	Insert_InterruptVeener HardFault
200000c0:	1000109d 	.word	0x1000109d
    .long 0
    .long 0
    .long 0
    .long 0
    .long 0
	Insert_InterruptVeener SVC
200000c4:	10003ce9 	.word	0x10003ce9
    .long 0
    .long 0
	Insert_InterruptVeener PendSV	
200000c8:	10003e01 	.word	0x10003e01
	Insert_InterruptVeener SysTick
200000cc:	10003e51 	.word	0x10003e51
	
	Insert_InterruptVeener IRQ0	
200000d0:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ1	
200000d4:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ2	
200000d8:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ3	
200000dc:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ4	
200000e0:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ5	
200000e4:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ6	
200000e8:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ7	
200000ec:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ8	
200000f0:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ9	
200000f4:	10002e79 	.word	0x10002e79
	Insert_InterruptVeener IRQ10	
200000f8:	10003c05 	.word	0x10003c05
	Insert_InterruptVeener IRQ11	
200000fc:	10002e65 	.word	0x10002e65
	Insert_InterruptVeener IRQ12	
20000100:	10003bf1 	.word	0x10003bf1
	Insert_InterruptVeener IRQ13	
20000104:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ14	
20000108:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ15	
2000010c:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ16	
20000110:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ17	
20000114:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ18	
20000118:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ19	
2000011c:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ20
20000120:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ21
20000124:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ22	
20000128:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ23	
2000012c:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ24	
20000130:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ25	
20000134:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ26	
20000138:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ27	
2000013c:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ28	
20000140:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ29	
20000144:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ30	
20000148:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ31	
2000014c:	1000109d 	.word	0x1000109d
